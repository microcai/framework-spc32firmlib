/*******************************************************************************
* @file     SPC1068_BITFIELD.h
* @brief    SPC1068_BITFIELD driver module header file.
* @version  V1.2.0
* @date     05-Feb-2021
*
* @note
* Copyright (C) 2021 Spintrol Limited Corporation. All rights reserved.
*
* @attention
* THIS SOFTWARE JUST PROVIDES CUSTOMERS WITH CODING INFORMATION REGARDING 
* THEIR PRODUCTS, WHICH AIMS AT SAVING TIME FOR THEM. SPINTROL SHALL NOT BE
* LIABLE FOR THE USE OF THE SOFTWARE. SPINTROL DOES NOT GUARANTEE THE 
* CORRECTNESS OF THIS SOFTWARE AND RESERVES THE RIGHT TO MODIFY THE SOFTWARE 
* WITHOUT NOTIFICATION.
*
******************************************************************************/


#ifndef SPC1068_BITFIELD_H
#define SPC1068_BITFIELD_H

#ifdef __cplusplus
extern "C" {
#endif




/********************************************************************************
*
* Module Name     WDT1
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTLOAD         VAL
 *  @access     WDT->WDTLOAD.bit.VAL
 *  @brief      Load value
 *              The value from which the counter is to decrease. When this register is written to, the count is immediately restarted from the new value. The minimum valid value is 1.
 */
#define WDTLOAD_ALL_VAL_Pos (0)
#define WDTLOAD_ALL_VAL_Msk (0xFFFFFFFFUL << WDTLOAD_ALL_VAL_Pos)

#define WDTLOAD_BIT_VAL

#define WDTLOAD_ALL_VAL_(x) ((x) << WDTLOAD_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTCNT          VAL
 *  @access     WDT->WDTCNT.bit.VAL
 *  @brief      Current value of the decrementing counter
 */
#define WDTCNT_ALL_VAL_Pos (0)
#define WDTCNT_ALL_VAL_Msk (0xFFFFFFFFUL << WDTCNT_ALL_VAL_Pos)

#define WDTCNT_BIT_VAL

#define WDTCNT_ALL_VAL_(x) ((x) << WDTCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTCTL          INTEN
 *  @access     WDT->WDTCTL.bit.INTEN
 *  @brief      Enable the interrupt event
 *              Reloads the counter from WDTLOAD when the interrupt upon a rising edge of this bit.
 */
#define WDTCTL_ALL_INTEN_Pos (0)
#define WDTCTL_ALL_INTEN_Msk (0x1UL << WDTCTL_ALL_INTEN_Pos)

typedef enum
{
    WDTCTL_BIT_INTEN_DISABLE     = 0,  /*!< Disable the counter and the interrupt   */
    WDTCTL_BIT_INTEN_ENABLE      = 1,  /*!< Enable the counter and the interrupt    */
} WDTCTL_BIT_INTEN;

#define WDTCTL_ALL_INTEN_DISABLE     ((0x0UL) << WDTCTL_ALL_INTEN_Pos)
#define WDTCTL_ALL_INTEN_ENABLE      ((0x1UL) << WDTCTL_ALL_INTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTCTL          RSTEN
 *  @access     WDT->WDTCTL.bit.RSTEN
 *  @brief      Enable watchdog reset output, Acts as a mask for the reset output
 */
#define WDTCTL_ALL_RSTEN_Pos (1)
#define WDTCTL_ALL_RSTEN_Msk (0x1UL << WDTCTL_ALL_RSTEN_Pos)

typedef enum
{
    WDTCTL_BIT_RSTEN_DISABLE     = 0,  /*!< Disable the reset request   */
    WDTCTL_BIT_RSTEN_ENABLE      = 1,  /*!< Enable the reset request    */
} WDTCTL_BIT_RSTEN;

#define WDTCTL_ALL_RSTEN_DISABLE     ((0x0UL) << WDTCTL_ALL_RSTEN_Pos)
#define WDTCTL_ALL_RSTEN_ENABLE      ((0x1UL) << WDTCTL_ALL_RSTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTIC           VAL
 *  @access     WDT->WDTIC.bit.VAL
 *  @brief      Interrupt clear register
 *              A write of any value to this register clears the watchdog interrupt, and reloads the counter from WDTLOAD.
 */
#define WDTIC_ALL_VAL_Pos (0)
#define WDTIC_ALL_VAL_Msk (0xFFFFFFFFUL << WDTIC_ALL_VAL_Pos)

#define WDTIC_BIT_VAL

#define WDTIC_ALL_VAL_(x) ((x) << WDTIC_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTRAWIF        RAWINT
 *  @access     WDT->WDTRAWIF.bit.RAWINT
 *  @brief      Raw interrupt status from the counter
 *              This register indicates the raw interrupt status from the counter. The value is ANDed with WDTCTL.INTEN to create the masked interrupt, which is passed to the interrupt output pin.
 */
#define WDTRAWIF_ALL_RAWINT_Pos (0)
#define WDTRAWIF_ALL_RAWINT_Msk (0x1UL << WDTRAWIF_ALL_RAWINT_Pos)

typedef enum
{
    WDTRAWIF_BIT_RAWINT_NOT_OCCUR     = 0,  /*!< Interrupt not occurred   */
    WDTRAWIF_BIT_RAWINT_OCCUR         = 1,  /*!< Interrupt occurred       */
} WDTRAWIF_BIT_RAWINT;

#define WDTRAWIF_ALL_RAWINT_NOT_OCCUR     ((0x0UL) << WDTRAWIF_ALL_RAWINT_Pos)
#define WDTRAWIF_ALL_RAWINT_OCCUR         ((0x1UL) << WDTRAWIF_ALL_RAWINT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTIF           INT
 *  @access     WDT->WDTIF.bit.INT
 *  @brief      Masked interrupt status from the counter
 *              This register indicates the masked interrupt status from the counter. This value is the logical AND of WDTRAWIF.RAWINT and WDTCTL.INTEN, and is the same value that is passed to the interrupt output pin.
 */
#define WDTIF_ALL_INT_Pos (0)
#define WDTIF_ALL_INT_Msk (0x1UL << WDTIF_ALL_INT_Pos)

typedef enum
{
    WDTIF_BIT_INT_NOT_OCCUR     = 0,  /*!< Interrupt not occurred   */
    WDTIF_BIT_INT_OCCUR         = 1,  /*!< Interrupt occurred       */
} WDTIF_BIT_INT;

#define WDTIF_ALL_INT_NOT_OCCUR     ((0x0UL) << WDTIF_ALL_INT_Pos)
#define WDTIF_ALL_INT_OCCUR         ((0x1UL) << WDTIF_ALL_INT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTLOCK         LCKSTS
 *  @access     WDT->WDTLOCK.bit.LCKSTS
 *  @brief      Register write lock status
 */
#define WDTLOCK_ALL_LCKSTS_Pos (0)
#define WDTLOCK_ALL_LCKSTS_Msk (0x1UL << WDTLOCK_ALL_LCKSTS_Pos)

typedef enum
{
    WDTLOCK_BIT_LCKSTS_UNLOCK     = 0,  /*!< Write access to all other registers is enabled (not locked)   */
    WDTLOCK_BIT_LCKSTS_LOCK       = 1,  /*!< Write access to all other registers is disabled (locked)      */
} WDTLOCK_BIT_LCKSTS;

#define WDTLOCK_ALL_LCKSTS_UNLOCK     ((0x0UL) << WDTLOCK_ALL_LCKSTS_Pos)
#define WDTLOCK_ALL_LCKSTS_LOCK       ((0x1UL) << WDTLOCK_ALL_LCKSTS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   WDT             WDTLOCK         LCKCTL
 *  @access     WDT->WDTLOCK.bit.LCKCTL
 *  @brief      Enable register writes
 *              Enable write access to all other registers by writing 0x1ACCE551.
 *              Disable write access by writing any other value.
 */
#define WDTLOCK_ALL_LCKCTL_Pos (1)
#define WDTLOCK_ALL_LCKCTL_Msk (0x7FFFFFFFUL << WDTLOCK_ALL_LCKCTL_Pos)

#define WDTLOCK_BIT_LCKCTL

#define WDTLOCK_ALL_LCKCTL_(x) ((x) << WDTLOCK_ALL_LCKCTL_Pos)





/********************************************************************************
*
* Module Name     TIMER0
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   TIMER           TMRCTL          EN
 *  @access     TIMER->TMRCTL.bit.EN
 *  @brief      Timer Enable bit
 */
#define TMRCTL_ALL_EN_Pos (0)
#define TMRCTL_ALL_EN_Msk (0x1UL << TMRCTL_ALL_EN_Pos)

typedef enum
{
    TMRCTL_BIT_EN_DISABLE     = 0,  /*!< Disable Timer   */
    TMRCTL_BIT_EN_ENABLE      = 1,  /*!< Enable Timer    */
} TMRCTL_BIT_EN;

#define TMRCTL_ALL_EN_DISABLE     ((0x0UL) << TMRCTL_ALL_EN_Pos)
#define TMRCTL_ALL_EN_ENABLE      ((0x1UL) << TMRCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   TIMER           TMRCTL          EXINT4EN
 *  @access     TIMER->TMRCTL.bit.EXINT4EN
 *  @brief      Select external input as timer enable
 */
#define TMRCTL_ALL_EXINT4EN_Pos (1)
#define TMRCTL_ALL_EXINT4EN_Msk (0x1UL << TMRCTL_ALL_EXINT4EN_Pos)

typedef enum
{
    TMRCTL_BIT_EXINT4EN_NOT_SEL_EXTERNAL     = 0,  /*!< Disable select external input as timer enable   */
    TMRCTL_BIT_EXINT4EN_SEL_EXTERNAL         = 1,  /*!< Enable select external input as timer enable    */
} TMRCTL_BIT_EXINT4EN;

#define TMRCTL_ALL_EXINT4EN_NOT_SEL_EXTERNAL     ((0x0UL) << TMRCTL_ALL_EXINT4EN_Pos)
#define TMRCTL_ALL_EXINT4EN_SEL_EXTERNAL         ((0x1UL) << TMRCTL_ALL_EXINT4EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   TIMER           TMRCTL          EXINT4CLK
 *  @access     TIMER->TMRCTL.bit.EXINT4CLK
 *  @brief      Select external input as timer clock
 */
#define TMRCTL_ALL_EXINT4CLK_Pos (2)
#define TMRCTL_ALL_EXINT4CLK_Msk (0x1UL << TMRCTL_ALL_EXINT4CLK_Pos)

typedef enum
{
    TMRCTL_BIT_EXINT4CLK_SEL_INTERNAL_CLK     = 0,  /*!< Disable select external input as timer clock   */
    TMRCTL_BIT_EXINT4CLK_SEL_EXTERNAL_CLK     = 1,  /*!< Enable Select external input as timer clock    */
} TMRCTL_BIT_EXINT4CLK;

#define TMRCTL_ALL_EXINT4CLK_SEL_INTERNAL_CLK     ((0x0UL) << TMRCTL_ALL_EXINT4CLK_Pos)
#define TMRCTL_ALL_EXINT4CLK_SEL_EXTERNAL_CLK     ((0x1UL) << TMRCTL_ALL_EXINT4CLK_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   TIMER           TMRCTL          INTEN
 *  @access     TIMER->TMRCTL.bit.INTEN
 *  @brief      Timer interrupt enable bit
 */
#define TMRCTL_ALL_INTEN_Pos (3)
#define TMRCTL_ALL_INTEN_Msk (0x1UL << TMRCTL_ALL_INTEN_Pos)

typedef enum
{
    TMRCTL_BIT_INTEN_DISABLE     = 0,  /*!< Disable timer interrupt   */
    TMRCTL_BIT_INTEN_ENABLE      = 1,  /*!< Enable timer interrupt    */
} TMRCTL_BIT_INTEN;

#define TMRCTL_ALL_INTEN_DISABLE     ((0x0UL) << TMRCTL_ALL_INTEN_Pos)
#define TMRCTL_ALL_INTEN_ENABLE      ((0x1UL) << TMRCTL_ALL_INTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   TIMER           TMRCNT          VAL
 *  @access     TIMER->TMRCNT.bit.VAL
 *  @brief      Current value of timer counter
 */
#define TMRCNT_ALL_VAL_Pos (0)
#define TMRCNT_ALL_VAL_Msk (0xFFFFFFFFUL << TMRCNT_ALL_VAL_Pos)

#define TMRCNT_BIT_VAL

#define TMRCNT_ALL_VAL_(x) ((x) << TMRCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   TIMER           TMRRELOAD       VAL
 *  @access     TIMER->TMRRELOAD.bit.VAL
 *  @brief      Reload value, A Write to this registers sets the current value
 */
#define TMRRELOAD_ALL_VAL_Pos (0)
#define TMRRELOAD_ALL_VAL_Msk (0xFFFFFFFFUL << TMRRELOAD_ALL_VAL_Pos)

#define TMRRELOAD_BIT_VAL

#define TMRRELOAD_ALL_VAL_(x) ((x) << TMRRELOAD_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   TIMER           TMRIF           INT
 *  @access     TIMER->TMRIF.bit.INT
 *  @brief      Timer interrupt, Write one to clear
 */
#define TMRIF_ALL_INT_Pos (0)
#define TMRIF_ALL_INT_Msk (0x1UL << TMRIF_ALL_INT_Pos)

typedef enum
{
    TMRIF_BIT_INT_NOT_OCCUR     = 0,  /*!< Read a 0 indicates there is no timer interrupt  
                                           Write a 0 has no effect                          */
    TMRIF_BIT_INT_OCCUR         = 1,  /*!< Read a 1 indicates a timer interrupt event      
                                           Write a 1 clear the timer interrupt              */
} TMRIF_BIT_INT;

#define TMRIF_ALL_INT_NOT_OCCUR     ((0x0UL) << TMRIF_ALL_INT_Pos)
#define TMRIF_ALL_INT_OCCUR         ((0x1UL) << TMRIF_ALL_INT_Pos)





/********************************************************************************
*
* Module Name     GPIO
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GPLR0           VAL
 *  @access     GPIO->GPLR0.bit.VAL
 *  @brief      GPIOn pin level readback (n = 0~31)
 *              0: GPIOn is low level
 *              1: GPIOn is high level
 */
#define GPLR0_ALL_VAL_Pos (0)
#define GPLR0_ALL_VAL_Msk (0xFFFFFFFFUL << GPLR0_ALL_VAL_Pos)

#define GPLR0_BIT_VAL

#define GPLR0_ALL_VAL_(x) ((x) << GPLR0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GPLR1           VAL
 *  @access     GPIO->GPLR1.bit.VAL
 *  @brief      GPIOn pin level readback (n = 32~35)
 *              0: GPIOn is low level
 *              1: GPIOn is high level
 */
#define GPLR1_ALL_VAL_Pos (0)
#define GPLR1_ALL_VAL_Msk (0xFUL << GPLR1_ALL_VAL_Pos)

#define GPLR1_BIT_VAL

#define GPLR1_ALL_VAL_(x) ((x) << GPLR1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GPDR0           VAL
 *  @access     GPIO->GPDR0.bit.VAL
 *  @brief      Set GPIOn direction (n = 0~31)
 *              0: Set GPIOn as input
 *              1: Set GPIOn as output
 */
#define GPDR0_ALL_VAL_Pos (0)
#define GPDR0_ALL_VAL_Msk (0xFFFFFFFFUL << GPDR0_ALL_VAL_Pos)

#define GPDR0_BIT_VAL

#define GPDR0_ALL_VAL_(x) ((x) << GPDR0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GPDR1           VAL
 *  @access     GPIO->GPDR1.bit.VAL
 *  @brief      Set GPIOn direction (n = 32~35)
 *              0: Set GPIOn as input
 *              1: Set GPIOn as output
 */
#define GPDR1_ALL_VAL_Pos (0)
#define GPDR1_ALL_VAL_Msk (0xFUL << GPDR1_ALL_VAL_Pos)

#define GPDR1_BIT_VAL

#define GPDR1_ALL_VAL_(x) ((x) << GPDR1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GPSR0           VAL
 *  @access     GPIO->GPSR0.bit.VAL
 *  @brief      Set GPIOn output high (n = 0~31)
 *              0: Unaffected
 *              1: Set GPIOn output to high
 */
#define GPSR0_ALL_VAL_Pos (0)
#define GPSR0_ALL_VAL_Msk (0xFFFFFFFFUL << GPSR0_ALL_VAL_Pos)

#define GPSR0_BIT_VAL

#define GPSR0_ALL_VAL_(x) ((x) << GPSR0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GPSR1           VAL
 *  @access     GPIO->GPSR1.bit.VAL
 *  @brief      Set GPIOn output value (n = 32~35)
 *              0: Unaffected
 *              1: Set GPIOn output to high
 */
#define GPSR1_ALL_VAL_Pos (0)
#define GPSR1_ALL_VAL_Msk (0xFUL << GPSR1_ALL_VAL_Pos)

#define GPSR1_BIT_VAL

#define GPSR1_ALL_VAL_(x) ((x) << GPSR1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GPCR0           VAL
 *  @access     GPIO->GPCR0.bit.VAL
 *  @brief      Set GPIOn output low (n = 0~31)
 *              0: Unaffected
 *              1: Set GPIOn output to low
 */
#define GPCR0_ALL_VAL_Pos (0)
#define GPCR0_ALL_VAL_Msk (0xFFFFFFFFUL << GPCR0_ALL_VAL_Pos)

#define GPCR0_BIT_VAL

#define GPCR0_ALL_VAL_(x) ((x) << GPCR0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GPCR1           VAL
 *  @access     GPIO->GPCR1.bit.VAL
 *  @brief      Set GPIOn output low (n = 32~35)
 *              0: Unaffected
 *              1: Set GPIOn output to low
 */
#define GPCR1_ALL_VAL_Pos (0)
#define GPCR1_ALL_VAL_Msk (0xFUL << GPCR1_ALL_VAL_Pos)

#define GPCR1_BIT_VAL

#define GPCR1_ALL_VAL_(x) ((x) << GPCR1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GRER0           VAL
 *  @access     GPIO->GRER0.bit.VAL
 *  @brief      Enable GPIOn rising edge detect (n = 0~31)
 *              0: Disable rising edge detection on GPIOn
 *              1: Enable rising edge detection on GPIOn
 */
#define GRER0_ALL_VAL_Pos (0)
#define GRER0_ALL_VAL_Msk (0xFFFFFFFFUL << GRER0_ALL_VAL_Pos)

#define GRER0_BIT_VAL

#define GRER0_ALL_VAL_(x) ((x) << GRER0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GRER1           VAL
 *  @access     GPIO->GRER1.bit.VAL
 *  @brief      Enable GPIOn rising edge detect (n = 32~35)
 *              0: Disable rising edge detection on GPIOn
 *              1: Enable rising edge detection on GPIOn
 */
#define GRER1_ALL_VAL_Pos (0)
#define GRER1_ALL_VAL_Msk (0xFUL << GRER1_ALL_VAL_Pos)

#define GRER1_BIT_VAL

#define GRER1_ALL_VAL_(x) ((x) << GRER1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GFER0           VAL
 *  @access     GPIO->GFER0.bit.VAL
 *  @brief      Enable GPIOn falling edge detect (n = 0~31)
 *              0: Disable falling edge detection on GPIOn
 *              1: Enable falling edge detection on GPIOn
 */
#define GFER0_ALL_VAL_Pos (0)
#define GFER0_ALL_VAL_Msk (0xFFFFFFFFUL << GFER0_ALL_VAL_Pos)

#define GFER0_BIT_VAL

#define GFER0_ALL_VAL_(x) ((x) << GFER0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GFER1           VAL
 *  @access     GPIO->GFER1.bit.VAL
 *  @brief      Enable GPIOn falling edge detect (n = 32~35)
 *              0: Disable falling edge detection on GPIOn
 *              1: Enable falling edge detection on GPIOn
 */
#define GFER1_ALL_VAL_Pos (0)
#define GFER1_ALL_VAL_Msk (0xFUL << GFER1_ALL_VAL_Pos)

#define GFER1_BIT_VAL

#define GFER1_ALL_VAL_(x) ((x) << GFER1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GEDR0           VAL
 *  @access     GPIO->GEDR0.bit.VAL
 *  @brief      GPIOn edge detect status (n = 0~31)
 *              0: Read 0 indicates no detected rising or falling edge
 *              Write a 0 has no effect
 *              1: Read 1 indicates edge was detected
 *              Write 1 will clear the latched status
 */
#define GEDR0_ALL_VAL_Pos (0)
#define GEDR0_ALL_VAL_Msk (0xFFFFFFFFUL << GEDR0_ALL_VAL_Pos)

#define GEDR0_BIT_VAL

#define GEDR0_ALL_VAL_(x) ((x) << GEDR0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GEDR1           VAL
 *  @access     GPIO->GEDR1.bit.VAL
 *  @brief      GPIOn edge detect status (n = 32~35)
 *              0: Read 0 indicates no detected rising or falling edge
 *              Write a 0 has no effect
 *              1: Read 1 indicates edge was detected
 *              Write 1 will clear the latched status
 */
#define GEDR1_ALL_VAL_Pos (0)
#define GEDR1_ALL_VAL_Msk (0xFUL << GEDR1_ALL_VAL_Pos)

#define GEDR1_BIT_VAL

#define GEDR1_ALL_VAL_(x) ((x) << GEDR1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GSDR0           VAL
 *  @access     GPIO->GSDR0.bit.VAL
 *  @brief      Set GPDR register bit (n = 0~31)
 *              0: Unaffected
 *              1: Set  GPDR bit and set GPIOn as output
 */
#define GSDR0_ALL_VAL_Pos (0)
#define GSDR0_ALL_VAL_Msk (0xFFFFFFFFUL << GSDR0_ALL_VAL_Pos)

#define GSDR0_BIT_VAL

#define GSDR0_ALL_VAL_(x) ((x) << GSDR0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GSDR1           VAL
 *  @access     GPIO->GSDR1.bit.VAL
 *  @brief      Set GPDR register bit (n = 32~35)
 *              0: Unaffected
 *              1: Set  GPDR bit and set GPIOn as output
 */
#define GSDR1_ALL_VAL_Pos (0)
#define GSDR1_ALL_VAL_Msk (0xFUL << GSDR1_ALL_VAL_Pos)

#define GSDR1_BIT_VAL

#define GSDR1_ALL_VAL_(x) ((x) << GSDR1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GCDR0           VAL
 *  @access     GPIO->GCDR0.bit.VAL
 *  @brief      Clear GPDR register bit (n = 0~31)
 *              0: Unaffected
 *              1: Clear  GPDR bit and set GPIOn as input
 */
#define GCDR0_ALL_VAL_Pos (0)
#define GCDR0_ALL_VAL_Msk (0xFFFFFFFFUL << GCDR0_ALL_VAL_Pos)

#define GCDR0_BIT_VAL

#define GCDR0_ALL_VAL_(x) ((x) << GCDR0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GCDR1           VAL
 *  @access     GPIO->GCDR1.bit.VAL
 *  @brief      Clear GPDR register bit (n = 32~35)
 *              0: Unaffected
 *              1: Clear  GPDR bit and set GPIOn as input
 */
#define GCDR1_ALL_VAL_Pos (0)
#define GCDR1_ALL_VAL_Msk (0xFUL << GCDR1_ALL_VAL_Pos)

#define GCDR1_BIT_VAL

#define GCDR1_ALL_VAL_(x) ((x) << GCDR1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GSRER0          VAL
 *  @access     GPIO->GSRER0.bit.VAL
 *  @brief      Set GRER register bit (n = 0~31)
 *              0: Unaffected
 *              1: Set GRER bit and enable rising edge detect for GPIOn
 */
#define GSRER0_ALL_VAL_Pos (0)
#define GSRER0_ALL_VAL_Msk (0xFFFFFFFFUL << GSRER0_ALL_VAL_Pos)

#define GSRER0_BIT_VAL

#define GSRER0_ALL_VAL_(x) ((x) << GSRER0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GSRER1          VAL
 *  @access     GPIO->GSRER1.bit.VAL
 *  @brief      Set GRER register bit (n = 32~35)
 *              0: Unaffected
 *              1: Set GRER bit and enable rising edge detect for GPIOn
 */
#define GSRER1_ALL_VAL_Pos (0)
#define GSRER1_ALL_VAL_Msk (0xFUL << GSRER1_ALL_VAL_Pos)

#define GSRER1_BIT_VAL

#define GSRER1_ALL_VAL_(x) ((x) << GSRER1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GCRER0          VAL
 *  @access     GPIO->GCRER0.bit.VAL
 *  @brief      Clear GRER register bit (n = 0~31)
 *              0: Unaffected
 *              1: Clear GRER bit and disable rising edge detect for GPIOn
 */
#define GCRER0_ALL_VAL_Pos (0)
#define GCRER0_ALL_VAL_Msk (0xFFFFFFFFUL << GCRER0_ALL_VAL_Pos)

#define GCRER0_BIT_VAL

#define GCRER0_ALL_VAL_(x) ((x) << GCRER0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GCRER1          VAL
 *  @access     GPIO->GCRER1.bit.VAL
 *  @brief      Clear GRER register bit (n = 32~35)
 *              0: Unaffected
 *              1: Clear GRER bit and disable rising edge detect for GPIOn
 */
#define GCRER1_ALL_VAL_Pos (0)
#define GCRER1_ALL_VAL_Msk (0xFUL << GCRER1_ALL_VAL_Pos)

#define GCRER1_BIT_VAL

#define GCRER1_ALL_VAL_(x) ((x) << GCRER1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GSFER0          VAL
 *  @access     GPIO->GSFER0.bit.VAL
 *  @brief      Set GFER register bit (n = 0~31)
 *              0: Unaffected
 *              1: Set GFER bit and enable falling edge detect for GPIOn
 */
#define GSFER0_ALL_VAL_Pos (0)
#define GSFER0_ALL_VAL_Msk (0xFFFFFFFFUL << GSFER0_ALL_VAL_Pos)

#define GSFER0_BIT_VAL

#define GSFER0_ALL_VAL_(x) ((x) << GSFER0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GSFER1          VAL
 *  @access     GPIO->GSFER1.bit.VAL
 *  @brief      Set GFER register bit (n = 0~31)
 *              0: Unaffected
 *              1: Set GFER bit and enable falling edge detect for GPIOn
 */
#define GSFER1_ALL_VAL_Pos (0)
#define GSFER1_ALL_VAL_Msk (0xFUL << GSFER1_ALL_VAL_Pos)

#define GSFER1_BIT_VAL

#define GSFER1_ALL_VAL_(x) ((x) << GSFER1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GCFER0          VAL
 *  @access     GPIO->GCFER0.bit.VAL
 *  @brief      Clear GFER register bit (n = 0~31)
 *              0: Unaffected
 *              1: Clear GFER bit and disable falling edge detect for GPIOn
 */
#define GCFER0_ALL_VAL_Pos (0)
#define GCFER0_ALL_VAL_Msk (0xFFFFFFFFUL << GCFER0_ALL_VAL_Pos)

#define GCFER0_BIT_VAL

#define GCFER0_ALL_VAL_(x) ((x) << GCFER0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            GCFER1          VAL
 *  @access     GPIO->GCFER1.bit.VAL
 *  @brief      Clear GFER register bit (n = 32~35)
 *              0: Unaffected
 *              1: Clear GFER bit and disable falling edge detect for GPIOn
 */
#define GCFER1_ALL_VAL_Pos (0)
#define GCFER1_ALL_VAL_Msk (0xFUL << GCFER1_ALL_VAL_Pos)

#define GCFER1_BIT_VAL

#define GCFER1_ALL_VAL_(x) ((x) << GCFER1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            APMSK0          VAL
 *  @access     GPIO->APMSK0.bit.VAL
 *  @brief      Enable GPIOn edge detect (n = 0~31)
 *              0: Disable GPIOn edge detect
 *              1: Enable GPIOn edge detect
 */
#define APMSK0_ALL_VAL_Pos (0)
#define APMSK0_ALL_VAL_Msk (0xFFFFFFFFUL << APMSK0_ALL_VAL_Pos)

#define APMSK0_BIT_VAL

#define APMSK0_ALL_VAL_(x) ((x) << APMSK0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GPIO            APMSK1          VAL
 *  @access     GPIO->APMSK1.bit.VAL
 *  @brief      Enable GPIOn edge detect (n = 32~35)
 *              0: Disable GPIOn edge detect
 *              1: Enable GPIOn edge detect
 */
#define APMSK1_ALL_VAL_Pos (0)
#define APMSK1_ALL_VAL_Msk (0xFUL << APMSK1_ALL_VAL_Pos)

#define APMSK1_BIT_VAL

#define APMSK1_ALL_VAL_(x) ((x) << APMSK1_ALL_VAL_Pos)





/********************************************************************************
*
* Module Name     UART
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTRBR         VAL
 *  @access     UART->UARTRBR.bit.VAL
 *  @brief      In non-FIFO mode, this register holds the characters received by the UART Receive Shift Register. If this register is configured to use fewer than eight bits, the bits are right-justified and the most significant bits (MSB) are zeroed. Reading the register empties the register and clears the <Data Ready> field in the Line Status Register. UARTRBR latches the value of the data byte at the front of the FIFO in FIFO mode.
 */
#define UARTRBR_ALL_VAL_Pos (0)
#define UARTRBR_ALL_VAL_Msk (0xFFFFFFFFUL << UARTRBR_ALL_VAL_Pos)

#define UARTRBR_BIT_VAL

#define UARTRBR_ALL_VAL_(x) ((x) << UARTRBR_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTTHR         VAL
 *  @access     UART->UARTTHR.bit.VAL
 *  @brief      This register holds the data byte to be transmitted next in non-FIFO mode. When the Transmit Shift Register (TSR) is emptied, the contents of this register are loaded into the Transmit Shift Register and the <Transmit Data Request> field in the Line Status Register is set.
 *              A write to Transmit Holding Register puts data into the top of the FIFO in FIFO mode. The data at the front of the FIFO is loaded into the TSR when the TSR is empty.
 */
#define UARTTHR_ALL_VAL_Pos (0)
#define UARTTHR_ALL_VAL_Msk (0xFFFFFFFFUL << UARTTHR_ALL_VAL_Pos)

#define UARTTHR_BIT_VAL

#define UARTTHR_ALL_VAL_(x) ((x) << UARTTHR_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTDLL         VAL
 *  @access     UART->UARTDLL.bit.VAL
 *  @brief      Low-byte compare value to generate baud rate
 */
#define UARTDLL_ALL_VAL_Pos (0)
#define UARTDLL_ALL_VAL_Msk (0xFFUL << UARTDLL_ALL_VAL_Pos)

#define UARTDLL_BIT_VAL

#define UARTDLL_ALL_VAL_(x) ((x) << UARTDLL_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTDLH         VAL
 *  @access     UART->UARTDLH.bit.VAL
 *  @brief      High-byte compare value to generate baud rate
 */
#define UARTDLH_ALL_VAL_Pos (0)
#define UARTDLH_ALL_VAL_Msk (0xFFUL << UARTDLH_ALL_VAL_Pos)

#define UARTDLH_BIT_VAL

#define UARTDLH_ALL_VAL_(x) ((x) << UARTDLH_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIER         RAVIE
 *  @access     UART->UARTIER.bit.RAVIE
 *  @brief      Receiver Data Available Interrupt Enable
 *              Receiver Data Available Interrupt Enable (Source UARTIIR[IID])
 */
#define UARTIER_ALL_RAVIE_Pos (0)
#define UARTIER_ALL_RAVIE_Msk (0x1UL << UARTIER_ALL_RAVIE_Pos)

typedef enum
{
    UARTIER_BIT_RAVIE_RX_DATA_INT_DISABLE     = 0,  /*!< Receiver data available (trigger threshold reached) interrupt disable   */
    UARTIER_BIT_RAVIE_RX_DATA_INT_ENABLE      = 1,  /*!< Receiver data available (trigger threshold reached) interrupt enabled   */
} UARTIER_BIT_RAVIE;

#define UARTIER_ALL_RAVIE_RX_DATA_INT_DISABLE     ((0x0UL) << UARTIER_ALL_RAVIE_Pos)
#define UARTIER_ALL_RAVIE_RX_DATA_INT_ENABLE      ((0x1UL) << UARTIER_ALL_RAVIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIER         TIE
 *  @access     UART->UARTIER.bit.TIE
 *  @brief      Transmit Data Request Interrupt Enable
 *              Transmit Data Request Interrupt Enable (Source UARTIIR[IID])
 */
#define UARTIER_ALL_TIE_Pos (1)
#define UARTIER_ALL_TIE_Msk (0x1UL << UARTIER_ALL_TIE_Pos)

typedef enum
{
    UARTIER_BIT_TIE_TX_FIFO_INT_DISABLE     = 0,  /*!< Transmit FIFO data request interrupt disabled   */
    UARTIER_BIT_TIE_TX_FIFO_INT_ENABLE      = 1,  /*!< Transmit FIFO data request interrupt enabled    */
} UARTIER_BIT_TIE;

#define UARTIER_ALL_TIE_TX_FIFO_INT_DISABLE     ((0x0UL) << UARTIER_ALL_TIE_Pos)
#define UARTIER_ALL_TIE_TX_FIFO_INT_ENABLE      ((0x1UL) << UARTIER_ALL_TIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIER         RLSE
 *  @access     UART->UARTIER.bit.RLSE
 *  @brief      Receiver Line Status Interrupt Enable
 *              Receiver Line Status Interrupt Enable (Source UARTIIR[IID])
 */
#define UARTIER_ALL_RLSE_Pos (2)
#define UARTIER_ALL_RLSE_Msk (0x1UL << UARTIER_ALL_RLSE_Pos)

typedef enum
{
    UARTIER_BIT_RLSE_RX_LINE_INT_DISABLE     = 0,  /*!< Receiver line status interrupt disabled   */
    UARTIER_BIT_RLSE_RX_LINE_INT_ENABLE      = 1,  /*!< Receiver line status interrupt enabled    */
} UARTIER_BIT_RLSE;

#define UARTIER_ALL_RLSE_RX_LINE_INT_DISABLE     ((0x0UL) << UARTIER_ALL_RLSE_Pos)
#define UARTIER_ALL_RLSE_RX_LINE_INT_ENABLE      ((0x1UL) << UARTIER_ALL_RLSE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIER         MIE
 *  @access     UART->UARTIER.bit.MIE
 *  @brief      Modem Interrupt Enable
 *              Modem Interrupt Enable (Source UARTIIR[IID])
 */
#define UARTIER_ALL_MIE_Pos (3)
#define UARTIER_ALL_MIE_Msk (0x1UL << UARTIER_ALL_MIE_Pos)

typedef enum
{
    UARTIER_BIT_MIE_MODEM_INT_DISABLE     = 0,  /*!< Modem status interrupt disabled   */
    UARTIER_BIT_MIE_MODEM_INT_ENABLE      = 1,  /*!< Modem status interrupt enabled    */
} UARTIER_BIT_MIE;

#define UARTIER_ALL_MIE_MODEM_INT_DISABLE     ((0x0UL) << UARTIER_ALL_MIE_Pos)
#define UARTIER_ALL_MIE_MODEM_INT_ENABLE      ((0x1UL) << UARTIER_ALL_MIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIER         RTOIE
 *  @access     UART->UARTIER.bit.RTOIE
 *  @brief      Receiver Time-out Interrupt Enable
 *              Receiver Time-out Interrupt Enable (Source UARTIIR[TOD])
 */
#define UARTIER_ALL_RTOIE_Pos (4)
#define UARTIER_ALL_RTOIE_Msk (0x1UL << UARTIER_ALL_RTOIE_Pos)

typedef enum
{
    UARTIER_BIT_RTOIE_RX_TIMEOUT_INT_DISABLE     = 0,  /*!< Receiver data time-out interrupt disabled   */
    UARTIER_BIT_RTOIE_RX_TIMEOUT_INT_ENABLE      = 1,  /*!< Receiver data time-out interrupt enabled    */
} UARTIER_BIT_RTOIE;

#define UARTIER_ALL_RTOIE_RX_TIMEOUT_INT_DISABLE     ((0x0UL) << UARTIER_ALL_RTOIE_Pos)
#define UARTIER_ALL_RTOIE_RX_TIMEOUT_INT_ENABLE      ((0x1UL) << UARTIER_ALL_RTOIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIER         NRZE
 *  @access     UART->UARTIER.bit.NRZE
 *  @brief      NRZ coding Enable
 *              NRZ encoding/decoding is used only in UART mode, not in Infrared mode. If the serial infrared receiver or transmitter is enabled, NRZ coding is disabled.
 */
#define UARTIER_ALL_NRZE_Pos (5)
#define UARTIER_ALL_NRZE_Msk (0x1UL << UARTIER_ALL_NRZE_Pos)

typedef enum
{
    UARTIER_BIT_NRZE_NRZ_DISABLE     = 0,  /*!< NRZ coding disabled   */
    UARTIER_BIT_NRZE_NRZ_ENABLE      = 1,  /*!< NRZ coding enabled    */
} UARTIER_BIT_NRZE;

#define UARTIER_ALL_NRZE_NRZ_DISABLE     ((0x0UL) << UARTIER_ALL_NRZE_Pos)
#define UARTIER_ALL_NRZE_NRZ_ENABLE      ((0x1UL) << UARTIER_ALL_NRZE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIER         UUE
 *  @access     UART->UARTIER.bit.UUE
 *  @brief      UART Unit Enable
 */
#define UARTIER_ALL_UUE_Pos (6)
#define UARTIER_ALL_UUE_Msk (0x1UL << UARTIER_ALL_UUE_Pos)

typedef enum
{
    UARTIER_BIT_UUE_UART_DISABLE     = 0,  /*!< The unit is disabled   */
    UARTIER_BIT_UUE_UART_ENABLE      = 1,  /*!< The unit is enabled    */
} UARTIER_BIT_UUE;

#define UARTIER_ALL_UUE_UART_DISABLE     ((0x0UL) << UARTIER_ALL_UUE_Pos)
#define UARTIER_ALL_UUE_UART_ENABLE      ((0x1UL) << UARTIER_ALL_UUE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIIR         NIP
 *  @access     UART->UARTIIR.bit.NIP
 *  @brief      No Interrupt Pending
 */
#define UARTIIR_ALL_NIP_Pos (0)
#define UARTIIR_ALL_NIP_Msk (0x1UL << UARTIIR_ALL_NIP_Pos)

typedef enum
{
    UARTIIR_BIT_NIP_INT_OCCUR         = 0,  /*!< Interrupt is pending (active low)   */
    UARTIIR_BIT_NIP_INT_NOT_OCCUR     = 1,  /*!< No interrupt is pending             */
} UARTIIR_BIT_NIP;

#define UARTIIR_ALL_NIP_INT_OCCUR         ((0x0UL) << UARTIIR_ALL_NIP_Pos)
#define UARTIIR_ALL_NIP_INT_NOT_OCCUR     ((0x1UL) << UARTIIR_ALL_NIP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIIR         IID
 *  @access     UART->UARTIIR.bit.IID
 *  @brief      Interrupt Source Encoded
 */
#define UARTIIR_ALL_IID_Pos (1)
#define UARTIIR_ALL_IID_Msk (0x3UL << UARTIIR_ALL_IID_Pos)

typedef enum
{
    UARTIIR_BIT_IID_MODEM_INT                    = 0,  /*!< Modem Status (CTS, DSR, RI, DCD modem signals changed state), Do not support in SPC1068   */
    UARTIIR_BIT_IID_TX_FIFO_REQUEST_DATA_INT     = 1,  /*!< Transmit FIFO requests data                                                               */
    UARTIIR_BIT_IID_RX_DATA_READY_INT            = 2,  /*!< Received data available                                                                   */
    UARTIIR_BIT_IID_RX_ERROR_INT                 = 3,  /*!< Receive error (Overrun, parity, framing, break, FIFO error)                               */
} UARTIIR_BIT_IID;

#define UARTIIR_ALL_IID_MODEM_INT                    ((0x0UL) << UARTIIR_ALL_IID_Pos)
#define UARTIIR_ALL_IID_TX_FIFO_REQUEST_DATA_INT     ((0x1UL) << UARTIIR_ALL_IID_Pos)
#define UARTIIR_ALL_IID_RX_DATA_READY_INT            ((0x2UL) << UARTIIR_ALL_IID_Pos)
#define UARTIIR_ALL_IID_RX_ERROR_INT                 ((0x3UL) << UARTIIR_ALL_IID_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIIR         TOD
 *  @access     UART->UARTIIR.bit.TOD
 *  @brief      Time Out Detected
 */
#define UARTIIR_ALL_TOD_Pos (3)
#define UARTIIR_ALL_TOD_Msk (0x1UL << UARTIIR_ALL_TOD_Pos)

typedef enum
{
    UARTIIR_BIT_TOD_TIMEOUT_NOT_OCCUR     = 0,  /*!< No time out interrupt is pending                 */
    UARTIIR_BIT_TOD_TIMEOUT_OCCUR         = 1,  /*!< Time out interrupt is pending (FIFO mode only)   */
} UARTIIR_BIT_TOD;

#define UARTIIR_ALL_TOD_TIMEOUT_NOT_OCCUR     ((0x0UL) << UARTIIR_ALL_TOD_Pos)
#define UARTIIR_ALL_TOD_TIMEOUT_OCCUR         ((0x1UL) << UARTIIR_ALL_TOD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIIR         ABL
 *  @access     UART->UARTIIR.bit.ABL
 *  @brief      Auto-baud Lock
 */
#define UARTIIR_ALL_ABL_Pos (4)
#define UARTIIR_ALL_ABL_Msk (0x1UL << UARTIIR_ALL_ABL_Pos)

typedef enum
{
    UARTIIR_BIT_ABL_AUTO_BAUD_NOT_LOCK     = 0,  /*!< Auto-baud circuitry has not programmed Divisor Latch registers (DLR)   */
    UARTIIR_BIT_ABL_AUTO_BAUD_LOCK         = 1,  /*!< Divisor Latch registers (DLR) programmed by auto-baud circuitry        */
} UARTIIR_BIT_ABL;

#define UARTIIR_ALL_ABL_AUTO_BAUD_NOT_LOCK     ((0x0UL) << UARTIIR_ALL_ABL_Pos)
#define UARTIIR_ALL_ABL_AUTO_BAUD_LOCK         ((0x1UL) << UARTIIR_ALL_ABL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTIIR         FIFOSTS
 *  @access     UART->UARTIIR.bit.FIFOSTS
 *  @brief      FIFO Mode Enable Status
 */
#define UARTIIR_ALL_FIFOSTS_Pos (6)
#define UARTIIR_ALL_FIFOSTS_Msk (0x3UL << UARTIIR_ALL_FIFOSTS_Pos)

typedef enum
{
    UARTIIR_BIT_FIFOSTS_NOT_FIFO_MODE     = 0,  /*!< Non-FIFO mode is selected                                                                           */
    UARTIIR_BIT_FIFOSTS_FIFO_MODE         = 3,  /*!< FIFO mode is selected (<Transmit and Receive FIFO Enable> field in the FIFO Control Register = 1)   */
} UARTIIR_BIT_FIFOSTS;

#define UARTIIR_ALL_FIFOSTS_NOT_FIFO_MODE     ((0x0UL) << UARTIIR_ALL_FIFOSTS_Pos)
#define UARTIIR_ALL_FIFOSTS_FIFO_MODE         ((0x3UL) << UARTIIR_ALL_FIFOSTS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTFCR         TRFIFOE
 *  @access     UART->UARTFCR.bit.TRFIFOE
 *  @brief      Transmit and Receive FIFO Enable
 *              TRFIFOE enable or disables the Transmit and Receive FIFOs. When TRFIFOE is set, both FIFOs are enabled (FIFO mode). When TRFIFOE is clear, the FIFOs are both disabled (non-FIFO mode). Writing 0b0 to this bit clears all bytes in both FIFOs. When changing from FIFO mode to non-FIFO mode and vice versa, data is cleared automatically from the FIFOs. This bit must be set when other bits in this register are written or the othe					r bits are not programmed.
 */
#define UARTFCR_ALL_TRFIFOE_Pos (0)
#define UARTFCR_ALL_TRFIFOE_Msk (0x1UL << UARTFCR_ALL_TRFIFOE_Pos)

typedef enum
{
    UARTFCR_BIT_TRFIFOE_FIFO_DISABLE     = 0,  /*!< FIFOs are disabled   */
    UARTFCR_BIT_TRFIFOE_FIFO_ENABLE      = 1,  /*!< FIFOs are enabled    */
} UARTFCR_BIT_TRFIFOE;

#define UARTFCR_ALL_TRFIFOE_FIFO_DISABLE     ((0x0UL) << UARTFCR_ALL_TRFIFOE_Pos)
#define UARTFCR_ALL_TRFIFOE_FIFO_ENABLE      ((0x1UL) << UARTFCR_ALL_TRFIFOE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTFCR         RSTRF
 *  @access     UART->UARTFCR.bit.RSTRF
 *  @brief      Reset Receive FIFO
 *              When RESETRF is set, all the bytes in the Receive FIFO are cleared. The DR bit in the UARTLSR is cleared to 0. All the error bits in the FIFO and the FIFOE bit in the UARTLSR are cleared. Any error bits, OE, PE, FE or BI, that has been set in UARTLSR are still set. The Receive Shift Register is not cleared. If the UARTIIR has been set to "received data available", it is cleared.
 */
#define UARTFCR_ALL_RSTRF_Pos (1)
#define UARTFCR_ALL_RSTRF_Msk (0x1UL << UARTFCR_ALL_RSTRF_Pos)

typedef enum
{
    UARTFCR_BIT_RSTRF_NO_EFFECT         = 0,  /*!< Writing 0 has no effect       */
    UARTFCR_BIT_RSTRF_CLEAR_RX_FIFO     = 1,  /*!< The receive FIFO is cleared   */
} UARTFCR_BIT_RSTRF;

#define UARTFCR_ALL_RSTRF_NO_EFFECT         ((0x0UL) << UARTFCR_ALL_RSTRF_Pos)
#define UARTFCR_ALL_RSTRF_CLEAR_RX_FIFO     ((0x1UL) << UARTFCR_ALL_RSTRF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTFCR         RSTTF
 *  @access     UART->UARTFCR.bit.RSTTF
 *  @brief      Reset Transmit FIFO
 *              When this one is set, all the bytes in the Transmit FIFO are cleared. The TDRQ bit in the LSR is set and the UARTIIR shows a transmitter requests data interrupt, if the TIE bit in the UARTIER register is set. The transmit Shift register is not cleared, and it completes the current transmission.
 */
#define UARTFCR_ALL_RSTTF_Pos (2)
#define UARTFCR_ALL_RSTTF_Msk (0x1UL << UARTFCR_ALL_RSTTF_Pos)

typedef enum
{
    UARTFCR_BIT_RSTTF_NO_EFFECT         = 0,  /*!< Writing 0 has no effect        */
    UARTFCR_BIT_RSTTF_CLEAR_TX_FIFO     = 1,  /*!< The transmit FIFO is cleared   */
} UARTFCR_BIT_RSTTF;

#define UARTFCR_ALL_RSTTF_NO_EFFECT         ((0x0UL) << UARTFCR_ALL_RSTTF_Pos)
#define UARTFCR_ALL_RSTTF_CLEAR_TX_FIFO     ((0x1UL) << UARTFCR_ALL_RSTTF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTFCR         TIL
 *  @access     UART->UARTFCR.bit.TIL
 *  @brief      Transmitter Interrupt Level
 */
#define UARTFCR_ALL_TIL_Pos (3)
#define UARTFCR_ALL_TIL_Msk (0x1UL << UARTFCR_ALL_TIL_Pos)

typedef enum
{
    UARTFCR_BIT_TIL_TXFIFO_HALF_EMPTY     = 0,  /*!< Interrupt request when FIFO is half empty   */
    UARTFCR_BIT_TIL_TXFIFO_EMPTY          = 1,  /*!< Interrupt request when FIFO is empty        */
} UARTFCR_BIT_TIL;

#define UARTFCR_ALL_TIL_TXFIFO_HALF_EMPTY     ((0x0UL) << UARTFCR_ALL_TIL_Pos)
#define UARTFCR_ALL_TIL_TXFIFO_EMPTY          ((0x1UL) << UARTFCR_ALL_TIL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTFCR         ITL
 *  @access     UART->UARTFCR.bit.ITL
 *  @brief      Interrupt Trigger Level (threshold)
 *              When the number of bytes in the Receive FIFO equals the interrupt trigger threshold programmed into this field and the received-data-available interrupt is enabled via the UARTIER, an interrupt is generated and appropriate bits are set in the UARTIIR.
 */
#define UARTFCR_ALL_ITL_Pos (6)
#define UARTFCR_ALL_ITL_Msk (0x3UL << UARTFCR_ALL_ITL_Pos)

typedef enum
{
    UARTFCR_BIT_ITL_RX_FIFO_THRESHOLD_1      = 0,  /*!< 1 byte or more in FIFO causes interrupt      */
    UARTFCR_BIT_ITL_RX_FIFO_THRESHOLD_8      = 1,  /*!< 8 bytes or more in FIFO causes interrupt     */
    UARTFCR_BIT_ITL_RX_FIFO_THRESHOLD_16     = 2,  /*!< 16 bytes or more in FIFO causes interrupt    */
    UARTFCR_BIT_ITL_RX_FIFO_THRESHOLD_32     = 3,  /*!< 32 bytes or more in FIFO causes interrupt    */
} UARTFCR_BIT_ITL;

#define UARTFCR_ALL_ITL_RX_FIFO_THRESHOLD_1      ((0x0UL) << UARTFCR_ALL_ITL_Pos)
#define UARTFCR_ALL_ITL_RX_FIFO_THRESHOLD_8      ((0x1UL) << UARTFCR_ALL_ITL_Pos)
#define UARTFCR_ALL_ITL_RX_FIFO_THRESHOLD_16     ((0x2UL) << UARTFCR_ALL_ITL_Pos)
#define UARTFCR_ALL_ITL_RX_FIFO_THRESHOLD_32     ((0x3UL) << UARTFCR_ALL_ITL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLCR         WLS
 *  @access     UART->UARTLCR.bit.WLS
 *  @brief      Word Length Select
 *              Specifies the number of data bits in each transmitted or received character.
 */
#define UARTLCR_ALL_WLS_Pos (0)
#define UARTLCR_ALL_WLS_Msk (0x3UL << UARTLCR_ALL_WLS_Pos)

typedef enum
{
    UARTLCR_BIT_WLS_5_DATA_BIT     = 0,  /*!< 5-bit character   */
    UARTLCR_BIT_WLS_6_DATA_BIT     = 1,  /*!< 6-bit character   */
    UARTLCR_BIT_WLS_7_DATA_BIT     = 2,  /*!< 7-bit character   */
    UARTLCR_BIT_WLS_8_DATA_BIT     = 3,  /*!< 8-bit character   */
} UARTLCR_BIT_WLS;

#define UARTLCR_ALL_WLS_5_DATA_BIT     ((0x0UL) << UARTLCR_ALL_WLS_Pos)
#define UARTLCR_ALL_WLS_6_DATA_BIT     ((0x1UL) << UARTLCR_ALL_WLS_Pos)
#define UARTLCR_ALL_WLS_7_DATA_BIT     ((0x2UL) << UARTLCR_ALL_WLS_Pos)
#define UARTLCR_ALL_WLS_8_DATA_BIT     ((0x3UL) << UARTLCR_ALL_WLS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLCR         STB
 *  @access     UART->UARTLCR.bit.STB
 *  @brief      Stop bits
 *              Specifies the number of stop bits transmitted and received in each character. When receiving, the receiver checks only the first stop bit.
 */
#define UARTLCR_ALL_STB_Pos (2)
#define UARTLCR_ALL_STB_Msk (0x1UL << UARTLCR_ALL_STB_Pos)

typedef enum
{
    UARTLCR_BIT_STB_1_STOP_BIT     = 0,  /*!< 1 stop bit                            */
    UARTLCR_BIT_STB_2_STOP_BIT     = 1,  /*!< 1.5 stop bits for 5-bit character    
                                              2 stop bits for 6/7/8 bit character   */
} UARTLCR_BIT_STB;

#define UARTLCR_ALL_STB_1_STOP_BIT     ((0x0UL) << UARTLCR_ALL_STB_Pos)
#define UARTLCR_ALL_STB_2_STOP_BIT     ((0x1UL) << UARTLCR_ALL_STB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLCR         PEN
 *  @access     UART->UARTLCR.bit.PEN
 *  @brief      Parity Enable
 *              Enables a parity bit to be generated on transmission or checked on reception.
 */
#define UARTLCR_ALL_PEN_Pos (3)
#define UARTLCR_ALL_PEN_Msk (0x1UL << UARTLCR_ALL_PEN_Pos)

typedef enum
{
    UARTLCR_BIT_PEN_NO_PARITY         = 0,  /*!< No parity   */
    UARTLCR_BIT_PEN_PARITY_ENABLE     = 1,  /*!< Parity      */
} UARTLCR_BIT_PEN;

#define UARTLCR_ALL_PEN_NO_PARITY         ((0x0UL) << UARTLCR_ALL_PEN_Pos)
#define UARTLCR_ALL_PEN_PARITY_ENABLE     ((0x1UL) << UARTLCR_ALL_PEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLCR         EPS
 *  @access     UART->UARTLCR.bit.EPS
 *  @brief      Even Parity Select
 *              If PEN = 0, EPS is ignored.
 */
#define UARTLCR_ALL_EPS_Pos (4)
#define UARTLCR_ALL_EPS_Msk (0x1UL << UARTLCR_ALL_EPS_Pos)

typedef enum
{
    UARTLCR_BIT_EPS_ODD_PARITY      = 0,  /*!< Sends or checks for odd parity    */
    UARTLCR_BIT_EPS_EVEN_PARITY     = 1,  /*!< Sends or checks for even parity   */
} UARTLCR_BIT_EPS;

#define UARTLCR_ALL_EPS_ODD_PARITY      ((0x0UL) << UARTLCR_ALL_EPS_Pos)
#define UARTLCR_ALL_EPS_EVEN_PARITY     ((0x1UL) << UARTLCR_ALL_EPS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLCR         STKYP
 *  @access     UART->UARTLCR.bit.STKYP
 *  @brief      Sticky Parity
 *              Forces the bit value at the parity bit location to be the opposite of the EPS bit rather than the parity value. This stops parity generation. If PEN=0, STKYP is ignored.
 */
#define UARTLCR_ALL_STKYP_Pos (5)
#define UARTLCR_ALL_STKYP_Msk (0x1UL << UARTLCR_ALL_STKYP_Pos)

typedef enum
{
    UARTLCR_BIT_STKYP_NO_EFFECT                 = 0,  /*!< No effect on parity bit                             */
    UARTLCR_BIT_STKYP_PARITY_EQU_INVERT_EPS     = 1,  /*!< Forces parity bit to be opposite of EPS bit value   */
} UARTLCR_BIT_STKYP;

#define UARTLCR_ALL_STKYP_NO_EFFECT                 ((0x0UL) << UARTLCR_ALL_STKYP_Pos)
#define UARTLCR_ALL_STKYP_PARITY_EQU_INVERT_EPS     ((0x1UL) << UARTLCR_ALL_STKYP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLCR         SB
 *  @access     UART->UARTLCR.bit.SB
 *  @brief      Set Break
 *              Causes a break condition to be transmitted to the receiving UART. Acts only on the TXD pin and has no effect on the Transmit logic. In FIFO mode, wait until the transmitter is idle (UARTLSR[TXEMPTY]=1) to set and clear SB.
 */
#define UARTLCR_ALL_SB_Pos (6)
#define UARTLCR_ALL_SB_Msk (0x1UL << UARTLCR_ALL_SB_Pos)

typedef enum
{
    UARTLCR_BIT_SB_NO_EFFECT      = 0,  /*!< No effect on TXD output          */
    UARTLCR_BIT_SB_FORCE_TX_0     = 1,  /*!< Forces TXD output to 0 (space)   */
} UARTLCR_BIT_SB;

#define UARTLCR_ALL_SB_NO_EFFECT      ((0x0UL) << UARTLCR_ALL_SB_Pos)
#define UARTLCR_ALL_SB_FORCE_TX_0     ((0x1UL) << UARTLCR_ALL_SB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLCR         DLAB
 *  @access     UART->UARTLCR.bit.DLAB
 *  @brief      Divisor Latch Access Bit
 *              Must be set to access the Divisor Latch registers of the baud-rate generator during a Read or Write operation. Must be clear to access the Receive buffer, the Transmit Holding Register, or the UARTIER.
 */
#define UARTLCR_ALL_DLAB_Pos (7)
#define UARTLCR_ALL_DLAB_Msk (0x1UL << UARTLCR_ALL_DLAB_Pos)

typedef enum
{
    UARTLCR_BIT_DLAB_DIVISOR_LOCK       = 0,  /*!< Access Transmit Holding Register, Receive Buffer Register, and Interrupt Enable Register   */
    UARTLCR_BIT_DLAB_DIVISOR_ACCESS     = 1,  /*!< Access Divisor Latch registers (UARTDLL and UARTDLH)                                       */
} UARTLCR_BIT_DLAB;

#define UARTLCR_ALL_DLAB_DIVISOR_LOCK       ((0x0UL) << UARTLCR_ALL_DLAB_Pos)
#define UARTLCR_ALL_DLAB_DIVISOR_ACCESS     ((0x1UL) << UARTLCR_ALL_DLAB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTMCR         OUT2
 *  @access     UART->UARTMCR.bit.OUT2
 *  @brief      OUT2 Signal Control
 *              OUT2 connects the UART interrupt output to the Interrupt Controller unit when LOOP is clear.
 *              When LOOP is set, interrupts always go to the CPU.
 */
#define UARTMCR_ALL_OUT2_Pos (3)
#define UARTMCR_ALL_OUT2_Msk (0x1UL << UARTMCR_ALL_OUT2_Pos)

typedef enum
{
    UARTMCR_BIT_OUT2_INT_DISABLE     = 0,  /*!< Disable UART interrupt   */
    UARTMCR_BIT_OUT2_INT_ENABLE      = 1,  /*!< Enable UART interrupt    */
} UARTMCR_BIT_OUT2;

#define UARTMCR_ALL_OUT2_INT_DISABLE     ((0x0UL) << UARTMCR_ALL_OUT2_Pos)
#define UARTMCR_ALL_OUT2_INT_ENABLE      ((0x1UL) << UARTMCR_ALL_OUT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTMCR         LOOP
 *  @access     UART->UARTMCR.bit.LOOP
 *  @brief      Loopback Mode
 *              This bit provides a local loopback feature for diagnostic testing of the UART. When LOOP is set, the following occurs: The transmitter serial output is set to a logic 1 state. The receiver serial input is disconnected from the pin. The output of the Transmit Shift Register is looped back into the Receive Shift Register input.
 *              Loopback mode must be configured before the UART is enabled.
 *              In Loopback mode, data that is transmitted is received immediately. This feature allows the CPU to verify the Transmit and Receive data paths of the UART. A break signal can also be transferred from the transmitter section to the receiver section in Loopback mode.
 */
#define UARTMCR_ALL_LOOP_Pos (4)
#define UARTMCR_ALL_LOOP_Msk (0x1UL << UARTMCR_ALL_LOOP_Pos)

typedef enum
{
    UARTMCR_BIT_LOOP_NORMAL_MODE       = 0,  /*!< Normal UART operation          */
    UARTMCR_BIT_LOOP_LOOPBACK_MODE     = 1,  /*!< Loopback-mode UART operation   */
} UARTMCR_BIT_LOOP;

#define UARTMCR_ALL_LOOP_NORMAL_MODE       ((0x0UL) << UARTMCR_ALL_LOOP_Pos)
#define UARTMCR_ALL_LOOP_LOOPBACK_MODE     ((0x1UL) << UARTMCR_ALL_LOOP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLSR         DR
 *  @access     UART->UARTLSR.bit.DR
 *  @brief      Data Ready
 *              Set when a complete incoming character has been received and transferred into the Receive Buffer Register or the FIFO. In non-FIFO mode, DR is cleared when the Receive buffer is read. In FIFO mode, DR is cleared if the FIFO is empty (last character has been read from UARTRBR) or the FIFO is reset with UARTFCR[RESETRF].
 */
#define UARTLSR_ALL_DR_Pos (0)
#define UARTLSR_ALL_DR_Msk (0x1UL << UARTLSR_ALL_DR_Pos)

typedef enum
{
    UARTLSR_BIT_DR_NO_DATA_RECEVIED     = 0,  /*!< No data has been received                  */
    UARTLSR_BIT_DR_DATA_RECEVIED        = 1,  /*!< Data is available in UARTRBR or the FIFO   */
} UARTLSR_BIT_DR;

#define UARTLSR_ALL_DR_NO_DATA_RECEVIED     ((0x0UL) << UARTLSR_ALL_DR_Pos)
#define UARTLSR_ALL_DR_DATA_RECEVIED        ((0x1UL) << UARTLSR_ALL_DR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLSR         OE
 *  @access     UART->UARTLSR.bit.OE
 *  @brief      Overrun Error
 *              In non-FIFO mode, indicates that data in Receive Buffer register was not read by the CPU before the next character was received. The new character is lost. In FIFO mode, OE indicates that all 64 bytes of the FIFO are full and the most recently received byte has been discarded. OE is set upon detection of an overrun condition and cleared when the CPU reads the UARTLSR.
 */
#define UARTLSR_ALL_OE_Pos (1)
#define UARTLSR_ALL_OE_Msk (0x1UL << UARTLSR_ALL_OE_Pos)

typedef enum
{
    UARTLSR_BIT_OE_RX_OVERRUN_NOT_OCCUR     = 0,  /*!< No data has been overrun        */
    UARTLSR_BIT_OE_RX_OVERRUN_OCCUR         = 1,  /*!< Receive data has been overrun   */
} UARTLSR_BIT_OE;

#define UARTLSR_ALL_OE_RX_OVERRUN_NOT_OCCUR     ((0x0UL) << UARTLSR_ALL_OE_Pos)
#define UARTLSR_ALL_OE_RX_OVERRUN_OCCUR         ((0x1UL) << UARTLSR_ALL_OE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLSR         PE
 *  @access     UART->UARTLSR.bit.PE
 *  @brief      Parity Error
 *              Indicates that the received data character does not have the correct even or odd parity, as selected by the even parity select bit. PE is set upon detection of a parity error and is cleared when the CPU reads the UARTLSR. In FIFO mode, PE shows a parity error for the character at the front of the FIFO, not the most recently received character.
 */
#define UARTLSR_ALL_PE_Pos (2)
#define UARTLSR_ALL_PE_Msk (0x1UL << UARTLSR_ALL_PE_Pos)

typedef enum
{
    UARTLSR_BIT_PE_PARITY_ERROR_NOT_OCCUR     = 0,  /*!< No Parity Error             */
    UARTLSR_BIT_PE_PARITY_ERROR_OCCUR         = 1,  /*!< Parity error has occurred   */
} UARTLSR_BIT_PE;

#define UARTLSR_ALL_PE_PARITY_ERROR_NOT_OCCUR     ((0x0UL) << UARTLSR_ALL_PE_Pos)
#define UARTLSR_ALL_PE_PARITY_ERROR_OCCUR         ((0x1UL) << UARTLSR_ALL_PE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLSR         FE
 *  @access     UART->UARTLSR.bit.FE
 *  @brief      Framing Error
 *              FE indicates that the received character did not have a valid stop bit. FE is set when the bit following the last data bit or parity bit is detected to be 0. FE is cleared when the CPU reads the LSR. The UART resynchronizes after a framing error. To do this, it assumes that the framing error was due to the next start bit, so it samples this start bit twice and then reads in the data. In FIFO mode, FE shows a framing error for the character at the front of the FIFO, not for the most recently received character.
 */
#define UARTLSR_ALL_FE_Pos (3)
#define UARTLSR_ALL_FE_Msk (0x1UL << UARTLSR_ALL_FE_Pos)

typedef enum
{
    UARTLSR_BIT_FE_FRAME_ERROR_NOT_OCCUR     = 0,  /*!< No Framing error                     */
    UARTLSR_BIT_FE_FRAME_ERROR_OCCUR         = 1,  /*!< Invalid stop bit has been detected   */
} UARTLSR_BIT_FE;

#define UARTLSR_ALL_FE_FRAME_ERROR_NOT_OCCUR     ((0x0UL) << UARTLSR_ALL_FE_Pos)
#define UARTLSR_ALL_FE_FRAME_ERROR_OCCUR         ((0x1UL) << UARTLSR_ALL_FE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLSR         BI
 *  @access     UART->UARTLSR.bit.BI
 *  @brief      Break Interrupt
 *              BI is set when the received data input is held low for longer than a full-word transmission time (the total time of start bit + data bits + parity bit + stop bit). BI is cleared when the CPU reads the UARTLSR. In FIFO mode, only one character equal to 0x00, is loaded into the FIFO regardless of the length of the break condition. BI shows the break condition for the character at the front of the FIFO, not the most recently received character.
 */
#define UARTLSR_ALL_BI_Pos (4)
#define UARTLSR_ALL_BI_Msk (0x1UL << UARTLSR_ALL_BI_Pos)

typedef enum
{
    UARTLSR_BIT_BI_BREAK_SIGNAL_NOT_OCCUR     = 0,  /*!< No break signal has been received   */
    UARTLSR_BIT_BI_BREAK_SIGNAL_OCCUR         = 1,  /*!< Break signal received               */
} UARTLSR_BIT_BI;

#define UARTLSR_ALL_BI_BREAK_SIGNAL_NOT_OCCUR     ((0x0UL) << UARTLSR_ALL_BI_Pos)
#define UARTLSR_ALL_BI_BREAK_SIGNAL_OCCUR         ((0x1UL) << UARTLSR_ALL_BI_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLSR         TDRQ
 *  @access     UART->UARTLSR.bit.TDRQ
 *  @brief      Transmit Data Request
 *              Indicates that the UART is ready to accept a new character for transmission. In addition, this bit causes the UART to issue an interrupt to the CPU when the transmit-data request interrupt enable is set. The TDRQ bit is set when a character is transferred from the Transmit Holding Register into the Transmit Shift Register. The bit is cleared with the loading of the Transmit Holding Register. In FIFO mode, TDRQ is set when half of the characters in the FIFO have been loaded into the Shift Register or the RESETTF bit in UARTFCR has been set. It is cleared when the FIFO has more than half data. If more than 64 characters are loaded into the FIFO, the excess characters are lost.
 */
#define UARTLSR_ALL_TDRQ_Pos (5)
#define UARTLSR_ALL_TDRQ_Msk (0x1UL << UARTLSR_ALL_TDRQ_Pos)

typedef enum
{
    UARTLSR_BIT_TDRQ_TXFIFO_MORE_THAN_HALF     = 0,  /*!< There is data in the holding register or FIFO waiting to be shifted out   */
    UARTLSR_BIT_TDRQ_TXFIFO_LESS_THAN_HALF     = 1,  /*!< The transmit FIFO has half or less than half data                         */
} UARTLSR_BIT_TDRQ;

#define UARTLSR_ALL_TDRQ_TXFIFO_MORE_THAN_HALF     ((0x0UL) << UARTLSR_ALL_TDRQ_Pos)
#define UARTLSR_ALL_TDRQ_TXFIFO_LESS_THAN_HALF     ((0x1UL) << UARTLSR_ALL_TDRQ_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLSR         TXEMPTY
 *  @access     UART->UARTLSR.bit.TXEMPTY
 *  @brief      Transmitter Empty
 *              Set when the Transmit Holding Register and the Transmit Shift Register are both empty. It is cleared when either the Transmit Holding Register or the Transmit Shift Register contains a data character. In FIFO mode, TXEMPTY is set when the Transmit FIFO and the Transmit Shift Register are both empty.
 */
#define UARTLSR_ALL_TXEMPTY_Pos (6)
#define UARTLSR_ALL_TXEMPTY_Msk (0x1UL << UARTLSR_ALL_TXEMPTY_Pos)

typedef enum
{
    UARTLSR_BIT_TXEMPTY_TXFIFO_NOT_EMPTY     = 0,  /*!< There is data in the transmit shift register, the Transmit Holding Register, or the FIFO.   */
    UARTLSR_BIT_TXEMPTY_TXFIFO_EMPTY         = 1,  /*!< All the data in the transmitter has been shifted out                                        */
} UARTLSR_BIT_TXEMPTY;

#define UARTLSR_ALL_TXEMPTY_TXFIFO_NOT_EMPTY     ((0x0UL) << UARTLSR_ALL_TXEMPTY_Pos)
#define UARTLSR_ALL_TXEMPTY_TXFIFO_EMPTY         ((0x1UL) << UARTLSR_ALL_TXEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTLSR         FIFOERR
 *  @access     UART->UARTLSR.bit.FIFOERR
 *  @brief      FIFO Error Status
 *              This bit is clear in non-FIFO mode. In FIFO mode, FIFOERR is set when there is at least one parity error, framing error, or break indication for any of the characters in the FIFO. The CPU read of the UARTLSR does not reset this bit. FIFOERR is reset when all errorneous characters have been read from the FIFO.
 */
#define UARTLSR_ALL_FIFOERR_Pos (7)
#define UARTLSR_ALL_FIFOERR_Msk (0x1UL << UARTLSR_ALL_FIFOERR_Pos)

typedef enum
{
    UARTLSR_BIT_FIFOERR_FIFO_ERROR_NOT_OCCUR     = 0,  /*!< No FIFO or no errors in receive FIFO                */
    UARTLSR_BIT_FIFOERR_FIFO_ERROR_OCCUR         = 1,  /*!< At least one character in receive FIFO has errors   */
} UARTLSR_BIT_FIFOERR;

#define UARTLSR_ALL_FIFOERR_FIFO_ERROR_NOT_OCCUR     ((0x0UL) << UARTLSR_ALL_FIFOERR_Pos)
#define UARTLSR_ALL_FIFOERR_FIFO_ERROR_OCCUR         ((0x1UL) << UARTLSR_ALL_FIFOERR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTISR         XMITIR
 *  @access     UART->UARTISR.bit.XMITIR
 *  @brief      Transmitter SIR Enable
 *              When XMITIR is set, the normal TXD output from the UART is processed by the lrDA encoder before it is fed to the device pin. If XMITIR is clear, all clocking to the lrDA encoder is blocked and the UART's TXD signal is connected directly to the device pin.
 */
#define UARTISR_ALL_XMITIR_Pos (0)
#define UARTISR_ALL_XMITIR_Msk (0x1UL << UARTISR_ALL_XMITIR_Pos)

typedef enum
{
    UARTISR_BIT_XMITIR_TXD_BY_IRDA     = 0,  /*!< TXD output from the UART is processed by the lrDA encoder    */
    UARTISR_BIT_XMITIR_TXD_DIRECT      = 1,  /*!< TXD signal is connected directly                             */
} UARTISR_BIT_XMITIR;

#define UARTISR_ALL_XMITIR_TXD_BY_IRDA     ((0x0UL) << UARTISR_ALL_XMITIR_Pos)
#define UARTISR_ALL_XMITIR_TXD_DIRECT      ((0x1UL) << UARTISR_ALL_XMITIR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTISR         RCVEIR
 *  @access     UART->UARTISR.bit.RCVEIR
 *  @brief      Receiver SIR Enable
 *              When RCVEIR is set, the signal from the RXD pin is processed by lrDA decoder before it is fed to the UART. IF RCVEIR is clear, than all clocking to the lrDA decoder is blocked and the RXD pin is fed directly to the UART.
 */
#define UARTISR_ALL_RCVEIR_Pos (1)
#define UARTISR_ALL_RCVEIR_Msk (0x1UL << UARTISR_ALL_RCVEIR_Pos)

typedef enum
{
    UARTISR_BIT_RCVEIR_UART         = 0,  /*!< Receiver is in UART mode       */
    UARTISR_BIT_RCVEIR_INFRARED     = 1,  /*!< Receiver is in infrared mode   */
} UARTISR_BIT_RCVEIR;

#define UARTISR_ALL_RCVEIR_UART         ((0x0UL) << UARTISR_ALL_RCVEIR_Pos)
#define UARTISR_ALL_RCVEIR_INFRARED     ((0x1UL) << UARTISR_ALL_RCVEIR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTISR         XMODE
 *  @access     UART->UARTISR.bit.XMODE
 *  @brief      Transmit Pulse Width Select
 *              When XMODE is clear, the UART 16x clock is used to clock the lrDA Transmit and Receive logic. When XMDOE is set, Receive decoder operaton does not change, and the Transmit encoder generates 1.6 ms pulses (that are 3/16 of a bit time at 115.2 kbps) instead of pulses 3/16 of a bit time wide. Spintrol recommends setting XMDOE.
 */
#define UARTISR_ALL_XMODE_Pos (2)
#define UARTISR_ALL_XMODE_Msk (0x1UL << UARTISR_ALL_XMODE_Pos)

typedef enum
{
    UARTISR_BIT_XMODE_WIDTH_3OVER16      = 0,  /*!< Transmit pulse width is 3/16 of a bit time wide   */
    UARTISR_BIT_XMODE_WIDTH_1DOT6_MS     = 1,  /*!< Transmit pulse width is 1.6ms                     */
} UARTISR_BIT_XMODE;

#define UARTISR_ALL_XMODE_WIDTH_3OVER16      ((0x0UL) << UARTISR_ALL_XMODE_Pos)
#define UARTISR_ALL_XMODE_WIDTH_1DOT6_MS     ((0x1UL) << UARTISR_ALL_XMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTISR         TXPL
 *  @access     UART->UARTISR.bit.TXPL
 *  @brief      Transmit Data Polarity
 */
#define UARTISR_ALL_TXPL_Pos (3)
#define UARTISR_ALL_TXPL_Msk (0x1UL << UARTISR_ALL_TXPL_Pos)

typedef enum
{
    UARTISR_BIT_TXPL_SEND_POSITIVE_ZERO     = 0,  /*!< SIR encoder generates a positive pulse for a data bit of zero   */
    UARTISR_BIT_TXPL_SEND_NEGATIVE_ZERO     = 1,  /*!< SIR encoder generates a negative pulse for a data bit of zero   */
} UARTISR_BIT_TXPL;

#define UARTISR_ALL_TXPL_SEND_POSITIVE_ZERO     ((0x0UL) << UARTISR_ALL_TXPL_Pos)
#define UARTISR_ALL_TXPL_SEND_NEGATIVE_ZERO     ((0x1UL) << UARTISR_ALL_TXPL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTISR         RXPL
 *  @access     UART->UARTISR.bit.RXPL
 *  @brief      Receive Data Polarity
 */
#define UARTISR_ALL_RXPL_Pos (4)
#define UARTISR_ALL_RXPL_Msk (0x1UL << UARTISR_ALL_RXPL_Pos)

typedef enum
{
    UARTISR_BIT_RXPL_REV_POSITIVE_ZERO     = 0,  /*!< SIR decoder takes positive pulses as zeros   */
    UARTISR_BIT_RXPL_REV_NEGATIVE_ZERO     = 1,  /*!< SIR decoder takes negative pulses as zeros   */
} UARTISR_BIT_RXPL;

#define UARTISR_ALL_RXPL_REV_POSITIVE_ZERO     ((0x0UL) << UARTISR_ALL_RXPL_Pos)
#define UARTISR_ALL_RXPL_REV_NEGATIVE_ZERO     ((0x1UL) << UARTISR_ALL_RXPL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTFOR         BYTECNT
 *  @access     UART->UARTFOR.bit.BYTECNT
 *  @brief      Number of bytes (0-63) remaining in the Receive FIFO
 */
#define UARTFOR_ALL_BYTECNT_Pos (0)
#define UARTFOR_ALL_BYTECNT_Msk (0x3FUL << UARTFOR_ALL_BYTECNT_Pos)

#define UARTFOR_BIT_BYTECNT

#define UARTFOR_ALL_BYTECNT_(x) ((x) << UARTFOR_ALL_BYTECNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTABR         ABE
 *  @access     UART->UARTABR.bit.ABE
 *  @brief      Auto-baud detection enable
 */
#define UARTABR_ALL_ABE_Pos (0)
#define UARTABR_ALL_ABE_Msk (0x1UL << UARTABR_ALL_ABE_Pos)

typedef enum
{
    UARTABR_BIT_ABE_DISABLE     = 0,  /*!< Auto-baud disabled   */
    UARTABR_BIT_ABE_ENABLE      = 1,  /*!< Auto-baud enabled    */
} UARTABR_BIT_ABE;

#define UARTABR_ALL_ABE_DISABLE     ((0x0UL) << UARTABR_ALL_ABE_Pos)
#define UARTABR_ALL_ABE_ENABLE      ((0x1UL) << UARTABR_ALL_ABE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTABR         ABLIE
 *  @access     UART->UARTABR.bit.ABLIE
 *  @brief      Auto-baud-lock interrupt enable
 */
#define UARTABR_ALL_ABLIE_Pos (1)
#define UARTABR_ALL_ABLIE_Msk (0x1UL << UARTABR_ALL_ABLIE_Pos)

typedef enum
{
    UARTABR_BIT_ABLIE_DISABLE     = 0,  /*!< Auto-baud-lock interrupt disabled (Source UARTIIR[ABL])   */
    UARTABR_BIT_ABLIE_ENABLE      = 1,  /*!< Auto-baud-lock interrupt enabled (Source UARTIIR[ABL])    */
} UARTABR_BIT_ABLIE;

#define UARTABR_ALL_ABLIE_DISABLE     ((0x0UL) << UARTABR_ALL_ABLIE_Pos)
#define UARTABR_ALL_ABLIE_ENABLE      ((0x1UL) << UARTABR_ALL_ABLIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTABR         ABUP
 *  @access     UART->UARTABR.bit.ABUP
 *  @brief      Method to program Divisor Latch registers
 */
#define UARTABR_ALL_ABUP_Pos (2)
#define UARTABR_ALL_ABUP_Msk (0x1UL << UARTABR_ALL_ABUP_Pos)

typedef enum
{
    UARTABR_BIT_ABUP_SOFTWARE_PROG_DIVISOR     = 0,  /*!< Software Programs Divisor Latch registers   */
    UARTABR_BIT_ABUP_UART_PROG_DIVISOR         = 1,  /*!< UART Programs Divisor Latch registers       */
} UARTABR_BIT_ABUP;

#define UARTABR_ALL_ABUP_SOFTWARE_PROG_DIVISOR     ((0x0UL) << UARTABR_ALL_ABUP_Pos)
#define UARTABR_ALL_ABUP_UART_PROG_DIVISOR         ((0x1UL) << UARTABR_ALL_ABUP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTABR         ABT
 *  @access     UART->UARTABR.bit.ABT
 *  @brief      Method to calculate baud rates
 */
#define UARTABR_ALL_ABT_Pos (3)
#define UARTABR_ALL_ABT_Msk (0x1UL << UARTABR_ALL_ABT_Pos)

typedef enum
{
    UARTABR_BIT_ABT_FORMULA     = 0,  /*!< Formula used to calculate baud rates, allowing all possible baud rates to be chosen by UART as shown in this chapter   */
    UARTABR_BIT_ABT_TABLE       = 1,  /*!< Table used to calculate baud rates, which limits UART to choosing common baud rates                                    */
} UARTABR_BIT_ABT;

#define UARTABR_ALL_ABT_FORMULA     ((0x0UL) << UARTABR_ALL_ABT_Pos)
#define UARTABR_ALL_ABT_TABLE       ((0x1UL) << UARTABR_ALL_ABT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   UART            UARTACR         CNTVAL
 *  @access     UART->UARTACR.bit.CNTVAL
 *  @brief      Number of UART clock cycles within a start-bit pulse
 */
#define UARTACR_ALL_CNTVAL_Pos (0)
#define UARTACR_ALL_CNTVAL_Msk (0xFFFFUL << UARTACR_ALL_CNTVAL_Pos)

#define UARTACR_BIT_CNTVAL

#define UARTACR_ALL_CNTVAL_(x) ((x) << UARTACR_ALL_CNTVAL_Pos)





/********************************************************************************
*
* Module Name     SSP
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         SIZESEL
 *  @access     SSP->SSPCTL0.bit.SIZESEL
 *  @brief      Data Size Select
 *              ESIZESEL  SIZESEL  Data Size
 *              1         0000     17-bit data
 *              1         0001     18-bit data
 *              1         0010     19-bit data
 *              1         0011     20-bit data
 *              1         0100     21-bit data
 *              1         0101     22-bit data
 *              1         0110     23-bit data
 *              1         0111     24-bit data
 *              1         1000     25-bit data
 *              1         1001     26-bit data
 *              1         1010     27-bit data
 *              1         1011     28-bit data
 *              1         1100     29-bit data
 *              1         1101     30-bit data
 *              1         1110     31-bit data
 *              1         1111     32-bit data
 *              ESIZESEL  SIZESEL  Data Size
 *              0         0000     1-bit data
 *              0         0001     2-bit data
 *              0         0010     3-bit data
 *              0         0011     4-bit data
 *              0         0100     5-bit data
 *              0         0101     6-bit data
 *              0         0110     7-bit data
 *              0         0111     8-bit data
 *              0         1000     9-bit data
 *              0         1001     10-bit data
 *              0         1010     11-bit data
 *              0         1011     12-bit data
 *              0         1100     13-bit data
 *              0         1101     14-bit data
 *              0         1110     15-bit data
 *              0         1111     16-bit data
 */
#define SSPCTL0_ALL_SIZESEL_Pos (0)
#define SSPCTL0_ALL_SIZESEL_Msk (0xFUL << SSPCTL0_ALL_SIZESEL_Pos)

typedef enum
{
    SSPCTL0_BIT_SIZESEL_FRAME_1_OR_17BIT      = 0,  /*!< FRAME_1_OR_17BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_2_OR_18BIT      = 1,  /*!< FRAME_2_OR_18BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_3_OR_19BIT      = 2,  /*!< FRAME_3_OR_19BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_4_OR_20BIT      = 3,  /*!< FRAME_4_OR_20BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_5_OR_21BIT      = 4,  /*!< FRAME_5_OR_21BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_6_OR_22BIT      = 5,  /*!< FRAME_6_OR_22BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_7_OR_23BIT      = 6,  /*!< FRAME_7_OR_23BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_8_OR_24BIT      = 7,  /*!< FRAME_8_OR_24BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_9_OR_25BIT      = 8,  /*!< FRAME_9_OR_25BIT    */
    SSPCTL0_BIT_SIZESEL_FRAME_10_OR_26BIT     = 9,  /*!< FRAME_10_OR_26BIT   */
    SSPCTL0_BIT_SIZESEL_FRAME_11_OR_27BIT     = 10,  /*!< FRAME_11_OR_27BIT   */
    SSPCTL0_BIT_SIZESEL_FRAME_12_OR_28BIT     = 11,  /*!< FRAME_12_OR_28BIT   */
    SSPCTL0_BIT_SIZESEL_FRAME_13_OR_29BIT     = 12,  /*!< FRAME_13_OR_29BIT   */
    SSPCTL0_BIT_SIZESEL_FRAME_14_OR_30BIT     = 13,  /*!< FRAME_14_OR_30BIT   */
    SSPCTL0_BIT_SIZESEL_FRAME_15_OR_31BIT     = 14,  /*!< FRAME_15_OR_31BIT   */
    SSPCTL0_BIT_SIZESEL_FRAME_16_OR_32BIT     = 15,  /*!< FRAME_16_OR_32BIT   */
} SSPCTL0_BIT_SIZESEL;

#define SSPCTL0_ALL_SIZESEL_FRAME_1_OR_17BIT      ((0x00UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_2_OR_18BIT      ((0x01UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_3_OR_19BIT      ((0x02UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_4_OR_20BIT      ((0x03UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_5_OR_21BIT      ((0x04UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_6_OR_22BIT      ((0x05UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_7_OR_23BIT      ((0x06UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_8_OR_24BIT      ((0x07UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_9_OR_25BIT      ((0x08UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_10_OR_26BIT     ((0x09UL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_11_OR_27BIT     ((0x0AUL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_12_OR_28BIT     ((0x0BUL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_13_OR_29BIT     ((0x0CUL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_14_OR_30BIT     ((0x0DUL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_15_OR_31BIT     ((0x0EUL) << SSPCTL0_ALL_SIZESEL_Pos)
#define SSPCTL0_ALL_SIZESEL_FRAME_16_OR_32BIT     ((0x0FUL) << SSPCTL0_ALL_SIZESEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         FRMSEL
 *  @access     SSP->SSPCTL0.bit.FRMSEL
 *  @brief      Frame Format
 *              This field must be written with 0x3 = to select the PSP format.
 */
#define SSPCTL0_ALL_FRMSEL_Pos (4)
#define SSPCTL0_ALL_FRMSEL_Msk (0x3UL << SSPCTL0_ALL_FRMSEL_Pos)

typedef enum
{
    SSPCTL0_BIT_FRMSEL_SPI_MOTOROLA     = 0,  /*!< Motorola Serial Peripheral Interface (SPI)            */
    SSPCTL0_BIT_FRMSEL_SSP_TI           = 1,  /*!< Texas Instruments Synchronous Serial Protocol (SSP)   */
    SSPCTL0_BIT_FRMSEL_PSP              = 3,  /*!< Programmable Serial Protocol (PSP)                    */
} SSPCTL0_BIT_FRMSEL;

#define SSPCTL0_ALL_FRMSEL_SPI_MOTOROLA     ((0x0UL) << SSPCTL0_ALL_FRMSEL_Pos)
#define SSPCTL0_ALL_FRMSEL_SSP_TI           ((0x1UL) << SSPCTL0_ALL_FRMSEL_Pos)
#define SSPCTL0_ALL_FRMSEL_PSP              ((0x3UL) << SSPCTL0_ALL_FRMSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         EN
 *  @access     SSP->SSPCTL0.bit.EN
 *  @brief      Synchronous Serial Port Enable
 */
#define SSPCTL0_ALL_EN_Pos (7)
#define SSPCTL0_ALL_EN_Msk (0x1UL << SSPCTL0_ALL_EN_Pos)

typedef enum
{
    SSPCTL0_BIT_EN_DISABLE     = 0,  /*!< SSP port is disabled   */
    SSPCTL0_BIT_EN_ENABLE      = 1,  /*!< SSP port is enabled    */
} SSPCTL0_BIT_EN;

#define SSPCTL0_ALL_EN_DISABLE     ((0x0UL) << SSPCTL0_ALL_EN_Pos)
#define SSPCTL0_ALL_EN_ENABLE      ((0x1UL) << SSPCTL0_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         ESIZESEL
 *  @access     SSP->SSPCTL0.bit.ESIZESEL
 *  @brief      Extended Data Size Select
 */
#define SSPCTL0_ALL_ESIZESEL_Pos (20)
#define SSPCTL0_ALL_ESIZESEL_Msk (0x1UL << SSPCTL0_ALL_ESIZESEL_Pos)

typedef enum
{
    SSPCTL0_BIT_ESIZESEL_DISABLE     = 0,  /*!< A 0 is pre-appended to the SIZESEL value to set the SIZESEL range from 1 to 16 bits    */
    SSPCTL0_BIT_ESIZESEL_ENABLE      = 1,  /*!< A 1 is pre-appended to the SIZESEL value to set the SIZESEL range from 17 to 32 bits   */
} SSPCTL0_BIT_ESIZESEL;

#define SSPCTL0_ALL_ESIZESEL_DISABLE     ((0x0UL) << SSPCTL0_ALL_ESIZESEL_Pos)
#define SSPCTL0_ALL_ESIZESEL_ENABLE      ((0x1UL) << SSPCTL0_ALL_ESIZESEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         RFINTMSK
 *  @access     SSP->SSPCTL0.bit.RFINTMSK
 *  @brief      Receive FIFO Overflow Interrupt Mask
 */
#define SSPCTL0_ALL_RFINTMSK_Pos (22)
#define SSPCTL0_ALL_RFINTMSK_Msk (0x1UL << SSPCTL0_ALL_RFINTMSK_Pos)

typedef enum
{
    SSPCTL0_BIT_RFINTMSK_RXFIFO_OVERFLOW_INT_UNMASK     = 0,  /*!< RFOVF events generate an SSP interrupt          */
    SSPCTL0_BIT_RFINTMSK_RXFIFO_OVERFLOW_INT_MASK       = 1,  /*!< RFOVF events do NOT generate an SSP interrupt   */
} SSPCTL0_BIT_RFINTMSK;

#define SSPCTL0_ALL_RFINTMSK_RXFIFO_OVERFLOW_INT_UNMASK     ((0x0UL) << SSPCTL0_ALL_RFINTMSK_Pos)
#define SSPCTL0_ALL_RFINTMSK_RXFIFO_OVERFLOW_INT_MASK       ((0x1UL) << SSPCTL0_ALL_RFINTMSK_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         TFINTMSK
 *  @access     SSP->SSPCTL0.bit.TFINTMSK
 *  @brief      Transmit FIFO Underflow Interrupt Mask
 */
#define SSPCTL0_ALL_TFINTMSK_Pos (23)
#define SSPCTL0_ALL_TFINTMSK_Msk (0x1UL << SSPCTL0_ALL_TFINTMSK_Pos)

typedef enum
{
    SSPCTL0_BIT_TFINTMSK_TXFIFO_UNDERFLOW_INT_UNMASK     = 0,  /*!< TFUDF events generate an SSP interrupt          */
    SSPCTL0_BIT_TFINTMSK_TXFIFO_UNDERFLOW_INT_MASK       = 1,  /*!< TFUDF events do NOT generate an SSP interrupt   */
} SSPCTL0_BIT_TFINTMSK;

#define SSPCTL0_ALL_TFINTMSK_TXFIFO_UNDERFLOW_INT_UNMASK     ((0x0UL) << SSPCTL0_ALL_TFINTMSK_Pos)
#define SSPCTL0_ALL_TFINTMSK_TXFIFO_UNDERFLOW_INT_MASK       ((0x1UL) << SSPCTL0_ALL_TFINTMSK_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         FRMRATE
 *  @access     SSP->SSPCTL0.bit.FRMRATE
 *  @brief      Frame Rate Divider Control
 *              Value of 0x0-0x7 specifies the number of time slots per frame when in network mode (the actual number of time slots is this field +1, so 1 to 8 time slots can be specified).
 */
#define SSPCTL0_ALL_FRMRATE_Pos (24)
#define SSPCTL0_ALL_FRMRATE_Msk (0x7UL << SSPCTL0_ALL_FRMRATE_Pos)

typedef enum
{
    SSPCTL0_BIT_FRMRATE_1_SLOT_PER_FRAME     = 0,  /*!< 1 slot per frame   */
    SSPCTL0_BIT_FRMRATE_2_SLOT_PER_FRAME     = 1,  /*!< 2 slot per frame   */
    SSPCTL0_BIT_FRMRATE_3_SLOT_PER_FRAME     = 2,  /*!< 3 slot per frame   */
    SSPCTL0_BIT_FRMRATE_4_SLOT_PER_FRAME     = 3,  /*!< 4 slot per frame   */
    SSPCTL0_BIT_FRMRATE_5_SLOT_PER_FRAME     = 4,  /*!< 5 slot per frame   */
    SSPCTL0_BIT_FRMRATE_6_SLOT_PER_FRAME     = 5,  /*!< 6 slot per frame   */
    SSPCTL0_BIT_FRMRATE_7_SLOT_PER_FRAME     = 6,  /*!< 7 slot per frame   */
    SSPCTL0_BIT_FRMRATE_8_SLOT_PER_FRAME     = 7,  /*!< 8 slot per frame   */
} SSPCTL0_BIT_FRMRATE;

#define SSPCTL0_ALL_FRMRATE_1_SLOT_PER_FRAME     ((0x0UL) << SSPCTL0_ALL_FRMRATE_Pos)
#define SSPCTL0_ALL_FRMRATE_2_SLOT_PER_FRAME     ((0x1UL) << SSPCTL0_ALL_FRMRATE_Pos)
#define SSPCTL0_ALL_FRMRATE_3_SLOT_PER_FRAME     ((0x2UL) << SSPCTL0_ALL_FRMRATE_Pos)
#define SSPCTL0_ALL_FRMRATE_4_SLOT_PER_FRAME     ((0x3UL) << SSPCTL0_ALL_FRMRATE_Pos)
#define SSPCTL0_ALL_FRMRATE_5_SLOT_PER_FRAME     ((0x4UL) << SSPCTL0_ALL_FRMRATE_Pos)
#define SSPCTL0_ALL_FRMRATE_6_SLOT_PER_FRAME     ((0x5UL) << SSPCTL0_ALL_FRMRATE_Pos)
#define SSPCTL0_ALL_FRMRATE_7_SLOT_PER_FRAME     ((0x6UL) << SSPCTL0_ALL_FRMRATE_Pos)
#define SSPCTL0_ALL_FRMRATE_8_SLOT_PER_FRAME     ((0x7UL) << SSPCTL0_ALL_FRMRATE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         FPACKEN
 *  @access     SSP->SSPCTL0.bit.FPACKEN
 *  @brief      FIFO Packing Enable
 */
#define SSPCTL0_ALL_FPACKEN_Pos (29)
#define SSPCTL0_ALL_FPACKEN_Msk (0x1UL << SSPCTL0_ALL_FPACKEN_Pos)

typedef enum
{
    SSPCTL0_BIT_FPACKEN_FIFO_PACK_DISABLE     = 0,  /*!< FIFO packing mode disabled   */
    SSPCTL0_BIT_FPACKEN_FIFO_PACK_ENABLE      = 1,  /*!< FIFO packing mode enabled    */
} SSPCTL0_BIT_FPACKEN;

#define SSPCTL0_ALL_FPACKEN_FIFO_PACK_DISABLE     ((0x0UL) << SSPCTL0_ALL_FPACKEN_Pos)
#define SSPCTL0_ALL_FPACKEN_FIFO_PACK_ENABLE      ((0x1UL) << SSPCTL0_ALL_FPACKEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL0         MODE
 *  @access     SSP->SSPCTL0.bit.MODE
 *  @brief      Mode
 */
#define SSPCTL0_ALL_MODE_Pos (31)
#define SSPCTL0_ALL_MODE_Msk (0x1UL << SSPCTL0_ALL_MODE_Pos)

typedef enum
{
    SSPCTL0_BIT_MODE_SPI             = 0,  /*!< Normal SSP mode   */
    SSPCTL0_BIT_MODE_SPI_NETWORK     = 1,  /*!< Network mode      */
} SSPCTL0_BIT_MODE;

#define SSPCTL0_ALL_MODE_SPI             ((0x0UL) << SSPCTL0_ALL_MODE_Pos)
#define SSPCTL0_ALL_MODE_SPI_NETWORK     ((0x1UL) << SSPCTL0_ALL_MODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         RFIE
 *  @access     SSP->SSPCTL1.bit.RFIE
 *  @brief      Receive FIFO Interrupt Enable
 */
#define SSPCTL1_ALL_RFIE_Pos (0)
#define SSPCTL1_ALL_RFIE_Msk (0x1UL << SSPCTL1_ALL_RFIE_Pos)

typedef enum
{
    SSPCTL1_BIT_RFIE_RXFIFO_INT_DISABLE     = 0,  /*!< RXFIFO threshold-level-reached interrupt is disabled   */
    SSPCTL1_BIT_RFIE_RXFIFO_INT_ENABLE      = 1,  /*!< RXFIFO threshold-level-reached interrupt is enabled    */
} SSPCTL1_BIT_RFIE;

#define SSPCTL1_ALL_RFIE_RXFIFO_INT_DISABLE     ((0x0UL) << SSPCTL1_ALL_RFIE_Pos)
#define SSPCTL1_ALL_RFIE_RXFIFO_INT_ENABLE      ((0x1UL) << SSPCTL1_ALL_RFIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         TFIE
 *  @access     SSP->SSPCTL1.bit.TFIE
 *  @brief      Transmit FIFO Interrupt Enable
 */
#define SSPCTL1_ALL_TFIE_Pos (1)
#define SSPCTL1_ALL_TFIE_Msk (0x1UL << SSPCTL1_ALL_TFIE_Pos)

typedef enum
{
    SSPCTL1_BIT_TFIE_TXFIFO_INT_DISABLE     = 0,  /*!< TXFIFO threshold-level-reached interrupt is disabled   */
    SSPCTL1_BIT_TFIE_TXFIFO_INT_ENABLE      = 1,  /*!< TXFIFO threshold-level-reached interrupt is enabled    */
} SSPCTL1_BIT_TFIE;

#define SSPCTL1_ALL_TFIE_TXFIFO_INT_DISABLE     ((0x0UL) << SSPCTL1_ALL_TFIE_Pos)
#define SSPCTL1_ALL_TFIE_TXFIFO_INT_ENABLE      ((0x1UL) << SSPCTL1_ALL_TFIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         LOOP
 *  @access     SSP->SSPCTL1.bit.LOOP
 *  @brief      Loopback Mode
 *              Loopback Mode (Test Mode Bit)
 */
#define SSPCTL1_ALL_LOOP_Pos (2)
#define SSPCTL1_ALL_LOOP_Msk (0x1UL << SSPCTL1_ALL_LOOP_Pos)

typedef enum
{
    SSPCTL1_BIT_LOOP_DISABLE     = 0,  /*!< Normal serial port operation is enabled                                             */
    SSPCTL1_BIT_LOOP_ENABLE      = 1,  /*!< Output of TX serial shifter is internally connected to input of RX serial shifter   */
} SSPCTL1_BIT_LOOP;

#define SSPCTL1_ALL_LOOP_DISABLE     ((0x0UL) << SSPCTL1_ALL_LOOP_Pos)
#define SSPCTL1_ALL_LOOP_ENABLE      ((0x1UL) << SSPCTL1_ALL_LOOP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         CLKPOL
 *  @access     SSP->SSPCTL1.bit.CLKPOL
 *  @brief      Motorola SPI SSP_CLK Polarity Setting
 */
#define SSPCTL1_ALL_CLKPOL_Pos (3)
#define SSPCTL1_ALL_CLKPOL_Msk (0x1UL << SSPCTL1_ALL_CLKPOL_Pos)

typedef enum
{
    SSPCTL1_BIT_CLKPOL_CLK_IDLE_LOW      = 0,  /*!< The inactive or idle state of SSP_CLK is low    */
    SSPCTL1_BIT_CLKPOL_CLK_IDLE_HIGH     = 1,  /*!< The inactive or idle state of SSP_CLK is high   */
} SSPCTL1_BIT_CLKPOL;

#define SSPCTL1_ALL_CLKPOL_CLK_IDLE_LOW      ((0x0UL) << SSPCTL1_ALL_CLKPOL_Pos)
#define SSPCTL1_ALL_CLKPOL_CLK_IDLE_HIGH     ((0x1UL) << SSPCTL1_ALL_CLKPOL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         CLKPHS
 *  @access     SSP->SSPCTL1.bit.CLKPHS
 *  @brief      Motorola SPI SSP_CLK phase setting
 */
#define SSPCTL1_ALL_CLKPHS_Pos (4)
#define SSPCTL1_ALL_CLKPHS_Msk (0x1UL << SSPCTL1_ALL_CLKPHS_Pos)

typedef enum
{
    SSPCTL1_BIT_CLKPHS_SAMPLE_ON_1st_CLK_EDGE     = 0,  /*!< SSP_CLK is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame   */
    SSPCTL1_BIT_CLKPHS_SAMPLE_ON_2nd_CLK_EDGE     = 1,  /*!< SSP_CLK is inactive until 1/2 cycle after the start of a frame and active until one cycle                             */
} SSPCTL1_BIT_CLKPHS;

#define SSPCTL1_ALL_CLKPHS_SAMPLE_ON_1st_CLK_EDGE     ((0x0UL) << SSPCTL1_ALL_CLKPHS_Pos)
#define SSPCTL1_ALL_CLKPHS_SAMPLE_ON_2nd_CLK_EDGE     ((0x1UL) << SSPCTL1_ALL_CLKPHS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         TFTH
 *  @access     SSP->SSPCTL1.bit.TFTH
 *  @brief      TXFIFO Trigger Threshold
 *              Sets threshold level at which TXFIFO asserts interrupt. Level should be set to the preferred threshold value minus 1.
 */
#define SSPCTL1_ALL_TFTH_Pos (6)
#define SSPCTL1_ALL_TFTH_Msk (0xFUL << SSPCTL1_ALL_TFTH_Pos)

#define SSPCTL1_BIT_TFTH

#define SSPCTL1_ALL_TFTH_(x) ((x) << SSPCTL1_ALL_TFTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         RFTH
 *  @access     SSP->SSPCTL1.bit.RFTH
 *  @brief      RXFIFO Trigger Threshold
 *              Sets threshold level at which RXFIFO asserts interrupt. Level should be set to the preferred threshold value minus 1.
 */
#define SSPCTL1_ALL_RFTH_Pos (10)
#define SSPCTL1_ALL_RFTH_Msk (0xFUL << SSPCTL1_ALL_RFTH_Pos)

#define SSPCTL1_BIT_RFTH

#define SSPCTL1_ALL_RFTH_(x) ((x) << SSPCTL1_ALL_RFTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         EFWR
 *  @access     SSP->SSPCTL1.bit.EFWR
 *  @brief      Enable FIFO Write/read
 *              Enable FIFO Write/read (Test Mode Bit)
 */
#define SSPCTL1_ALL_EFWR_Pos (14)
#define SSPCTL1_ALL_EFWR_Msk (0x1UL << SSPCTL1_ALL_EFWR_Pos)

typedef enum
{
    SSPCTL1_BIT_EFWR_FIFO_TEST_DISABLED     = 0,  /*!< FIFO write/read special function is disabled (normal SSP operational mode)   */
    SSPCTL1_BIT_EFWR_FIFO_TEST_ENABLED      = 1,  /*!< FIFO write/read special function is enabled                                  */
} SSPCTL1_BIT_EFWR;

#define SSPCTL1_ALL_EFWR_FIFO_TEST_DISABLED     ((0x0UL) << SSPCTL1_ALL_EFWR_Pos)
#define SSPCTL1_ALL_EFWR_FIFO_TEST_ENABLED      ((0x1UL) << SSPCTL1_ALL_EFWR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         STRF
 *  @access     SSP->SSPCTL1.bit.STRF
 *  @brief      Select FIFO For EFWR
 *              Select FIFO For EFWR (Test Mode Bit). Only when EFWR = 1.
 */
#define SSPCTL1_ALL_STRF_Pos (15)
#define SSPCTL1_ALL_STRF_Msk (0x1UL << SSPCTL1_ALL_STRF_Pos)

typedef enum
{
    SSPCTL1_BIT_STRF_SEL_TXFIFO     = 0,  /*!< TXFIFO is selected for both writes and reads through the SSP Data Register   */
    SSPCTL1_BIT_STRF_SEL_RXFIFO     = 1,  /*!< RXFIFO is selected for both writes and reads through the SSP Data Register   */
} SSPCTL1_BIT_STRF;

#define SSPCTL1_ALL_STRF_SEL_TXFIFO     ((0x0UL) << SSPCTL1_ALL_STRF_Pos)
#define SSPCTL1_ALL_STRF_SEL_RXFIFO     ((0x1UL) << SSPCTL1_ALL_STRF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         FRMINV
 *  @access     SSP->SSPCTL1.bit.FRMINV
 *  @brief      Invert Frame Signal
 */
#define SSPCTL1_ALL_FRMINV_Pos (16)
#define SSPCTL1_ALL_FRMINV_Msk (0x1UL << SSPCTL1_ALL_FRMINV_Pos)

typedef enum
{
    SSPCTL1_BIT_FRMINV_FRM_NOT_INVERT     = 0,  /*!< SSP_FRM polarity is determined by the PSP polarity bits                                                                          */
    SSPCTL1_BIT_FRMINV_FRM_INVERT         = 1,  /*!< SSP_FRM is inverted from normal-SSP_FRM (as defined by the PSP polarity bits). (Works in all frame formats: SPI, SSP, and PSP)   */
} SSPCTL1_BIT_FRMINV;

#define SSPCTL1_ALL_FRMINV_FRM_NOT_INVERT     ((0x0UL) << SSPCTL1_ALL_FRMINV_Pos)
#define SSPCTL1_ALL_FRMINV_FRM_INVERT         ((0x1UL) << SSPCTL1_ALL_FRMINV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         RXTOIE
 *  @access     SSP->SSPCTL1.bit.RXTOIE
 *  @brief      Receiver Time-out Interrupt Enable
 */
#define SSPCTL1_ALL_RXTOIE_Pos (19)
#define SSPCTL1_ALL_RXTOIE_Msk (0x1UL << SSPCTL1_ALL_RXTOIE_Pos)

typedef enum
{
    SSPCTL1_BIT_RXTOIE_RX_TIMEOUT_INT_DISABLE     = 0,  /*!< Receiver time-out interrupt is disabled   */
    SSPCTL1_BIT_RXTOIE_RX_TIMEOUT_INT_ENABLE      = 1,  /*!< Receiver time-out interrupt is enabled    */
} SSPCTL1_BIT_RXTOIE;

#define SSPCTL1_ALL_RXTOIE_RX_TIMEOUT_INT_DISABLE     ((0x0UL) << SSPCTL1_ALL_RXTOIE_Pos)
#define SSPCTL1_ALL_RXTOIE_RX_TIMEOUT_INT_ENABLE      ((0x1UL) << SSPCTL1_ALL_RXTOIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         RXONLY
 *  @access     SSP->SSPCTL1.bit.RXONLY
 *  @brief      Receive Without Transmit
 */
#define SSPCTL1_ALL_RXONLY_Pos (23)
#define SSPCTL1_ALL_RXONLY_Msk (0x1UL << SSPCTL1_ALL_RXONLY_Pos)

typedef enum
{
    SSPCTL1_BIT_RXONLY_TXRX_MODE     = 0,  /*!< Transmit/Receive mode           */
    SSPCTL1_BIT_RXONLY_RX_MODE       = 1,  /*!< Receive without Transmit mode   */
} SSPCTL1_BIT_RXONLY;

#define SSPCTL1_ALL_RXONLY_TXRX_MODE     ((0x0UL) << SSPCTL1_ALL_RXONLY_Pos)
#define SSPCTL1_ALL_RXONLY_RX_MODE       ((0x1UL) << SSPCTL1_ALL_RXONLY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         FRMDIR
 *  @access     SSP->SSPCTL1.bit.FRMDIR
 *  @brief      SSP Frame (SSP_FRM) Direction
 */
#define SSPCTL1_ALL_FRMDIR_Pos (24)
#define SSPCTL1_ALL_FRMDIR_Msk (0x1UL << SSPCTL1_ALL_FRMDIR_Pos)

typedef enum
{
    SSPCTL1_BIT_FRMDIR_MASTER_MODE     = 0,  /*!< Master mode, SSP port drives SSP_FRM    */
    SSPCTL1_BIT_FRMDIR_SLAVE_MODE      = 1,  /*!< Slave mode, SSP port receives SSP_FRM   */
} SSPCTL1_BIT_FRMDIR;

#define SSPCTL1_ALL_FRMDIR_MASTER_MODE     ((0x0UL) << SSPCTL1_ALL_FRMDIR_Pos)
#define SSPCTL1_ALL_FRMDIR_SLAVE_MODE      ((0x1UL) << SSPCTL1_ALL_FRMDIR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         CLKDIR
 *  @access     SSP->SSPCTL1.bit.CLKDIR
 *  @brief      SSP Serial Bit Rate Clock (SSP_CLK) Direction
 */
#define SSPCTL1_ALL_CLKDIR_Pos (25)
#define SSPCTL1_ALL_CLKDIR_Msk (0x1UL << SSPCTL1_ALL_CLKDIR_Pos)

typedef enum
{
    SSPCTL1_BIT_CLKDIR_MASTER_MODE     = 0,  /*!< Master mode, SSP port drives SSP_CLK    */
    SSPCTL1_BIT_CLKDIR_SLAVE_MODE      = 1,  /*!< Slave mode, SSP port receives SSP_CLK   */
} SSPCTL1_BIT_CLKDIR;

#define SSPCTL1_ALL_CLKDIR_MASTER_MODE     ((0x0UL) << SSPCTL1_ALL_CLKDIR_Pos)
#define SSPCTL1_ALL_CLKDIR_SLAVE_MODE      ((0x1UL) << SSPCTL1_ALL_CLKDIR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         SLVCLKSEL
 *  @access     SSP->SSPCTL1.bit.SLVCLKSEL
 *  @brief      Slave Clock Free Running
 */
#define SSPCTL1_ALL_SLVCLKSEL_Pos (28)
#define SSPCTL1_ALL_SLVCLKSEL_Msk (0x1UL << SSPCTL1_ALL_SLVCLKSEL_Pos)

typedef enum
{
    SSPCTL1_BIT_SLVCLKSEL_SLAVE_INTERNAL_SCLK     = 0,  /*!< Clock input to SSP_CLK is not active when SSPCTL1_CLKDIR is set to 1   */
    SSPCTL1_BIT_SLVCLKSEL_SLAVE_EXTENAL_SCLK      = 1,  /*!< Clock input to SSP_CLK is active when SSPCTL1_CLKDIR is set to 1       */
} SSPCTL1_BIT_SLVCLKSEL;

#define SSPCTL1_ALL_SLVCLKSEL_SLAVE_INTERNAL_SCLK     ((0x0UL) << SSPCTL1_ALL_SLVCLKSEL_Pos)
#define SSPCTL1_ALL_SLVCLKSEL_SLAVE_EXTENAL_SCLK      ((0x1UL) << SSPCTL1_ALL_SLVCLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         BITCNTERRIE
 *  @access     SSP->SSPCTL1.bit.BITCNTERRIE
 *  @brief      Enable Bit Count Error Interrupt
 */
#define SSPCTL1_ALL_BITCNTERRIE_Pos (29)
#define SSPCTL1_ALL_BITCNTERRIE_Msk (0x1UL << SSPCTL1_ALL_BITCNTERRIE_Pos)

typedef enum
{
    SSPCTL1_BIT_BITCNTERRIE_BCE_INT_DISABLE     = 0,  /*!< Interrupt due to a bit count error is disabled   */
    SSPCTL1_BIT_BITCNTERRIE_BCE_INT_ENABLE      = 1,  /*!< Interrupt due to a bit count error is enabled    */
} SSPCTL1_BIT_BITCNTERRIE;

#define SSPCTL1_ALL_BITCNTERRIE_BCE_INT_DISABLE     ((0x0UL) << SSPCTL1_ALL_BITCNTERRIE_Pos)
#define SSPCTL1_ALL_BITCNTERRIE_BCE_INT_ENABLE      ((0x1UL) << SSPCTL1_ALL_BITCNTERRIE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         TXTRIEN
 *  @access     SSP->SSPCTL1.bit.TXTRIEN
 *  @brief      TXD Tri-Stated Enable
 */
#define SSPCTL1_ALL_TXTRIEN_Pos (30)
#define SSPCTL1_ALL_TXTRIEN_Msk (0x1UL << SSPCTL1_ALL_TXTRIEN_Pos)

typedef enum
{
    SSPCTL1_BIT_TXTRIEN_TX_TRISTATE_DISABLE     = 0,  /*!< SSP_TXD output signal is not tri-stated            */
    SSPCTL1_BIT_TXTRIEN_TX_TRISTATE_ENALBLE     = 1,  /*!< SSP_TXD is tri-stated when not transmitting data   */
} SSPCTL1_BIT_TXTRIEN;

#define SSPCTL1_ALL_TXTRIEN_TX_TRISTATE_DISABLE     ((0x0UL) << SSPCTL1_ALL_TXTRIEN_Pos)
#define SSPCTL1_ALL_TXTRIEN_TX_TRISTATE_ENALBLE     ((0x1UL) << SSPCTL1_ALL_TXTRIEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPCTL1         TXTRITIME
 *  @access     SSP->SSPCTL1.bit.TXTRITIME
 *  @brief      TXD Tri-stated Enable On Last Phase
 */
#define SSPCTL1_ALL_TXTRITIME_Pos (31)
#define SSPCTL1_ALL_TXTRITIME_Msk (0x1UL << SSPCTL1_ALL_TXTRITIME_Pos)

typedef enum
{
    SSPCTL1_BIT_TXTRITIME_TX_TRISTATE_MODE_0     = 0,  /*!< SSP_TXD is tri-stated 1/2 clock cycle after the beginning of the LSB      */
    SSPCTL1_BIT_TXTRITIME_TX_TRISTATE_MODE_1     = 1,  /*!< SSP_TXD output signal is tri-stated on the clock edge that ends the LSB   */
} SSPCTL1_BIT_TXTRITIME;

#define SSPCTL1_ALL_TXTRITIME_TX_TRISTATE_MODE_0     ((0x0UL) << SSPCTL1_ALL_TXTRITIME_Pos)
#define SSPCTL1_ALL_TXTRITIME_TX_TRISTATE_MODE_1     ((0x1UL) << SSPCTL1_ALL_TXTRITIME_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          TNF
 *  @access     SSP->SSPSTS.bit.TNF
 *  @brief      Transmit FIFO Not Full
 */
#define SSPSTS_ALL_TNF_Pos (2)
#define SSPSTS_ALL_TNF_Msk (0x1UL << SSPSTS_ALL_TNF_Pos)

typedef enum
{
    SSPSTS_BIT_TNF_TXFIFO_FULL         = 0,  /*!< TXFIFO is full       */
    SSPSTS_BIT_TNF_TXFIFO_NOT_FULL     = 1,  /*!< TXFIFO is not full   */
} SSPSTS_BIT_TNF;

#define SSPSTS_ALL_TNF_TXFIFO_FULL         ((0x0UL) << SSPSTS_ALL_TNF_Pos)
#define SSPSTS_ALL_TNF_TXFIFO_NOT_FULL     ((0x1UL) << SSPSTS_ALL_TNF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          RNE
 *  @access     SSP->SSPSTS.bit.RNE
 *  @brief      Receive FIFO Not Empty
 */
#define SSPSTS_ALL_RNE_Pos (3)
#define SSPSTS_ALL_RNE_Msk (0x1UL << SSPSTS_ALL_RNE_Pos)

typedef enum
{
    SSPSTS_BIT_RNE_RXFIFO_EMPTY         = 0,  /*!< RXFIFO is empty       */
    SSPSTS_BIT_RNE_RXFIFO_NOT_EMPYT     = 1,  /*!< RXFIFO is not empty   */
} SSPSTS_BIT_RNE;

#define SSPSTS_ALL_RNE_RXFIFO_EMPTY         ((0x0UL) << SSPSTS_ALL_RNE_Pos)
#define SSPSTS_ALL_RNE_RXFIFO_NOT_EMPYT     ((0x1UL) << SSPSTS_ALL_RNE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          BUSY
 *  @access     SSP->SSPSTS.bit.BUSY
 *  @brief      SSP Busy
 */
#define SSPSTS_ALL_BUSY_Pos (4)
#define SSPSTS_ALL_BUSY_Msk (0x1UL << SSPSTS_ALL_BUSY_Pos)

typedef enum
{
    SSPSTS_BIT_BUSY_PORT_IDLE     = 0,  /*!< SSP port is idle or disabled                                  */
    SSPSTS_BIT_BUSY_PORT_BUSY     = 1,  /*!< SSP port is currently transmitting or receiving framed data   */
} SSPSTS_BIT_BUSY;

#define SSPSTS_ALL_BUSY_PORT_IDLE     ((0x0UL) << SSPSTS_ALL_BUSY_Pos)
#define SSPSTS_ALL_BUSY_PORT_BUSY     ((0x1UL) << SSPSTS_ALL_BUSY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          TFS
 *  @access     SSP->SSPSTS.bit.TFS
 *  @brief      Transmit FIFO Service Request
 */
#define SSPSTS_ALL_TFS_Pos (5)
#define SSPSTS_ALL_TFS_Msk (0x1UL << SSPSTS_ALL_TFS_Pos)

typedef enum
{
    SSPSTS_BIT_TFS_TXFIFO_EVENT_NOT_OCCUR     = 0,  /*!< TXFIFO level exceeds the TFT threshold (TFT + 1), or SSP port disabled             */
    SSPSTS_BIT_TFS_TXFIFO_EVENT_OCCUR         = 1,  /*!< TXFIFO level is at or below TFT threshold (TFT + 1), causes an interrupt request   */
} SSPSTS_BIT_TFS;

#define SSPSTS_ALL_TFS_TXFIFO_EVENT_NOT_OCCUR     ((0x0UL) << SSPSTS_ALL_TFS_Pos)
#define SSPSTS_ALL_TFS_TXFIFO_EVENT_OCCUR         ((0x1UL) << SSPSTS_ALL_TFS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          RFS
 *  @access     SSP->SSPSTS.bit.RFS
 *  @brief      Receive FIFO Service Request
 */
#define SSPSTS_ALL_RFS_Pos (6)
#define SSPSTS_ALL_RFS_Msk (0x1UL << SSPSTS_ALL_RFS_Pos)

typedef enum
{
    SSPSTS_BIT_RFS_RXFIFO_EVENT_NOT_OCCUR     = 0,  /*!< RXFIFO level is at or below RFT threshold (RFT), or SSP port is disabled   */
    SSPSTS_BIT_RFS_RXFIFO_EVENT_OCCUR         = 1,  /*!< RXFIFO level exceeds RFT threshold (RFT), causes an interrupt request      */
} SSPSTS_BIT_RFS;

#define SSPSTS_ALL_RFS_RXFIFO_EVENT_NOT_OCCUR     ((0x0UL) << SSPSTS_ALL_RFS_Pos)
#define SSPSTS_ALL_RFS_RXFIFO_EVENT_OCCUR         ((0x1UL) << SSPSTS_ALL_RFS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          RFOVF
 *  @access     SSP->SSPSTS.bit.RFOVF
 *  @brief      Receive FIFO Overflow
 */
#define SSPSTS_ALL_RFOVF_Pos (7)
#define SSPSTS_ALL_RFOVF_Msk (0x1UL << SSPSTS_ALL_RFOVF_Pos)

typedef enum
{
    SSPSTS_BIT_RFOVF_RXFIFO_OVERFLOW_NOT_OCCUR     = 0,  /*!< Receive FIFO Overflow                                              */
    SSPSTS_BIT_RFOVF_RXFIFO_OVERFLOW_OCCUR         = 1,  /*!< Attempted data write to full RXFIFO, causes an interrupt request   */
} SSPSTS_BIT_RFOVF;

#define SSPSTS_ALL_RFOVF_RXFIFO_OVERFLOW_NOT_OCCUR     ((0x0UL) << SSPSTS_ALL_RFOVF_Pos)
#define SSPSTS_ALL_RFOVF_RXFIFO_OVERFLOW_OCCUR         ((0x1UL) << SSPSTS_ALL_RFOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          TFLVL
 *  @access     SSP->SSPSTS.bit.TFLVL
 *  @brief      Transmit FIFO Level
 *              Number of entries in TXFIFO.
 *              
 *              Note: When the value 0x0 is read, the TXFIFO is either empty or full, and software should read the <Transmit FIFO Not Full> field.
 */
#define SSPSTS_ALL_TFLVL_Pos (8)
#define SSPSTS_ALL_TFLVL_Msk (0xFUL << SSPSTS_ALL_TFLVL_Pos)

#define SSPSTS_BIT_TFLVL

#define SSPSTS_ALL_TFLVL_(x) ((x) << SSPSTS_ALL_TFLVL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          RFLVL
 *  @access     SSP->SSPSTS.bit.RFLVL
 *  @brief      Receive FIFO Level
 *              Number of entries minus one in RXFIFO.
 *              
 *              Note: When the value 0xF is read, the RXFIFO is either empty or full, and software should read the <Receive FIFO Not Empty> field.
 */
#define SSPSTS_ALL_RFLVL_Pos (12)
#define SSPSTS_ALL_RFLVL_Msk (0xFUL << SSPSTS_ALL_RFLVL_Pos)

#define SSPSTS_BIT_RFLVL

#define SSPSTS_ALL_RFLVL_(x) ((x) << SSPSTS_ALL_RFLVL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          RXTOINT
 *  @access     SSP->SSPSTS.bit.RXTOINT
 *  @brief      Receiver Time-out Interrupt
 */
#define SSPSTS_ALL_RXTOINT_Pos (19)
#define SSPSTS_ALL_RXTOINT_Msk (0x1UL << SSPSTS_ALL_RXTOINT_Pos)

typedef enum
{
    SSPSTS_BIT_RXTOINT_RX_TIMEOUT_NOT_OCCUR     = 0,  /*!< No receiver time-out is pending                          */
    SSPSTS_BIT_RXTOINT_RX_TIMEOUT_OCCUR         = 1,  /*!< Receiver time-out pending, causes an interrupt request   */
} SSPSTS_BIT_RXTOINT;

#define SSPSTS_ALL_RXTOINT_RX_TIMEOUT_NOT_OCCUR     ((0x0UL) << SSPSTS_ALL_RXTOINT_Pos)
#define SSPSTS_ALL_RXTOINT_RX_TIMEOUT_OCCUR         ((0x1UL) << SSPSTS_ALL_RXTOINT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          TFUDF
 *  @access     SSP->SSPSTS.bit.TFUDF
 *  @brief      Transmit FIFO Underflow
 */
#define SSPSTS_ALL_TFUDF_Pos (21)
#define SSPSTS_ALL_TFUDF_Msk (0x1UL << SSPSTS_ALL_TFUDF_Pos)

typedef enum
{
    SSPSTS_BIT_TFUDF_TXFIFO_UNDERFLOW_NOT_OCCUR     = 0,  /*!< The TXFIFO has not experienced an underflow                                                                                                                                          */
    SSPSTS_BIT_TFUDF_TXFIFO_UNDERFLOW_OCCUR         = 1,  /*!< A read from the TXFIFO was attempted when the TXFIFO was empty, causes an interrupt if it is enabled (<Transmit FIFO Underrun Interrupt Mask> in the SSP Control Register 0 is 0).   */
} SSPSTS_BIT_TFUDF;

#define SSPSTS_ALL_TFUDF_TXFIFO_UNDERFLOW_NOT_OCCUR     ((0x0UL) << SSPSTS_ALL_TFUDF_Pos)
#define SSPSTS_ALL_TFUDF_TXFIFO_UNDERFLOW_OCCUR         ((0x1UL) << SSPSTS_ALL_TFUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          SLVCLKSTS
 *  @access     SSP->SSPSTS.bit.SLVCLKSTS
 *  @brief      Slave Clock Status
 */
#define SSPSTS_ALL_SLVCLKSTS_Pos (22)
#define SSPSTS_ALL_SLVCLKSTS_Msk (0x1UL << SSPSTS_ALL_SLVCLKSTS_Pos)

typedef enum
{
    SSPSTS_BIT_SLVCLKSTS_SLAVE_PORT_READY     = 0,  /*!< The SSP port is ready for slave clock operations                  */
    SSPSTS_BIT_SLVCLKSTS_SLAVE_PORT_BUSY      = 1,  /*!< The SSP port is currently busy synchronizing slave mode signals   */
} SSPSTS_BIT_SLVCLKSTS;

#define SSPSTS_ALL_SLVCLKSTS_SLAVE_PORT_READY     ((0x0UL) << SSPSTS_ALL_SLVCLKSTS_Pos)
#define SSPSTS_ALL_SLVCLKSTS_SLAVE_PORT_BUSY      ((0x1UL) << SSPSTS_ALL_SLVCLKSTS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          BITCNTERR
 *  @access     SSP->SSPSTS.bit.BITCNTERR
 *  @brief      Bit Count Error
 */
#define SSPSTS_ALL_BITCNTERR_Pos (23)
#define SSPSTS_ALL_BITCNTERR_Msk (0x1UL << SSPSTS_ALL_BITCNTERR_Pos)

typedef enum
{
    SSPSTS_BIT_BITCNTERR_BCE_NOT_OCCUR     = 0,  /*!< The SSP port has not experienced a bit count error                  */
    SSPSTS_BIT_BITCNTERR_BCE_OCCUR         = 1,  /*!< The SSP_FRM signal was asserted when the bit counter was not zero   */
} SSPSTS_BIT_BITCNTERR;

#define SSPSTS_ALL_BITCNTERR_BCE_NOT_OCCUR     ((0x0UL) << SSPSTS_ALL_BITCNTERR_Pos)
#define SSPSTS_ALL_BITCNTERR_BCE_OCCUR         ((0x1UL) << SSPSTS_ALL_BITCNTERR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          TFODDSTS
 *  @access     SSP->SSPSTS.bit.TFODDSTS
 *  @brief      TX FIFO Odd Sample Status
 *              When SSP port is in packed mode, the number of samples in the TX FIFO is:
 *              (<Transmit FIFO Level>*2 + this field), when <Transmit FIFO Not Full>=1;
 *              32, when <Transmit FIFO Not Full>=0.
 *              
 *              The TX FIFO cannot accept new data when <Transmit FIFO Not Full>=1 and <Transmit FIFO Level>=15 and this field=1. (The TX FIFO has 31 samples).
 *              
 *              Note: that this bit needs to be read only when FIFO Packing is enabled (<FIFO Packing Enable> in the SSP Control Register 0 set). Otherwise this bit is zero.
 */
#define SSPSTS_ALL_TFODDSTS_Pos (30)
#define SSPSTS_ALL_TFODDSTS_Msk (0x1UL << SSPSTS_ALL_TFODDSTS_Pos)

typedef enum
{
    SSPSTS_BIT_TFODDSTS_EVEN_SAMPLE_IN_TXFIFO     = 0,  /*!< TXFIFO entry has an even number of samples   */
    SSPSTS_BIT_TFODDSTS_ODD_SAMPLE_IN_TXFIFO      = 1,  /*!< TXFIFO entry has an even number of samples   */
} SSPSTS_BIT_TFODDSTS;

#define SSPSTS_ALL_TFODDSTS_EVEN_SAMPLE_IN_TXFIFO     ((0x0UL) << SSPSTS_ALL_TFODDSTS_Pos)
#define SSPSTS_ALL_TFODDSTS_ODD_SAMPLE_IN_TXFIFO      ((0x1UL) << SSPSTS_ALL_TFODDSTS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPSTS          RFODDSTS
 *  @access     SSP->SSPSTS.bit.RFODDSTS
 *  @brief      RX FIFO Odd Sample Status
 *              Note: that this bit needs to be looked at only when FIFO Packing is enabled (<FIFO Packing Enable> field in SSP Control Register 0 is set). Otherwise this bit is zero.
 *              When SSP port is in Packed mode, and the CPU is used to read the RXFIFO, CPU should make sure that <Receive FIFO Not Empty>=1 AND this field=0 before it attempts to read the RXFIFO.
 */
#define SSPSTS_ALL_RFODDSTS_Pos (31)
#define SSPSTS_ALL_RFODDSTS_Msk (0x1UL << SSPSTS_ALL_RFODDSTS_Pos)

typedef enum
{
    SSPSTS_BIT_RFODDSTS_2_SAMPLE_IN_RXFIFO     = 0,  /*!< RXFIFO entry has 2 samples   */
    SSPSTS_BIT_RFODDSTS_1_SAMPLE_IN_RXFIFO     = 1,  /*!< RXFIFO entry has 1 sample    */
} SSPSTS_BIT_RFODDSTS;

#define SSPSTS_ALL_RFODDSTS_2_SAMPLE_IN_RXFIFO     ((0x0UL) << SSPSTS_ALL_RFODDSTS_Pos)
#define SSPSTS_ALL_RFODDSTS_1_SAMPLE_IN_RXFIFO     ((0x1UL) << SSPSTS_ALL_RFODDSTS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPFRC          TFREQ
 *  @access     SSP->SSPFRC.bit.TFREQ
 *  @brief      Test TXFIFO Service Request
 */
#define SSPFRC_ALL_TFREQ_Pos (5)
#define SSPFRC_ALL_TFREQ_Msk (0x1UL << SSPFRC_ALL_TFREQ_Pos)

typedef enum
{
    SSPFRC_BIT_TFREQ_NO_EFFECT                      = 0,  /*!< No TXFIFO-service request                                   */
    SSPFRC_BIT_TFREQ_FORCE_TXFIFO_REQUEST_EVENT     = 1,  /*!< Generates a non-maskable TXFIFO-service interrupt request   */
} SSPFRC_BIT_TFREQ;

#define SSPFRC_ALL_TFREQ_NO_EFFECT                      ((0x0UL) << SSPFRC_ALL_TFREQ_Pos)
#define SSPFRC_ALL_TFREQ_FORCE_TXFIFO_REQUEST_EVENT     ((0x1UL) << SSPFRC_ALL_TFREQ_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPFRC          RFREQ
 *  @access     SSP->SSPFRC.bit.RFREQ
 *  @brief      Test RXFIFO Service Request
 */
#define SSPFRC_ALL_RFREQ_Pos (6)
#define SSPFRC_ALL_RFREQ_Msk (0x1UL << SSPFRC_ALL_RFREQ_Pos)

typedef enum
{
    SSPFRC_BIT_RFREQ_NO_EFFECT                      = 0,  /*!< No RXFIFO-service request                                   */
    SSPFRC_BIT_RFREQ_FORCE_RXFIFO_REQUEST_EVENT     = 1,  /*!< Generates a non-maskable RXFIFO-service interrupt request   */
} SSPFRC_BIT_RFREQ;

#define SSPFRC_ALL_RFREQ_NO_EFFECT                      ((0x0UL) << SSPFRC_ALL_RFREQ_Pos)
#define SSPFRC_ALL_RFREQ_FORCE_RXFIFO_REQUEST_EVENT     ((0x1UL) << SSPFRC_ALL_RFREQ_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPFRC          RFOVF
 *  @access     SSP->SSPFRC.bit.RFOVF
 *  @brief      Test RXFIFO Overrun
 */
#define SSPFRC_ALL_RFOVF_Pos (7)
#define SSPFRC_ALL_RFOVF_Msk (0x1UL << SSPFRC_ALL_RFOVF_Pos)

typedef enum
{
    SSPFRC_BIT_RFOVF_NO_EFFECT                   = 0,  /*!< No RXFIFO overflow service request                           */
    SSPFRC_BIT_RFOVF_FORCE_RX_OVERFLOW_EVENT     = 1,  /*!< Generates a non-maskable RXFIFO overflow interrupt request   */
} SSPFRC_BIT_RFOVF;

#define SSPFRC_ALL_RFOVF_NO_EFFECT                   ((0x0UL) << SSPFRC_ALL_RFOVF_Pos)
#define SSPFRC_ALL_RFOVF_FORCE_RX_OVERFLOW_EVENT     ((0x1UL) << SSPFRC_ALL_RFOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPDATA         VAL
 *  @access     SSP->SSPDATA.bit.VAL
 *  @brief      DATA value
 *              Data to be written to the TXFIFO or read from the RXFIFO
 */
#define SSPDATA_ALL_VAL_Pos (0)
#define SSPDATA_ALL_VAL_Msk (0xFFFFFFFFUL << SSPDATA_ALL_VAL_Pos)

#define SSPDATA_BIT_VAL

#define SSPDATA_ALL_VAL_(x) ((x) << SSPDATA_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTO           VAL
 *  @access     SSP->SSPTO.bit.VAL
 *  @brief      Timeout Value
 *              Define the time-out interval by 2^VAL-1.
 */
#define SSPTO_ALL_VAL_Pos (0)
#define SSPTO_ALL_VAL_Msk (0xFFFFFFUL << SSPTO_ALL_VAL_Pos)

#define SSPTO_BIT_VAL

#define SSPTO_ALL_VAL_(x) ((x) << SSPTO_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          CLKMODE
 *  @access     SSP->SSPPSP.bit.CLKMODE
 *  @brief      Serial Bit-rate Clock Mode
 */
#define SSPPSP_ALL_CLKMODE_Pos (0)
#define SSPPSP_ALL_CLKMODE_Msk (0x3UL << SSPPSP_ALL_CLKMODE_Pos)

typedef enum
{
    SSPPSP_BIT_CLKMODE_BIT_RATE_CLK_MODE_0     = 0,  /*!< Data Driven (Falling), Data Sampled (Rising), Idle State (Low)    */
    SSPPSP_BIT_CLKMODE_BIT_RATE_CLK_MODE_1     = 1,  /*!< Data Driven (Rising), Data Sampled (Falling), Idle State (Low)    */
    SSPPSP_BIT_CLKMODE_BIT_RATE_CLK_MODE_2     = 2,  /*!< Data Driven (Rising), Data Sampled (Falling), Idle State (High)   */
    SSPPSP_BIT_CLKMODE_BIT_RATE_CLK_MODE_3     = 3,  /*!< Data Driven (Falling), Data Sampled (Rising), Idle State (High)   */
} SSPPSP_BIT_CLKMODE;

#define SSPPSP_ALL_CLKMODE_BIT_RATE_CLK_MODE_0     ((0x0UL) << SSPPSP_ALL_CLKMODE_Pos)
#define SSPPSP_ALL_CLKMODE_BIT_RATE_CLK_MODE_1     ((0x1UL) << SSPPSP_ALL_CLKMODE_Pos)
#define SSPPSP_ALL_CLKMODE_BIT_RATE_CLK_MODE_2     ((0x2UL) << SSPPSP_ALL_CLKMODE_Pos)
#define SSPPSP_ALL_CLKMODE_BIT_RATE_CLK_MODE_3     ((0x3UL) << SSPPSP_ALL_CLKMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          FRMPOL
 *  @access     SSP->SSPPSP.bit.FRMPOL
 *  @brief      Serial Frame Polarity
 */
#define SSPPSP_ALL_FRMPOL_Pos (2)
#define SSPPSP_ALL_FRMPOL_Msk (0x1UL << SSPPSP_ALL_FRMPOL_Pos)

typedef enum
{
    SSPPSP_BIT_FRMPOL_FRM_ACTIVE_LOW      = 0,  /*!< SSP_FRM is active low (0b0)    */
    SSPPSP_BIT_FRMPOL_FRM_ACTIVE_HIGH     = 1,  /*!< SSP_FRM is active high (0b1)   */
} SSPPSP_BIT_FRMPOL;

#define SSPPSP_ALL_FRMPOL_FRM_ACTIVE_LOW      ((0x0UL) << SSPPSP_ALL_FRMPOL_Pos)
#define SSPPSP_ALL_FRMPOL_FRM_ACTIVE_HIGH     ((0x1UL) << SSPPSP_ALL_FRMPOL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          ETDS
 *  @access     SSP->SSPPSP.bit.ETDS
 *  @brief      End Of Transfer Data State
 */
#define SSPPSP_ALL_ETDS_Pos (3)
#define SSPPSP_ALL_ETDS_Msk (0x1UL << SSPPSP_ALL_ETDS_Pos)

typedef enum
{
    SSPPSP_BIT_ETDS_TRANSFER_NOT_END     = 0,  /*!< Transfer pending   */
    SSPPSP_BIT_ETDS_TRANSFER_END         = 1,  /*!< Transfer ended     */
} SSPPSP_BIT_ETDS;

#define SSPPSP_ALL_ETDS_TRANSFER_NOT_END     ((0x0UL) << SSPPSP_ALL_ETDS_Pos)
#define SSPPSP_ALL_ETDS_TRANSFER_END         ((0x1UL) << SSPPSP_ALL_ETDS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          STARTDLY
 *  @access     SSP->SSPPSP.bit.STARTDLY
 *  @brief      Start Delay
 *              Programmed value specifies the number (0-7) of non-active clocks (SSP_CLK) that define the duration of idle time
 *              Note: Do not use in PSP Network mode.
 */
#define SSPPSP_ALL_STARTDLY_Pos (4)
#define SSPPSP_ALL_STARTDLY_Msk (0x7UL << SSPPSP_ALL_STARTDLY_Pos)

typedef enum
{
    SSPPSP_BIT_STARTDLY_START_DELAY_LEN_0     = 0,  /*!< Start Delay by 0 clock   */
    SSPPSP_BIT_STARTDLY_START_DELAY_LEN_1     = 1,  /*!< Start Delay by 1 clock   */
    SSPPSP_BIT_STARTDLY_START_DELAY_LEN_2     = 2,  /*!< Start Delay by 2 clock   */
    SSPPSP_BIT_STARTDLY_START_DELAY_LEN_3     = 3,  /*!< Start Delay by 3 clock   */
    SSPPSP_BIT_STARTDLY_START_DELAY_LEN_4     = 4,  /*!< Start Delay by 4 clock   */
    SSPPSP_BIT_STARTDLY_START_DELAY_LEN_5     = 5,  /*!< Start Delay by 5 clock   */
    SSPPSP_BIT_STARTDLY_START_DELAY_LEN_6     = 6,  /*!< Start Delay by 6 clock   */
    SSPPSP_BIT_STARTDLY_START_DELAY_LEN_7     = 7,  /*!< Start Delay by 7 clock   */
} SSPPSP_BIT_STARTDLY;

#define SSPPSP_ALL_STARTDLY_START_DELAY_LEN_0     ((0x0UL) << SSPPSP_ALL_STARTDLY_Pos)
#define SSPPSP_ALL_STARTDLY_START_DELAY_LEN_1     ((0x1UL) << SSPPSP_ALL_STARTDLY_Pos)
#define SSPPSP_ALL_STARTDLY_START_DELAY_LEN_2     ((0x2UL) << SSPPSP_ALL_STARTDLY_Pos)
#define SSPPSP_ALL_STARTDLY_START_DELAY_LEN_3     ((0x3UL) << SSPPSP_ALL_STARTDLY_Pos)
#define SSPPSP_ALL_STARTDLY_START_DELAY_LEN_4     ((0x4UL) << SSPPSP_ALL_STARTDLY_Pos)
#define SSPPSP_ALL_STARTDLY_START_DELAY_LEN_5     ((0x5UL) << SSPPSP_ALL_STARTDLY_Pos)
#define SSPPSP_ALL_STARTDLY_START_DELAY_LEN_6     ((0x6UL) << SSPPSP_ALL_STARTDLY_Pos)
#define SSPPSP_ALL_STARTDLY_START_DELAY_LEN_7     ((0x7UL) << SSPPSP_ALL_STARTDLY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          DMYSTART
 *  @access     SSP->SSPPSP.bit.DMYSTART
 *  @brief      Dummy Start
 *              Least-significant bits of the dummy start delay
 *              Programmed value of this field specifies the number (0-15) of active clocks (SSP_CLKs) between the end of start delay and when the most-significant bit of transmit/receive data is driven.
 *              Note: Do not use in PSP Network mode.
 */
#define SSPPSP_ALL_DMYSTART_Pos (7)
#define SSPPSP_ALL_DMYSTART_Msk (0x3UL << SSPPSP_ALL_DMYSTART_Pos)

typedef enum
{
    SSPPSP_BIT_DMYSTART_DUMMY_START_DELAY_LEN_0     = 0,  /*!< Dummy start by 0 clock   */
    SSPPSP_BIT_DMYSTART_DUMMY_START_DELAY_LEN_1     = 1,  /*!< Dummy start by 1 clock   */
    SSPPSP_BIT_DMYSTART_DUMMY_START_DELAY_LEN_2     = 2,  /*!< Dummy start by 2 clock   */
    SSPPSP_BIT_DMYSTART_DUMMY_START_DELAY_LEN_3     = 3,  /*!< Dummy start by 3 clock   */
} SSPPSP_BIT_DMYSTART;

#define SSPPSP_ALL_DMYSTART_DUMMY_START_DELAY_LEN_0     ((0x0UL) << SSPPSP_ALL_DMYSTART_Pos)
#define SSPPSP_ALL_DMYSTART_DUMMY_START_DELAY_LEN_1     ((0x1UL) << SSPPSP_ALL_DMYSTART_Pos)
#define SSPPSP_ALL_DMYSTART_DUMMY_START_DELAY_LEN_2     ((0x2UL) << SSPPSP_ALL_DMYSTART_Pos)
#define SSPPSP_ALL_DMYSTART_DUMMY_START_DELAY_LEN_3     ((0x3UL) << SSPPSP_ALL_DMYSTART_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          FRMDLY
 *  @access     SSP->SSPPSP.bit.FRMDLY
 *  @brief      Serial Frame Delay
 *              Programmed value specifies the number (0 -127) of active one-half clocks (SSP_CLK) asserted from the mostsignificant bit of SSP_TXD (output) or SSP_RXD (input) being driven to SSP_FRM.
 *              Note: Do not use in PSP Network mode.
 */
#define SSPPSP_ALL_FRMDLY_Pos (9)
#define SSPPSP_ALL_FRMDLY_Msk (0x7FUL << SSPPSP_ALL_FRMDLY_Pos)

#define SSPPSP_BIT_FRMDLY

#define SSPPSP_ALL_FRMDLY_(x) ((x) << SSPPSP_ALL_FRMDLY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          FRMWIDTH
 *  @access     SSP->SSPPSP.bit.FRMWIDTH
 *  @brief      Serial Frame Width
 *              Least-significant bits of the serial frame width Programmed value of this field specifies the frame width from 0x00 (one SSP_CLK cycle) to 0x3F (63 SSP_CLK cycles).
 */
#define SSPPSP_ALL_FRMWIDTH_Pos (16)
#define SSPPSP_ALL_FRMWIDTH_Msk (0x3FUL << SSPPSP_ALL_FRMWIDTH_Pos)

#define SSPPSP_BIT_FRMWIDTH

#define SSPPSP_ALL_FRMWIDTH_(x) ((x) << SSPPSP_ALL_FRMWIDTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          DMYSTOP
 *  @access     SSP->SSPPSP.bit.DMYSTOP
 *  @brief      Dummy Stop
 *              The least-significant bits of the dummy stop delay Programmed value of <Extended Dummy Stop> + this field specifies the number (0-31) of active clocks (SSP_CLK) that follow the end of the transmitted data.
 *              Note: Do not use in PSP Network mode.
 */
#define SSPPSP_ALL_DMYSTOP_Pos (23)
#define SSPPSP_ALL_DMYSTOP_Msk (0x3UL << SSPPSP_ALL_DMYSTOP_Pos)

typedef enum
{
    SSPPSP_BIT_DMYSTOP_DUMMY_STOP_LEN_0     = 0,  /*!< Dummy Stop length 0   */
    SSPPSP_BIT_DMYSTOP_DUMMY_STOP_LEN_1     = 1,  /*!< Dummy Stop length 1   */
    SSPPSP_BIT_DMYSTOP_DUMMY_STOP_LEN_2     = 2,  /*!< Dummy Stop length 2   */
    SSPPSP_BIT_DMYSTOP_DUMMY_STOP_LEN_3     = 3,  /*!< Dummy Stop length 3   */
} SSPPSP_BIT_DMYSTOP;

#define SSPPSP_ALL_DMYSTOP_DUMMY_STOP_LEN_0     ((0x0UL) << SSPPSP_ALL_DMYSTOP_Pos)
#define SSPPSP_ALL_DMYSTOP_DUMMY_STOP_LEN_1     ((0x1UL) << SSPPSP_ALL_DMYSTOP_Pos)
#define SSPPSP_ALL_DMYSTOP_DUMMY_STOP_LEN_2     ((0x2UL) << SSPPSP_ALL_DMYSTOP_Pos)
#define SSPPSP_ALL_DMYSTOP_DUMMY_STOP_LEN_3     ((0x3UL) << SSPPSP_ALL_DMYSTOP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          FRMSYNC
 *  @access     SSP->SSPPSP.bit.FRMSYNC
 *  @brief      Frame Sync Relative Timing Bit
 */
#define SSPPSP_ALL_FRMSYNC_Pos (25)
#define SSPPSP_ALL_FRMSYNC_Msk (0x1UL << SSPPSP_ALL_FRMSYNC_Pos)

typedef enum
{
    SSPPSP_BIT_FRMSYNC_FRAME_INTERVAL_DMYSTOP        = 0,  /*!< Next frame is asserted after the end of the DMYSTOP timing   */
    SSPPSP_BIT_FRMSYNC_FRAME_NO_INTERVAL_DMYSTOP     = 1,  /*!< Next frame is asserted with the LSB of the previous frame    */
} SSPPSP_BIT_FRMSYNC;

#define SSPPSP_ALL_FRMSYNC_FRAME_INTERVAL_DMYSTOP        ((0x0UL) << SSPPSP_ALL_FRMSYNC_Pos)
#define SSPPSP_ALL_FRMSYNC_FRAME_NO_INTERVAL_DMYSTOP     ((0x1UL) << SSPPSP_ALL_FRMSYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          EDMYSTART
 *  @access     SSP->SSPPSP.bit.EDMYSTART
 *  @brief      Extended Dummy Start
 *              The most-significant bits of the dummy start delay
 *              Note: Do not use in PSP Network mode.
 */
#define SSPPSP_ALL_EDMYSTART_Pos (26)
#define SSPPSP_ALL_EDMYSTART_Msk (0x3UL << SSPPSP_ALL_EDMYSTART_Pos)

typedef enum
{
    SSPPSP_BIT_EDMYSTART_EXTENDED_DUMMY_START_LEN_0     = 0,  /*!< EXTENDED DUMMY START 0    */
    SSPPSP_BIT_EDMYSTART_EXTENDED_DUMMY_START_LEN_1     = 1,  /*!< EXTENDED DUMMY START 1    */
    SSPPSP_BIT_EDMYSTART_EXTENDED_DUMMY_START_LEN_2     = 2,  /*!< EXTENDED DUMMY START 2    */
    SSPPSP_BIT_EDMYSTART_EXTENDED_DUMMY_START_LEN_3     = 3,  /*!< EXTENDED DUMMY START 3    */
} SSPPSP_BIT_EDMYSTART;

#define SSPPSP_ALL_EDMYSTART_EXTENDED_DUMMY_START_LEN_0     ((0x0UL) << SSPPSP_ALL_EDMYSTART_Pos)
#define SSPPSP_ALL_EDMYSTART_EXTENDED_DUMMY_START_LEN_1     ((0x1UL) << SSPPSP_ALL_EDMYSTART_Pos)
#define SSPPSP_ALL_EDMYSTART_EXTENDED_DUMMY_START_LEN_2     ((0x2UL) << SSPPSP_ALL_EDMYSTART_Pos)
#define SSPPSP_ALL_EDMYSTART_EXTENDED_DUMMY_START_LEN_3     ((0x3UL) << SSPPSP_ALL_EDMYSTART_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPPSP          EDMYSTOP
 *  @access     SSP->SSPPSP.bit.EDMYSTOP
 *  @brief      Extended Dummy Stop
 *              The most-significant bits of the dummy stop delay
 *              Note: Do not use in PSP Network mode.
 */
#define SSPPSP_ALL_EDMYSTOP_Pos (28)
#define SSPPSP_ALL_EDMYSTOP_Msk (0x7UL << SSPPSP_ALL_EDMYSTOP_Pos)

typedef enum
{
    SSPPSP_BIT_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_0     = 0,  /*!< EXTENDED DUMMY STOP 0    */
    SSPPSP_BIT_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_1     = 1,  /*!< EXTENDED DUMMY STOP 1    */
    SSPPSP_BIT_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_2     = 2,  /*!< EXTENDED DUMMY STOP 2    */
    SSPPSP_BIT_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_3     = 3,  /*!< EXTENDED DUMMY STOP 3    */
    SSPPSP_BIT_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_4     = 4,  /*!< EXTENDED DUMMY STOP 4    */
    SSPPSP_BIT_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_5     = 5,  /*!< EXTENDED DUMMY STOP 5    */
    SSPPSP_BIT_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_6     = 6,  /*!< EXTENDED DUMMY STOP 6    */
    SSPPSP_BIT_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_7     = 7,  /*!< EXTENDED DUMMY STOP 7    */
} SSPPSP_BIT_EDMYSTOP;

#define SSPPSP_ALL_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_0     ((0x0UL) << SSPPSP_ALL_EDMYSTOP_Pos)
#define SSPPSP_ALL_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_1     ((0x1UL) << SSPPSP_ALL_EDMYSTOP_Pos)
#define SSPPSP_ALL_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_2     ((0x2UL) << SSPPSP_ALL_EDMYSTOP_Pos)
#define SSPPSP_ALL_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_3     ((0x3UL) << SSPPSP_ALL_EDMYSTOP_Pos)
#define SSPPSP_ALL_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_4     ((0x4UL) << SSPPSP_ALL_EDMYSTOP_Pos)
#define SSPPSP_ALL_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_5     ((0x5UL) << SSPPSP_ALL_EDMYSTOP_Pos)
#define SSPPSP_ALL_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_6     ((0x6UL) << SSPPSP_ALL_EDMYSTOP_Pos)
#define SSPPSP_ALL_EDMYSTOP_EXTENDED_DUMMY_STOP_LEN_7     ((0x7UL) << SSPPSP_ALL_EDMYSTOP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTXSLOTEN     SLOT0
 *  @access     SSP->SSPTXSLOTEN.bit.SLOT0
 *  @brief      Tx Time Slot 0 Active
 */
#define SSPTXSLOTEN_ALL_SLOT0_Pos (0)
#define SSPTXSLOTEN_ALL_SLOT0_Msk (0x1UL << SSPTXSLOTEN_ALL_SLOT0_Pos)

typedef enum
{
    SSPTXSLOTEN_BIT_SLOT0_TX_DISABLE     = 0,  /*!< SSP port does NOT transmit data in this time slot   */
    SSPTXSLOTEN_BIT_SLOT0_TX_ENABLE      = 1,  /*!< SSP port does transmit data in this time slot       */
} SSPTXSLOTEN_BIT_SLOT0;

#define SSPTXSLOTEN_ALL_SLOT0_TX_DISABLE     ((0x0UL) << SSPTXSLOTEN_ALL_SLOT0_Pos)
#define SSPTXSLOTEN_ALL_SLOT0_TX_ENABLE      ((0x1UL) << SSPTXSLOTEN_ALL_SLOT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTXSLOTEN     SLOT1
 *  @access     SSP->SSPTXSLOTEN.bit.SLOT1
 *  @brief      Tx Time Slot 1 Active
 */
#define SSPTXSLOTEN_ALL_SLOT1_Pos (1)
#define SSPTXSLOTEN_ALL_SLOT1_Msk (0x1UL << SSPTXSLOTEN_ALL_SLOT1_Pos)

typedef enum
{
    SSPTXSLOTEN_BIT_SLOT1_TX_DISABLE     = 0,  /*!< SSP port does NOT transmit data in this time slot   */
    SSPTXSLOTEN_BIT_SLOT1_TX_ENABLE      = 1,  /*!< SSP port does NOT transmit data in this time slot   */
} SSPTXSLOTEN_BIT_SLOT1;

#define SSPTXSLOTEN_ALL_SLOT1_TX_DISABLE     ((0x0UL) << SSPTXSLOTEN_ALL_SLOT1_Pos)
#define SSPTXSLOTEN_ALL_SLOT1_TX_ENABLE      ((0x1UL) << SSPTXSLOTEN_ALL_SLOT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTXSLOTEN     SLOT2
 *  @access     SSP->SSPTXSLOTEN.bit.SLOT2
 *  @brief      Tx Time Slot 2 Active
 */
#define SSPTXSLOTEN_ALL_SLOT2_Pos (2)
#define SSPTXSLOTEN_ALL_SLOT2_Msk (0x1UL << SSPTXSLOTEN_ALL_SLOT2_Pos)

typedef enum
{
    SSPTXSLOTEN_BIT_SLOT2_TX_DISABLE     = 0,  /*!< SSP port does transmit data in this time slot       */
    SSPTXSLOTEN_BIT_SLOT2_TX_ENABLE      = 1,  /*!< SSP port does NOT transmit data in this time slot   */
} SSPTXSLOTEN_BIT_SLOT2;

#define SSPTXSLOTEN_ALL_SLOT2_TX_DISABLE     ((0x0UL) << SSPTXSLOTEN_ALL_SLOT2_Pos)
#define SSPTXSLOTEN_ALL_SLOT2_TX_ENABLE      ((0x1UL) << SSPTXSLOTEN_ALL_SLOT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTXSLOTEN     SLOT3
 *  @access     SSP->SSPTXSLOTEN.bit.SLOT3
 *  @brief      Tx Time Slot 3 Active
 */
#define SSPTXSLOTEN_ALL_SLOT3_Pos (3)
#define SSPTXSLOTEN_ALL_SLOT3_Msk (0x1UL << SSPTXSLOTEN_ALL_SLOT3_Pos)

typedef enum
{
    SSPTXSLOTEN_BIT_SLOT3_TX_DISABLE     = 0,  /*!< SSP port does NOT transmit data in this time slot   */
    SSPTXSLOTEN_BIT_SLOT3_TX_ENABLE      = 1,  /*!< SSP port does NOT transmit data in this time slot   */
} SSPTXSLOTEN_BIT_SLOT3;

#define SSPTXSLOTEN_ALL_SLOT3_TX_DISABLE     ((0x0UL) << SSPTXSLOTEN_ALL_SLOT3_Pos)
#define SSPTXSLOTEN_ALL_SLOT3_TX_ENABLE      ((0x1UL) << SSPTXSLOTEN_ALL_SLOT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTXSLOTEN     SLOT4
 *  @access     SSP->SSPTXSLOTEN.bit.SLOT4
 *  @brief      Tx Time Slot 4 Active
 */
#define SSPTXSLOTEN_ALL_SLOT4_Pos (4)
#define SSPTXSLOTEN_ALL_SLOT4_Msk (0x1UL << SSPTXSLOTEN_ALL_SLOT4_Pos)

typedef enum
{
    SSPTXSLOTEN_BIT_SLOT4_TX_DISABLE     = 0,  /*!< SSP port does NOT transmit data in this time slot   */
    SSPTXSLOTEN_BIT_SLOT4_TX_ENABLE      = 1,  /*!< SSP port does transmit data in this time slot       */
} SSPTXSLOTEN_BIT_SLOT4;

#define SSPTXSLOTEN_ALL_SLOT4_TX_DISABLE     ((0x0UL) << SSPTXSLOTEN_ALL_SLOT4_Pos)
#define SSPTXSLOTEN_ALL_SLOT4_TX_ENABLE      ((0x1UL) << SSPTXSLOTEN_ALL_SLOT4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTXSLOTEN     SLOT5
 *  @access     SSP->SSPTXSLOTEN.bit.SLOT5
 *  @brief      Tx Time Slot 5 Active
 */
#define SSPTXSLOTEN_ALL_SLOT5_Pos (5)
#define SSPTXSLOTEN_ALL_SLOT5_Msk (0x1UL << SSPTXSLOTEN_ALL_SLOT5_Pos)

typedef enum
{
    SSPTXSLOTEN_BIT_SLOT5_TX_DISABLE     = 0,  /*!< SSP port does NOT transmit data in this time slot   */
    SSPTXSLOTEN_BIT_SLOT5_TX_ENABLE      = 1,  /*!< SSP port does NOT transmit data in this time slot   */
} SSPTXSLOTEN_BIT_SLOT5;

#define SSPTXSLOTEN_ALL_SLOT5_TX_DISABLE     ((0x0UL) << SSPTXSLOTEN_ALL_SLOT5_Pos)
#define SSPTXSLOTEN_ALL_SLOT5_TX_ENABLE      ((0x1UL) << SSPTXSLOTEN_ALL_SLOT5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTXSLOTEN     SLOT6
 *  @access     SSP->SSPTXSLOTEN.bit.SLOT6
 *  @brief      Tx Time Slot 6 Active
 */
#define SSPTXSLOTEN_ALL_SLOT6_Pos (6)
#define SSPTXSLOTEN_ALL_SLOT6_Msk (0x1UL << SSPTXSLOTEN_ALL_SLOT6_Pos)

typedef enum
{
    SSPTXSLOTEN_BIT_SLOT6_TX_DISABLE     = 0,  /*!< SSP port does transmit data in this time slot       */
    SSPTXSLOTEN_BIT_SLOT6_TX_ENABLE      = 1,  /*!< SSP port does NOT transmit data in this time slot   */
} SSPTXSLOTEN_BIT_SLOT6;

#define SSPTXSLOTEN_ALL_SLOT6_TX_DISABLE     ((0x0UL) << SSPTXSLOTEN_ALL_SLOT6_Pos)
#define SSPTXSLOTEN_ALL_SLOT6_TX_ENABLE      ((0x1UL) << SSPTXSLOTEN_ALL_SLOT6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPTXSLOTEN     SLOT7
 *  @access     SSP->SSPTXSLOTEN.bit.SLOT7
 *  @brief      Tx Time Slot 7 Active
 */
#define SSPTXSLOTEN_ALL_SLOT7_Pos (7)
#define SSPTXSLOTEN_ALL_SLOT7_Msk (0x1UL << SSPTXSLOTEN_ALL_SLOT7_Pos)

typedef enum
{
    SSPTXSLOTEN_BIT_SLOT7_TX_DISABLE     = 0,  /*!< SSP port does NOT transmit data in this time slot   */
    SSPTXSLOTEN_BIT_SLOT7_TX_ENABLE      = 1,  /*!< SSP port does NOT transmit data in this time slot   */
} SSPTXSLOTEN_BIT_SLOT7;

#define SSPTXSLOTEN_ALL_SLOT7_TX_DISABLE     ((0x0UL) << SSPTXSLOTEN_ALL_SLOT7_Pos)
#define SSPTXSLOTEN_ALL_SLOT7_TX_ENABLE      ((0x1UL) << SSPTXSLOTEN_ALL_SLOT7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPRXSLOTEN     SLOT0
 *  @access     SSP->SSPRXSLOTEN.bit.SLOT0
 *  @brief      Rx Time Slot 0 Active
 */
#define SSPRXSLOTEN_ALL_SLOT0_Pos (0)
#define SSPRXSLOTEN_ALL_SLOT0_Msk (0x1UL << SSPRXSLOTEN_ALL_SLOT0_Pos)

typedef enum
{
    SSPRXSLOTEN_BIT_SLOT0_RX_DISABLE     = 0,  /*!< SSP port does not receive data in this time slot   */
    SSPRXSLOTEN_BIT_SLOT0_RX_ENABLE      = 1,  /*!< SSP port receives data in this time slot           */
} SSPRXSLOTEN_BIT_SLOT0;

#define SSPRXSLOTEN_ALL_SLOT0_RX_DISABLE     ((0x0UL) << SSPRXSLOTEN_ALL_SLOT0_Pos)
#define SSPRXSLOTEN_ALL_SLOT0_RX_ENABLE      ((0x1UL) << SSPRXSLOTEN_ALL_SLOT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPRXSLOTEN     SLOT1
 *  @access     SSP->SSPRXSLOTEN.bit.SLOT1
 *  @brief      Rx Time Slot 1 Active
 */
#define SSPRXSLOTEN_ALL_SLOT1_Pos (1)
#define SSPRXSLOTEN_ALL_SLOT1_Msk (0x1UL << SSPRXSLOTEN_ALL_SLOT1_Pos)

typedef enum
{
    SSPRXSLOTEN_BIT_SLOT1_RX_DISABLE     = 0,  /*!< SSP port does not receive data in this time slot   */
    SSPRXSLOTEN_BIT_SLOT1_RX_ENABLE      = 1,  /*!< SSP port receives data in this time slot           */
} SSPRXSLOTEN_BIT_SLOT1;

#define SSPRXSLOTEN_ALL_SLOT1_RX_DISABLE     ((0x0UL) << SSPRXSLOTEN_ALL_SLOT1_Pos)
#define SSPRXSLOTEN_ALL_SLOT1_RX_ENABLE      ((0x1UL) << SSPRXSLOTEN_ALL_SLOT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPRXSLOTEN     SLOT2
 *  @access     SSP->SSPRXSLOTEN.bit.SLOT2
 *  @brief      Rx Time Slot 2 Active
 */
#define SSPRXSLOTEN_ALL_SLOT2_Pos (2)
#define SSPRXSLOTEN_ALL_SLOT2_Msk (0x1UL << SSPRXSLOTEN_ALL_SLOT2_Pos)

typedef enum
{
    SSPRXSLOTEN_BIT_SLOT2_RX_DISABLE     = 0,  /*!< SSP port does not receive data in this time slot   */
    SSPRXSLOTEN_BIT_SLOT2_RX_ENABLE      = 1,  /*!< SSP port receives data in this time slot           */
} SSPRXSLOTEN_BIT_SLOT2;

#define SSPRXSLOTEN_ALL_SLOT2_RX_DISABLE     ((0x0UL) << SSPRXSLOTEN_ALL_SLOT2_Pos)
#define SSPRXSLOTEN_ALL_SLOT2_RX_ENABLE      ((0x1UL) << SSPRXSLOTEN_ALL_SLOT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPRXSLOTEN     SLOT3
 *  @access     SSP->SSPRXSLOTEN.bit.SLOT3
 *  @brief      Rx Time Slot 3 Active
 */
#define SSPRXSLOTEN_ALL_SLOT3_Pos (3)
#define SSPRXSLOTEN_ALL_SLOT3_Msk (0x1UL << SSPRXSLOTEN_ALL_SLOT3_Pos)

typedef enum
{
    SSPRXSLOTEN_BIT_SLOT3_RX_DISABLE     = 0,  /*!< SSP port does not receive data in this time slot   */
    SSPRXSLOTEN_BIT_SLOT3_RX_ENABLE      = 1,  /*!< SSP port receives data in this time slot           */
} SSPRXSLOTEN_BIT_SLOT3;

#define SSPRXSLOTEN_ALL_SLOT3_RX_DISABLE     ((0x0UL) << SSPRXSLOTEN_ALL_SLOT3_Pos)
#define SSPRXSLOTEN_ALL_SLOT3_RX_ENABLE      ((0x1UL) << SSPRXSLOTEN_ALL_SLOT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPRXSLOTEN     SLOT4
 *  @access     SSP->SSPRXSLOTEN.bit.SLOT4
 *  @brief      Rx Time Slot 4 Active
 */
#define SSPRXSLOTEN_ALL_SLOT4_Pos (4)
#define SSPRXSLOTEN_ALL_SLOT4_Msk (0x1UL << SSPRXSLOTEN_ALL_SLOT4_Pos)

typedef enum
{
    SSPRXSLOTEN_BIT_SLOT4_RX_DISABLE     = 0,  /*!< SSP port does not receive data in this time slot   */
    SSPRXSLOTEN_BIT_SLOT4_RX_ENABLE      = 1,  /*!< SSP port receives data in this time slot           */
} SSPRXSLOTEN_BIT_SLOT4;

#define SSPRXSLOTEN_ALL_SLOT4_RX_DISABLE     ((0x0UL) << SSPRXSLOTEN_ALL_SLOT4_Pos)
#define SSPRXSLOTEN_ALL_SLOT4_RX_ENABLE      ((0x1UL) << SSPRXSLOTEN_ALL_SLOT4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPRXSLOTEN     SLOT5
 *  @access     SSP->SSPRXSLOTEN.bit.SLOT5
 *  @brief      Rx Time Slot 5 Active
 */
#define SSPRXSLOTEN_ALL_SLOT5_Pos (5)
#define SSPRXSLOTEN_ALL_SLOT5_Msk (0x1UL << SSPRXSLOTEN_ALL_SLOT5_Pos)

typedef enum
{
    SSPRXSLOTEN_BIT_SLOT5_RX_DISABLE     = 0,  /*!< SSP port does not receive data in this time slot   */
    SSPRXSLOTEN_BIT_SLOT5_RX_ENABLE      = 1,  /*!< SSP port receives data in this time slot           */
} SSPRXSLOTEN_BIT_SLOT5;

#define SSPRXSLOTEN_ALL_SLOT5_RX_DISABLE     ((0x0UL) << SSPRXSLOTEN_ALL_SLOT5_Pos)
#define SSPRXSLOTEN_ALL_SLOT5_RX_ENABLE      ((0x1UL) << SSPRXSLOTEN_ALL_SLOT5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPRXSLOTEN     SLOT6
 *  @access     SSP->SSPRXSLOTEN.bit.SLOT6
 *  @brief      Rx Time Slot 6 Active
 */
#define SSPRXSLOTEN_ALL_SLOT6_Pos (6)
#define SSPRXSLOTEN_ALL_SLOT6_Msk (0x1UL << SSPRXSLOTEN_ALL_SLOT6_Pos)

typedef enum
{
    SSPRXSLOTEN_BIT_SLOT6_RX_DISABLE     = 0,  /*!< SSP port does not receive data in this time slot   */
    SSPRXSLOTEN_BIT_SLOT6_RX_ENABLE      = 1,  /*!< SSP port receives data in this time slot           */
} SSPRXSLOTEN_BIT_SLOT6;

#define SSPRXSLOTEN_ALL_SLOT6_RX_DISABLE     ((0x0UL) << SSPRXSLOTEN_ALL_SLOT6_Pos)
#define SSPRXSLOTEN_ALL_SLOT6_RX_ENABLE      ((0x1UL) << SSPRXSLOTEN_ALL_SLOT6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPRXSLOTEN     SLOT7
 *  @access     SSP->SSPRXSLOTEN.bit.SLOT7
 *  @brief      Rx Time Slot 7 Active
 */
#define SSPRXSLOTEN_ALL_SLOT7_Pos (7)
#define SSPRXSLOTEN_ALL_SLOT7_Msk (0x1UL << SSPRXSLOTEN_ALL_SLOT7_Pos)

typedef enum
{
    SSPRXSLOTEN_BIT_SLOT7_RX_DISABLE     = 0,  /*!< SSP port does not receive data in this time slot   */
    SSPRXSLOTEN_BIT_SLOT7_RX_ENABLE      = 1,  /*!< SSP port receives data in this time slot           */
} SSPRXSLOTEN_BIT_SLOT7;

#define SSPRXSLOTEN_ALL_SLOT7_RX_DISABLE     ((0x0UL) << SSPRXSLOTEN_ALL_SLOT7_Pos)
#define SSPRXSLOTEN_ALL_SLOT7_RX_ENABLE      ((0x1UL) << SSPRXSLOTEN_ALL_SLOT7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPNETSTS       SLOTACT
 *  @access     SSP->SSPNETSTS.bit.SLOTACT
 *  @brief      Time Slot Status
 *              Value indicates which time slot is currently active. Because of synchronization between the SSP port's SSP_CLK domain and an internal bus clock domain, the value in this field becomes stable between the beginning and end of the currently active time slot.
 */
#define SSPNETSTS_ALL_SLOTACT_Pos (0)
#define SSPNETSTS_ALL_SLOTACT_Msk (0x7UL << SSPNETSTS_ALL_SLOTACT_Pos)

typedef enum
{
    SSPNETSTS_BIT_SLOTACT_1_ACTIVE_SLOT     = 0,  /*!< 1 Active slot    */
    SSPNETSTS_BIT_SLOTACT_2_ACTIVE_SLOT     = 1,  /*!< 2 Active slots   */
    SSPNETSTS_BIT_SLOTACT_3_ACTIVE_SLOT     = 2,  /*!< 3 Active slots   */
    SSPNETSTS_BIT_SLOTACT_4_ACTIVE_SLOT     = 3,  /*!< 4 Active slots   */
    SSPNETSTS_BIT_SLOTACT_5_ACTIVE_SLOT     = 4,  /*!< 5 Active slots   */
    SSPNETSTS_BIT_SLOTACT_6_ACTIVE_SLOT     = 5,  /*!< 6 Active slots   */
    SSPNETSTS_BIT_SLOTACT_7_ACTIVE_SLOT     = 6,  /*!< 7 Active slots   */
    SSPNETSTS_BIT_SLOTACT_8_ACTIVE_SLOT     = 7,  /*!< 8 Active slots   */
} SSPNETSTS_BIT_SLOTACT;

#define SSPNETSTS_ALL_SLOTACT_1_ACTIVE_SLOT     ((0x0UL) << SSPNETSTS_ALL_SLOTACT_Pos)
#define SSPNETSTS_ALL_SLOTACT_2_ACTIVE_SLOT     ((0x1UL) << SSPNETSTS_ALL_SLOTACT_Pos)
#define SSPNETSTS_ALL_SLOTACT_3_ACTIVE_SLOT     ((0x2UL) << SSPNETSTS_ALL_SLOTACT_Pos)
#define SSPNETSTS_ALL_SLOTACT_4_ACTIVE_SLOT     ((0x3UL) << SSPNETSTS_ALL_SLOTACT_Pos)
#define SSPNETSTS_ALL_SLOTACT_5_ACTIVE_SLOT     ((0x4UL) << SSPNETSTS_ALL_SLOTACT_Pos)
#define SSPNETSTS_ALL_SLOTACT_6_ACTIVE_SLOT     ((0x5UL) << SSPNETSTS_ALL_SLOTACT_Pos)
#define SSPNETSTS_ALL_SLOTACT_7_ACTIVE_SLOT     ((0x6UL) << SSPNETSTS_ALL_SLOTACT_Pos)
#define SSPNETSTS_ALL_SLOTACT_8_ACTIVE_SLOT     ((0x7UL) << SSPNETSTS_ALL_SLOTACT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   SSP             SSPNETSTS       BUSY
 *  @access     SSP->SSPNETSTS.bit.BUSY
 *  @brief      Network Mode Busy
 */
#define SSPNETSTS_ALL_BUSY_Pos (31)
#define SSPNETSTS_ALL_BUSY_Msk (0x1UL << SSPNETSTS_ALL_BUSY_Pos)

typedef enum
{
    SSPNETSTS_BIT_BUSY_NETWORK_IDLE     = 0,  /*!< SSP port is in network mode and no frame is currently active   */
    SSPNETSTS_BIT_BUSY_NETWORK_BUSY     = 1,  /*!< SSP port is in network mode and a frame is currently active    */
} SSPNETSTS_BIT_BUSY;

#define SSPNETSTS_ALL_BUSY_NETWORK_IDLE     ((0x0UL) << SSPNETSTS_ALL_BUSY_Pos)
#define SSPNETSTS_ALL_BUSY_NETWORK_BUSY     ((0x1UL) << SSPNETSTS_ALL_BUSY_Pos)





/********************************************************************************
*
* Module Name     I2C
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CCTL          MASTER
 *  @access     I2C->I2CCTL.bit.MASTER
 *  @brief      This bit controls whether the I2C master is enabled.
 *              NOTE: Software should ensure that if this bit is written with '1' then bit 6 should also be written with a '1'.
 */
#define I2CCTL_ALL_MASTER_Pos (0)
#define I2CCTL_ALL_MASTER_Msk (0x1UL << I2CCTL_ALL_MASTER_Pos)

typedef enum
{
    I2CCTL_BIT_MASTER_DISABLE     = 0,  /*!< Master disabled   */
    I2CCTL_BIT_MASTER_ENABLE      = 1,  /*!< Master enabled    */
} I2CCTL_BIT_MASTER;

#define I2CCTL_ALL_MASTER_DISABLE     ((0x0UL) << I2CCTL_ALL_MASTER_Pos)
#define I2CCTL_ALL_MASTER_ENABLE      ((0x1UL) << I2CCTL_ALL_MASTER_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CCTL          SPEED
 *  @access     I2C->I2CCTL.bit.SPEED
 *  @brief      These bits control at which speed the I2C operates; its setting is relevant only if one is operating the I2C in master mode. Hardware protects against illegal values being programmed by software. This register should be programmed only with a value in the range of 1 to 3; otherwise, hardware updates this register with the value of 3.
 */
#define I2CCTL_ALL_SPEED_Pos (1)
#define I2CCTL_ALL_SPEED_Msk (0x3UL << I2CCTL_ALL_SPEED_Pos)

typedef enum
{
    I2CCTL_BIT_SPEED_100K_BPS      = 1,  /*!< Standard mode (100 kbit/s)     */
    I2CCTL_BIT_SPEED_400K_BPS      = 2,  /*!< Fast mode (400 kbit/s)         */
    I2CCTL_BIT_SPEED_3400K_BPS     = 3,  /*!< High speed mode (3.4 Mbit/s)   */
} I2CCTL_BIT_SPEED;

#define I2CCTL_ALL_SPEED_100K_BPS      ((0x1UL) << I2CCTL_ALL_SPEED_Pos)
#define I2CCTL_ALL_SPEED_400K_BPS      ((0x2UL) << I2CCTL_ALL_SPEED_Pos)
#define I2CCTL_ALL_SPEED_3400K_BPS     ((0x3UL) << I2CCTL_ALL_SPEED_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CCTL          SLVADDR10B
 *  @access     I2C->I2CCTL.bit.SLVADDR10B
 *  @brief      When acting as a slave, this bit controls whether the I2C responds to 7- or 10-bit addresses.
 *              0x0: 7-bit addressing. The I2C ignores transactions that involve 10-bit addressing; for 7-bit addressing, only the lower 7 bits of the I2CSLVADDR register are compared.
 *              0x1: 10-bit addressing. The I2C responds to only 10-bit addressing transfers that match the full 10 bits of the I2CSLVADDR register.
 */
#define I2CCTL_ALL_SLVADDR10B_Pos (3)
#define I2CCTL_ALL_SLVADDR10B_Msk (0x1UL << I2CCTL_ALL_SLVADDR10B_Pos)

typedef enum
{
    I2CCTL_BIT_SLVADDR10B_7BIT_ADDR      = 0,  /*!< 7-bit addressing    */
    I2CCTL_BIT_SLVADDR10B_10BIT_ADDR     = 1,  /*!< 10-bit addressing   */
} I2CCTL_BIT_SLVADDR10B;

#define I2CCTL_ALL_SLVADDR10B_7BIT_ADDR      ((0x0UL) << I2CCTL_ALL_SLVADDR10B_Pos)
#define I2CCTL_ALL_SLVADDR10B_10BIT_ADDR     ((0x1UL) << I2CCTL_ALL_SLVADDR10B_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CCTL          ADDRSTS
 *  @access     I2C->I2CCTL.bit.ADDRSTS
 *  @brief      The function of this bit is handled by bit 12 of I2CMASTERADDR register, and becomes a read-only copy.
 */
#define I2CCTL_ALL_ADDRSTS_Pos (4)
#define I2CCTL_ALL_ADDRSTS_Msk (0x1UL << I2CCTL_ALL_ADDRSTS_Pos)

typedef enum
{
    I2CCTL_BIT_ADDRSTS_7BIT_ADDR      = 0,  /*!< 7-bit addressing    */
    I2CCTL_BIT_ADDRSTS_10BIT_ADDR     = 1,  /*!< 10-bit addressing   */
} I2CCTL_BIT_ADDRSTS;

#define I2CCTL_ALL_ADDRSTS_7BIT_ADDR      ((0x0UL) << I2CCTL_ALL_ADDRSTS_Pos)
#define I2CCTL_ALL_ADDRSTS_10BIT_ADDR     ((0x1UL) << I2CCTL_ALL_ADDRSTS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CCTL          RESTARTEN
 *  @access     I2C->I2CCTL.bit.RESTARTEN
 *  @brief      Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several I2C operations.
 *              When RESTART is disabled, the master is prohibited from performing the following functions:
 *              - Change direction within a transfer (split)
 *              - Send a START BYTE
 *              - High-speed mode operation
 *              - Combined format transfers in 7-bit addressing modes
 *              - Read operation with a 10-bit address
 *              - Send multiple bytes per transfer By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are broken down into multiple I2C transfers. If the above operations are performed, it will result in setting bit 6 (TXABRT) of the I2CRAWIF register.
 */
#define I2CCTL_ALL_RESTARTEN_Pos (5)
#define I2CCTL_ALL_RESTARTEN_Msk (0x1UL << I2CCTL_ALL_RESTARTEN_Pos)

typedef enum
{
    I2CCTL_BIT_RESTARTEN_DISABLE     = 0,  /*!< Disable   */
    I2CCTL_BIT_RESTARTEN_ENABLE      = 1,  /*!< Enable    */
} I2CCTL_BIT_RESTARTEN;

#define I2CCTL_ALL_RESTARTEN_DISABLE     ((0x0UL) << I2CCTL_ALL_RESTARTEN_Pos)
#define I2CCTL_ALL_RESTARTEN_ENABLE      ((0x1UL) << I2CCTL_ALL_RESTARTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CCTL          SLVDIS
 *  @access     I2C->I2CCTL.bit.SLVDIS
 *  @brief      This bit controls whether I2C has its slave disabled, which means once the presetn signal is applied, then this bit takes on the value of the configuration parameter SLAVE_DISABLE. You have the choice of having the slave enabled or disabled after reset is applied, which means software does not have to configure the slave. By default, the slave is always enabled (in reset state as well). If you need to disable it after reset, set this bit to 1. If this bit is set (slave is disabled), I2C functions only as a master and does not perform any action that requires a slave.
 *              NOTE: Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0.
 */
#define I2CCTL_ALL_SLVDIS_Pos (6)
#define I2CCTL_ALL_SLVDIS_Msk (0x1UL << I2CCTL_ALL_SLVDIS_Pos)

typedef enum
{
    I2CCTL_BIT_SLVDIS_SLAVE_ENABLE      = 0,  /*!< Slave is enabled    */
    I2CCTL_BIT_SLVDIS_SLAVE_DISABLE     = 1,  /*!< Slave is disabled   */
} I2CCTL_BIT_SLVDIS;

#define I2CCTL_ALL_SLVDIS_SLAVE_ENABLE      ((0x0UL) << I2CCTL_ALL_SLVDIS_Pos)
#define I2CCTL_ALL_SLVDIS_SLAVE_DISABLE     ((0x1UL) << I2CCTL_ALL_SLVDIS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CMASTERADDR   TARADDR
 *  @access     I2C->I2CMASTERADDR.bit.TARADDR
 *  @brief      This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
 *              If the I2CMASTERADDR and I2CSLVADDR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave.
 */
#define I2CMASTERADDR_ALL_TARADDR_Pos (0)
#define I2CMASTERADDR_ALL_TARADDR_Msk (0x3FFUL << I2CMASTERADDR_ALL_TARADDR_Pos)

#define I2CMASTERADDR_BIT_TARADDR

#define I2CMASTERADDR_ALL_TARADDR_(x) ((x) << I2CMASTERADDR_ALL_TARADDR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CMASTERADDR   GCORSTART
 *  @access     I2C->I2CMASTERADDR.bit.GCORSTART
 *  @brief      If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the I2C.
 */
#define I2CMASTERADDR_ALL_GCORSTART_Pos (10)
#define I2CMASTERADDR_ALL_GCORSTART_Msk (0x1UL << I2CMASTERADDR_ALL_GCORSTART_Pos)

typedef enum
{
    I2CMASTERADDR_BIT_GCORSTART_GENERAL_CALL     = 0,  /*!< General Call Address after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TXABRT) of the I2CRAWIF register. The I2C remains in General Call mode until the SPECIAL bit value (bit 11) is cleared   */
    I2CMASTERADDR_BIT_GCORSTART_START            = 1,  /*!< START BYTE                                                                                                                                                                                                                                                             */
} I2CMASTERADDR_BIT_GCORSTART;

#define I2CMASTERADDR_ALL_GCORSTART_GENERAL_CALL     ((0x0UL) << I2CMASTERADDR_ALL_GCORSTART_Pos)
#define I2CMASTERADDR_ALL_GCORSTART_START            ((0x1UL) << I2CMASTERADDR_ALL_GCORSTART_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CMASTERADDR   SPECIAL
 *  @access     I2C->I2CMASTERADDR.bit.SPECIAL
 *  @brief      This bit indicates whether software performs a General Call or START BYTE command.
 */
#define I2CMASTERADDR_ALL_SPECIAL_Pos (11)
#define I2CMASTERADDR_ALL_SPECIAL_Msk (0x1UL << I2CMASTERADDR_ALL_SPECIAL_Pos)

typedef enum
{
    I2CMASTERADDR_BIT_SPECIAL_DISABLE     = 0,  /*!< Ignore bit 10 GCORSTART and use I2CMASTERADDR normally      */
    I2CMASTERADDR_BIT_SPECIAL_ENABLE      = 1,  /*!< Perform special I2C command as specified in GCORSTART bit   */
} I2CMASTERADDR_BIT_SPECIAL;

#define I2CMASTERADDR_ALL_SPECIAL_DISABLE     ((0x0UL) << I2CMASTERADDR_ALL_SPECIAL_Pos)
#define I2CMASTERADDR_ALL_SPECIAL_ENABLE      ((0x1UL) << I2CMASTERADDR_ALL_SPECIAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CMASTERADDR   MASTERADDR10B
 *  @access     I2C->I2CMASTERADDR.bit.MASTERADDR10B
 *  @brief      This bit controls whether the I2C starts its transfers in 7- or 10-bit addressing mode when acting as a master.
 */
#define I2CMASTERADDR_ALL_MASTERADDR10B_Pos (12)
#define I2CMASTERADDR_ALL_MASTERADDR10B_Msk (0x1UL << I2CMASTERADDR_ALL_MASTERADDR10B_Pos)

typedef enum
{
    I2CMASTERADDR_BIT_MASTERADDR10B_7BIT_ADDR      = 0,  /*!< 7-bit addressing    */
    I2CMASTERADDR_BIT_MASTERADDR10B_10BIT_ADDR     = 1,  /*!< 10-bit addressing   */
} I2CMASTERADDR_BIT_MASTERADDR10B;

#define I2CMASTERADDR_ALL_MASTERADDR10B_7BIT_ADDR      ((0x0UL) << I2CMASTERADDR_ALL_MASTERADDR10B_Pos)
#define I2CMASTERADDR_ALL_MASTERADDR10B_10BIT_ADDR     ((0x1UL) << I2CMASTERADDR_ALL_MASTERADDR10B_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSLVADDR      VAL
 *  @access     I2C->I2CSLVADDR.bit.VAL
 *  @brief      The VAL holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only VAL[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the I2CENABLE register being set to 0. Writes at other times have no effect.
 *              Note: The default values cannot be any of the reserved address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct operation of the device is not guaranteed if you program the I2CSLVADDR or I2CMASTERADDR to a reserved value.
 */
#define I2CSLVADDR_ALL_VAL_Pos (0)
#define I2CSLVADDR_ALL_VAL_Msk (0x3FFUL << I2CSLVADDR_ALL_VAL_Pos)

#define I2CSLVADDR_BIT_VAL

#define I2CSLVADDR_ALL_VAL_(x) ((x) << I2CSLVADDR_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CHSMADDR      VAL
 *  @access     I2C->I2CHSMADDR.bit.VAL
 *  @brief      This bit field holds the value of the I2C HS mode master code. HS-mode master codes are reserved 8-bit codes (00001xxx) that are not used for slave addressing or other purposes. Each master has its unique master code; up to eight high-speed mode masters can be present on the same I2C bus system. Valid values are from 0 to 7. This register can be written only when the I2C interface is disabled, which corresponds to the I2CENABLE register being set to 0. Writes at other times have no effect.
 */
#define I2CHSMADDR_ALL_VAL_Pos (0)
#define I2CHSMADDR_ALL_VAL_Msk (0x7UL << I2CHSMADDR_ALL_VAL_Pos)

#define I2CHSMADDR_BIT_VAL

#define I2CHSMADDR_ALL_VAL_(x) ((x) << I2CHSMADDR_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CDATACMD      DATA
 *  @access     I2C->I2CDATACMD.bit.DATA
 *  @brief      This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DATA) are ignored by the I2C. However, when you read this register, these bits return the value of data received on the I2C interface.
 */
#define I2CDATACMD_ALL_DATA_Pos (0)
#define I2CDATACMD_ALL_DATA_Msk (0xFFUL << I2CDATACMD_ALL_DATA_Pos)

#define I2CDATACMD_BIT_DATA

#define I2CDATACMD_ALL_DATA_(x) ((x) << I2CDATACMD_ALL_DATA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CDATACMD      CMD
 *  @access     I2C->I2CDATACMD.bit.CMD
 *  @brief      This bit controls whether a read or a write is performed.
 *              This bit does not control the direction when the I2C acts as a slave. It controls only the direction when it acts as a master.
 *              When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slavereceiver mode, this bit is a 'don't care' because writes to this register are not required. In slave-transmitter mode, a '0' indicates that CPU data is to be transmitted and as DATA or I2CDATACMD[7:0]. When programming this bit, you should remember the following: attempting to perform a  read operation after a General Call command has been sent results in a TXABRT interrupt (bit 6 of the I2CRAWIF register), unless bit 11 (SPECIAL) in the I2CMASTERADDR register has been cleared. If a '1' is written to this bit after receiving a RDREQ interrupt, then a TXABRT interrupt occurs.
 *              NOTE: It is possible that while attempting a master I2C read transfer on I2C, a RDREQ interrupt may have occurred simultaneously due to a remote I2C master addressing I2C. In this type of scenario, I2C ignores the I2CDATACMD write, generates a TXABRT interrupt, and waits to service the RDREQ interrupt.
 */
#define I2CDATACMD_ALL_CMD_Pos (8)
#define I2CDATACMD_ALL_CMD_Msk (0x1UL << I2CDATACMD_ALL_CMD_Pos)

typedef enum
{
    I2CDATACMD_BIT_CMD_WRITE     = 0,  /*!< Write   */
    I2CDATACMD_BIT_CMD_READ      = 1,  /*!< Read    */
} I2CDATACMD_BIT_CMD;

#define I2CDATACMD_ALL_CMD_WRITE     ((0x0UL) << I2CDATACMD_ALL_CMD_Pos)
#define I2CDATACMD_ALL_CMD_READ      ((0x1UL) << I2CDATACMD_ALL_CMD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSSHCNT       VAL
 *  @access     I2C->I2CSSHCNT.bit.VAL
 *  @brief      This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. These values apply only if the ic_clk is set to the given frequency in the table. This register can be written only when the I2C interface is disabled which corresponds to the I2CENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of the I2C. The lower byte must be programmed first. Then the upper byte is programmed.
 */
#define I2CSSHCNT_ALL_VAL_Pos (0)
#define I2CSSHCNT_ALL_VAL_Msk (0xFFFFUL << I2CSSHCNT_ALL_VAL_Pos)

#define I2CSSHCNT_BIT_VAL

#define I2CSSHCNT_ALL_VAL_(x) ((x) << I2CSSHCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSSLCNT       VAL
 *  @access     I2C->I2CSSLCNT.bit.VAL
 *  @brief      This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed. The table below shows some sample I2CSSLCNT calculations. These values apply only if the ic_clk is set to the given frequency in the table. This register can be written only when the I2C interface is disabled which corresponds to the I2CENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. For designs with APB_DATA_WIDTH = 8, the order of programming is important to ensure the correct operation of I2C. The lower byte must be programmed first, and then the upper byte is programmed.
 */
#define I2CSSLCNT_ALL_VAL_Pos (0)
#define I2CSSLCNT_ALL_VAL_Msk (0xFFFFUL << I2CSSLCNT_ALL_VAL_Pos)

#define I2CSSLCNT_BIT_VAL

#define I2CSSLCNT_ALL_VAL_(x) ((x) << I2CSSLCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CFSHCNT       VAL
 *  @access     I2C->I2CFSHCNT.bit.VAL
 *  @brief      This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2CENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the I2C. The lower byte must be programmed first. Then the upper byte is programmed.
 */
#define I2CFSHCNT_ALL_VAL_Pos (0)
#define I2CFSHCNT_ALL_VAL_Msk (0xFFFFUL << I2CFSHCNT_ALL_VAL_Pos)

#define I2CFSHCNT_BIT_VAL

#define I2CFSHCNT_ALL_VAL_(x) ((x) << I2CFSHCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CFSLCNT       VAL
 *  @access     I2C->I2CFSLCNT.bit.VAL
 *  @brief      This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to theI2CENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the I2C. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.
 */
#define I2CFSLCNT_ALL_VAL_Pos (0)
#define I2CFSLCNT_ALL_VAL_Msk (0xFFFFUL << I2CFSLCNT_ALL_VAL_Pos)

#define I2CFSLCNT_BIT_VAL

#define I2CFSLCNT_ALL_VAL_(x) ((x) << I2CFSLCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CHSHCNT       VAL
 *  @access     I2C->I2CHSHCNT.bit.VAL
 *  @brief      This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for high speed. The SCL High time depends on the loading of the bus. For 100pF loading, the SCL High time is 60ns; for 400pF loading, the SCL High time is 120ns. This register can be written only when the I2C interface is disabled, which corresponds to the I2CENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the I2C. The lower byte must be programmed first. Then the upper byte is programmed.
 */
#define I2CHSHCNT_ALL_VAL_Pos (0)
#define I2CHSHCNT_ALL_VAL_Msk (0xFFFFUL << I2CHSHCNT_ALL_VAL_Pos)

#define I2CHSHCNT_BIT_VAL

#define I2CHSHCNT_ALL_VAL_(x) ((x) << I2CHSHCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CHSLCNT       VAL
 *  @access     I2C->I2CHSLCNT.bit.VAL
 *  @brief      This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for high speed. The SCL low time depends on the loading of the bus. For 100pF loading, the SCL low time is 160ns; for 400pF loading, the SCL low time is 320ns. This register can be written only when the I2C interface is disabled, which corresponds to the I2CENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the I2C. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8.
 */
#define I2CHSLCNT_ALL_VAL_Pos (0)
#define I2CHSLCNT_ALL_VAL_Msk (0xFFFFUL << I2CHSLCNT_ALL_VAL_Pos)

#define I2CHSLCNT_BIT_VAL

#define I2CHSLCNT_ALL_VAL_(x) ((x) << I2CHSLCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           RXUDF
 *  @access     I2C->I2CIF.bit.RXUDF
 *  @brief      Set if the processor attempts to read the receive buffer when it is empty by reading from the I2CDATACMD register. If the module is disabled (I2CENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
 */
#define I2CIF_ALL_RXUDF_Pos (0)
#define I2CIF_ALL_RXUDF_Msk (0x1UL << I2CIF_ALL_RXUDF_Pos)

typedef enum
{
    I2CIF_BIT_RXUDF_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_RXUDF_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_RXUDF;

#define I2CIF_ALL_RXUDF_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_RXUDF_Pos)
#define I2CIF_ALL_RXUDF_OCCUR         ((0x1UL) << I2CIF_ALL_RXUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           RXOVF
 *  @access     I2C->I2CIF.bit.RXOVF
 *  @brief      Set if the receive buffer is completely filled to RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The I2C acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2CENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
 */
#define I2CIF_ALL_RXOVF_Pos (1)
#define I2CIF_ALL_RXOVF_Msk (0x1UL << I2CIF_ALL_RXOVF_Pos)

typedef enum
{
    I2CIF_BIT_RXOVF_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_RXOVF_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_RXOVF;

#define I2CIF_ALL_RXOVF_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_RXOVF_Pos)
#define I2CIF_ALL_RXOVF_OCCUR         ((0x1UL) << I2CIF_ALL_RXOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           RXFULL
 *  @access     I2C->I2CIF.bit.RXFULL
 *  @brief      Set when the receive buffer reaches or goes above the threshold in the I2CRXTH register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2CENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2CENABLE bit 0 is programmed with a 0, regardless of the activity that continues.
 */
#define I2CIF_ALL_RXFULL_Pos (2)
#define I2CIF_ALL_RXFULL_Msk (0x1UL << I2CIF_ALL_RXFULL_Pos)

typedef enum
{
    I2CIF_BIT_RXFULL_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_RXFULL_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_RXFULL;

#define I2CIF_ALL_RXFULL_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_RXFULL_Pos)
#define I2CIF_ALL_RXFULL_OCCUR         ((0x1UL) << I2CIF_ALL_RXFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           TXOVF
 *  @access     I2C->I2CIF.bit.TXOVF
 *  @brief      Set during transmit if the transmit buffer is filled to TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the I2CDATACMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
 */
#define I2CIF_ALL_TXOVF_Pos (3)
#define I2CIF_ALL_TXOVF_Msk (0x1UL << I2CIF_ALL_TXOVF_Pos)

typedef enum
{
    I2CIF_BIT_TXOVF_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_TXOVF_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_TXOVF;

#define I2CIF_ALL_TXOVF_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_TXOVF_Pos)
#define I2CIF_ALL_TXOVF_OCCUR         ((0x1UL) << I2CIF_ALL_TXOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           TXEMPTY
 *  @access     I2C->I2CIF.bit.TXEMPTY
 *  @brief      This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2CTXTH register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the I2CENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0.
 */
#define I2CIF_ALL_TXEMPTY_Pos (4)
#define I2CIF_ALL_TXEMPTY_Msk (0x1UL << I2CIF_ALL_TXEMPTY_Pos)

typedef enum
{
    I2CIF_BIT_TXEMPTY_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_TXEMPTY_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_TXEMPTY;

#define I2CIF_ALL_TXEMPTY_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_TXEMPTY_Pos)
#define I2CIF_ALL_TXEMPTY_OCCUR         ((0x1UL) << I2CIF_ALL_TXEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           RDREQ
 *  @access     I2C->I2CIF.bit.RDREQ
 *  @brief      This bit is set to 1 when I2C is acting as a slave and another I2C master is attempting to read data from I2C. The I2C holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2CDATACMD register. This bit is set to 0 just after the processor reads the I2CRDREQCLR register.
 */
#define I2CIF_ALL_RDREQ_Pos (5)
#define I2CIF_ALL_RDREQ_Msk (0x1UL << I2CIF_ALL_RDREQ_Pos)

typedef enum
{
    I2CIF_BIT_RDREQ_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_RDREQ_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_RDREQ;

#define I2CIF_ALL_RDREQ_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_RDREQ_Pos)
#define I2CIF_ALL_RDREQ_OCCUR         ((0x1UL) << I2CIF_ALL_RDREQ_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           TXABRT
 *  @access     I2C->I2CIF.bit.TXABRT
 *  @brief      This bit indicates if I2C, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the I2CTXABRTSRC register indicates the reason why the transmit abort takes places.
 *              NOTE: The I2C flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2CTXABRTCLR is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface.
 */
#define I2CIF_ALL_TXABRT_Pos (6)
#define I2CIF_ALL_TXABRT_Msk (0x1UL << I2CIF_ALL_TXABRT_Pos)

typedef enum
{
    I2CIF_BIT_TXABRT_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_TXABRT_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_TXABRT;

#define I2CIF_ALL_TXABRT_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_TXABRT_Pos)
#define I2CIF_ALL_TXABRT_OCCUR         ((0x1UL) << I2CIF_ALL_TXABRT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           RXDONE
 *  @access     I2C->I2CIF.bit.RXDONE
 *  @brief      When the I2C is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.
 */
#define I2CIF_ALL_RXDONE_Pos (7)
#define I2CIF_ALL_RXDONE_Msk (0x1UL << I2CIF_ALL_RXDONE_Pos)

typedef enum
{
    I2CIF_BIT_RXDONE_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_RXDONE_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_RXDONE;

#define I2CIF_ALL_RXDONE_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_RXDONE_Pos)
#define I2CIF_ALL_RXDONE_OCCUR         ((0x1UL) << I2CIF_ALL_RXDONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           ACT
 *  @access     I2C->I2CIF.bit.ACT
 *  @brief      This bit captures I2C activity and stays set until it is cleared.
 *              There are four ways to clear it:
 *              - Disabling the I2C
 *              - Reading the I2CACTCLR register
 *              - Reading the I2CINTCLR register
 *              - System reset
 *              Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the I2C module is idle, this bit remains set until cleared, indicating that there was activity on the bus.
 */
#define I2CIF_ALL_ACT_Pos (8)
#define I2CIF_ALL_ACT_Msk (0x1UL << I2CIF_ALL_ACT_Pos)

typedef enum
{
    I2CIF_BIT_ACT_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_ACT_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_ACT;

#define I2CIF_ALL_ACT_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_ACT_Pos)
#define I2CIF_ALL_ACT_OCCUR         ((0x1UL) << I2CIF_ALL_ACT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           STOPDET
 *  @access     I2C->I2CIF.bit.STOPDET
 *  @brief      Indicates whether a STOP condition has occurred on the I2C interface regardless of whether I2C is operating in slave or master mode.
 */
#define I2CIF_ALL_STOPDET_Pos (9)
#define I2CIF_ALL_STOPDET_Msk (0x1UL << I2CIF_ALL_STOPDET_Pos)

typedef enum
{
    I2CIF_BIT_STOPDET_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_STOPDET_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_STOPDET;

#define I2CIF_ALL_STOPDET_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_STOPDET_Pos)
#define I2CIF_ALL_STOPDET_OCCUR         ((0x1UL) << I2CIF_ALL_STOPDET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           STARTDET
 *  @access     I2C->I2CIF.bit.STARTDET
 *  @brief      Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether I2C is operating in slave or master mode.
 */
#define I2CIF_ALL_STARTDET_Pos (10)
#define I2CIF_ALL_STARTDET_Msk (0x1UL << I2CIF_ALL_STARTDET_Pos)

typedef enum
{
    I2CIF_BIT_STARTDET_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_STARTDET_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_STARTDET;

#define I2CIF_ALL_STARTDET_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_STARTDET_Pos)
#define I2CIF_ALL_STARTDET_OCCUR         ((0x1UL) << I2CIF_ALL_STARTDET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIF           GENCALL
 *  @access     I2C->I2CIF.bit.GENCALL
 *  @brief      Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling I2C or when the CPU reads bit 0 of the I2CGENCALLCLR register. I2C stores the received data in the Rx buffer.
 */
#define I2CIF_ALL_GENCALL_Pos (11)
#define I2CIF_ALL_GENCALL_Msk (0x1UL << I2CIF_ALL_GENCALL_Pos)

typedef enum
{
    I2CIF_BIT_GENCALL_NOT_OCCUR     = 0,  /*!<    */
    I2CIF_BIT_GENCALL_OCCUR         = 1,  /*!<    */
} I2CIF_BIT_GENCALL;

#define I2CIF_ALL_GENCALL_NOT_OCCUR     ((0x0UL) << I2CIF_ALL_GENCALL_Pos)
#define I2CIF_ALL_GENCALL_OCCUR         ((0x1UL) << I2CIF_ALL_GENCALL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           RXUDF
 *  @access     I2C->I2CIE.bit.RXUDF
 *  @brief      Enable/disable RXUDF interrupt
 */
#define I2CIE_ALL_RXUDF_Pos (0)
#define I2CIE_ALL_RXUDF_Msk (0x1UL << I2CIE_ALL_RXUDF_Pos)

typedef enum
{
    I2CIE_BIT_RXUDF_DISABLE     = 0,  /*!< Disable RXUDF interrupt   */
    I2CIE_BIT_RXUDF_ENABLE      = 1,  /*!< Enable RXUDF interrupt    */
} I2CIE_BIT_RXUDF;

#define I2CIE_ALL_RXUDF_DISABLE     ((0x0UL) << I2CIE_ALL_RXUDF_Pos)
#define I2CIE_ALL_RXUDF_ENABLE      ((0x1UL) << I2CIE_ALL_RXUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           RXOVF
 *  @access     I2C->I2CIE.bit.RXOVF
 *  @brief      Enable/disable RXOVF interrupt
 */
#define I2CIE_ALL_RXOVF_Pos (1)
#define I2CIE_ALL_RXOVF_Msk (0x1UL << I2CIE_ALL_RXOVF_Pos)

typedef enum
{
    I2CIE_BIT_RXOVF_DISABLE     = 0,  /*!< Disable RXOVF interrupt   */
    I2CIE_BIT_RXOVF_ENABLE      = 1,  /*!< Enable RXOVF interrupt    */
} I2CIE_BIT_RXOVF;

#define I2CIE_ALL_RXOVF_DISABLE     ((0x0UL) << I2CIE_ALL_RXOVF_Pos)
#define I2CIE_ALL_RXOVF_ENABLE      ((0x1UL) << I2CIE_ALL_RXOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           RXFULL
 *  @access     I2C->I2CIE.bit.RXFULL
 *  @brief      Enable/disable RXFULL interrupt
 */
#define I2CIE_ALL_RXFULL_Pos (2)
#define I2CIE_ALL_RXFULL_Msk (0x1UL << I2CIE_ALL_RXFULL_Pos)

typedef enum
{
    I2CIE_BIT_RXFULL_DISABLE     = 0,  /*!< Disable RXFULL interrupt   */
    I2CIE_BIT_RXFULL_ENABLE      = 1,  /*!< Enable RXFULL interrupt    */
} I2CIE_BIT_RXFULL;

#define I2CIE_ALL_RXFULL_DISABLE     ((0x0UL) << I2CIE_ALL_RXFULL_Pos)
#define I2CIE_ALL_RXFULL_ENABLE      ((0x1UL) << I2CIE_ALL_RXFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           TXOVF
 *  @access     I2C->I2CIE.bit.TXOVF
 *  @brief      Enable/disable TXOVF interrupt
 */
#define I2CIE_ALL_TXOVF_Pos (3)
#define I2CIE_ALL_TXOVF_Msk (0x1UL << I2CIE_ALL_TXOVF_Pos)

typedef enum
{
    I2CIE_BIT_TXOVF_DISABLE     = 0,  /*!< Disable TXOVF interrupt   */
    I2CIE_BIT_TXOVF_ENABLE      = 1,  /*!< Enable TXOVF interrupt    */
} I2CIE_BIT_TXOVF;

#define I2CIE_ALL_TXOVF_DISABLE     ((0x0UL) << I2CIE_ALL_TXOVF_Pos)
#define I2CIE_ALL_TXOVF_ENABLE      ((0x1UL) << I2CIE_ALL_TXOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           TXEMPTY
 *  @access     I2C->I2CIE.bit.TXEMPTY
 *  @brief      Enable/disable TXEMPTY interrupt
 */
#define I2CIE_ALL_TXEMPTY_Pos (4)
#define I2CIE_ALL_TXEMPTY_Msk (0x1UL << I2CIE_ALL_TXEMPTY_Pos)

typedef enum
{
    I2CIE_BIT_TXEMPTY_DISABLE     = 0,  /*!< Disable TXEMPTY interrupt   */
    I2CIE_BIT_TXEMPTY_ENABLE      = 1,  /*!< Enable TXEMPTY interrupt    */
} I2CIE_BIT_TXEMPTY;

#define I2CIE_ALL_TXEMPTY_DISABLE     ((0x0UL) << I2CIE_ALL_TXEMPTY_Pos)
#define I2CIE_ALL_TXEMPTY_ENABLE      ((0x1UL) << I2CIE_ALL_TXEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           RDREQ
 *  @access     I2C->I2CIE.bit.RDREQ
 *  @brief      Enable/disable RDREQ interrupt
 */
#define I2CIE_ALL_RDREQ_Pos (5)
#define I2CIE_ALL_RDREQ_Msk (0x1UL << I2CIE_ALL_RDREQ_Pos)

typedef enum
{
    I2CIE_BIT_RDREQ_DISABLE     = 0,  /*!< Disable RDREQ interrupt   */
    I2CIE_BIT_RDREQ_ENABLE      = 1,  /*!< Enable RDREQ interrupt    */
} I2CIE_BIT_RDREQ;

#define I2CIE_ALL_RDREQ_DISABLE     ((0x0UL) << I2CIE_ALL_RDREQ_Pos)
#define I2CIE_ALL_RDREQ_ENABLE      ((0x1UL) << I2CIE_ALL_RDREQ_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           TXABRT
 *  @access     I2C->I2CIE.bit.TXABRT
 *  @brief      Enable/disable TXABRT interrupt
 */
#define I2CIE_ALL_TXABRT_Pos (6)
#define I2CIE_ALL_TXABRT_Msk (0x1UL << I2CIE_ALL_TXABRT_Pos)

typedef enum
{
    I2CIE_BIT_TXABRT_DISABLE     = 0,  /*!< Disable TXABRT interrupt   */
    I2CIE_BIT_TXABRT_ENABLE      = 1,  /*!< Enable TXABRT interrupt    */
} I2CIE_BIT_TXABRT;

#define I2CIE_ALL_TXABRT_DISABLE     ((0x0UL) << I2CIE_ALL_TXABRT_Pos)
#define I2CIE_ALL_TXABRT_ENABLE      ((0x1UL) << I2CIE_ALL_TXABRT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           RXDONE
 *  @access     I2C->I2CIE.bit.RXDONE
 *  @brief      Enable/disable RXDONE interrupt
 */
#define I2CIE_ALL_RXDONE_Pos (7)
#define I2CIE_ALL_RXDONE_Msk (0x1UL << I2CIE_ALL_RXDONE_Pos)

typedef enum
{
    I2CIE_BIT_RXDONE_DISABLE     = 0,  /*!< Disable RXDONE interrupt   */
    I2CIE_BIT_RXDONE_ENABLE      = 1,  /*!< Enable RXDONE interrupt    */
} I2CIE_BIT_RXDONE;

#define I2CIE_ALL_RXDONE_DISABLE     ((0x0UL) << I2CIE_ALL_RXDONE_Pos)
#define I2CIE_ALL_RXDONE_ENABLE      ((0x1UL) << I2CIE_ALL_RXDONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           ACT
 *  @access     I2C->I2CIE.bit.ACT
 *  @brief      Enable/disable ACTIVITY interrupt
 */
#define I2CIE_ALL_ACT_Pos (8)
#define I2CIE_ALL_ACT_Msk (0x1UL << I2CIE_ALL_ACT_Pos)

typedef enum
{
    I2CIE_BIT_ACT_DISABLE     = 0,  /*!< Disable ACTIVITY interrupt   */
    I2CIE_BIT_ACT_ENABLE      = 1,  /*!< Enable ACTIVITY interrupt    */
} I2CIE_BIT_ACT;

#define I2CIE_ALL_ACT_DISABLE     ((0x0UL) << I2CIE_ALL_ACT_Pos)
#define I2CIE_ALL_ACT_ENABLE      ((0x1UL) << I2CIE_ALL_ACT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           STOPDET
 *  @access     I2C->I2CIE.bit.STOPDET
 *  @brief      Enable/disable STOPDET interrupt
 */
#define I2CIE_ALL_STOPDET_Pos (9)
#define I2CIE_ALL_STOPDET_Msk (0x1UL << I2CIE_ALL_STOPDET_Pos)

typedef enum
{
    I2CIE_BIT_STOPDET_DISABLE     = 0,  /*!< Disable STOPDET interrupt   */
    I2CIE_BIT_STOPDET_ENABLE      = 1,  /*!< Enable STOPDET interrupt    */
} I2CIE_BIT_STOPDET;

#define I2CIE_ALL_STOPDET_DISABLE     ((0x0UL) << I2CIE_ALL_STOPDET_Pos)
#define I2CIE_ALL_STOPDET_ENABLE      ((0x1UL) << I2CIE_ALL_STOPDET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           STARTDET
 *  @access     I2C->I2CIE.bit.STARTDET
 *  @brief      Enable/disable STARTDET interrupt
 */
#define I2CIE_ALL_STARTDET_Pos (10)
#define I2CIE_ALL_STARTDET_Msk (0x1UL << I2CIE_ALL_STARTDET_Pos)

typedef enum
{
    I2CIE_BIT_STARTDET_DISABLE     = 0,  /*!< Disable STARTDET interrupt   */
    I2CIE_BIT_STARTDET_ENABLE      = 1,  /*!< Enable STARTDET interrupt    */
} I2CIE_BIT_STARTDET;

#define I2CIE_ALL_STARTDET_DISABLE     ((0x0UL) << I2CIE_ALL_STARTDET_Pos)
#define I2CIE_ALL_STARTDET_ENABLE      ((0x1UL) << I2CIE_ALL_STARTDET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CIE           GENCALL
 *  @access     I2C->I2CIE.bit.GENCALL
 *  @brief      Enable/disable GENCALL interrupt
 */
#define I2CIE_ALL_GENCALL_Pos (11)
#define I2CIE_ALL_GENCALL_Msk (0x1UL << I2CIE_ALL_GENCALL_Pos)

typedef enum
{
    I2CIE_BIT_GENCALL_DISABLE     = 0,  /*!< Disable GENCALL interrupt   */
    I2CIE_BIT_GENCALL_ENABLE      = 1,  /*!< Enable GENCALL interrupt    */
} I2CIE_BIT_GENCALL;

#define I2CIE_ALL_GENCALL_DISABLE     ((0x0UL) << I2CIE_ALL_GENCALL_Pos)
#define I2CIE_ALL_GENCALL_ENABLE      ((0x1UL) << I2CIE_ALL_GENCALL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        RXUDF
 *  @access     I2C->I2CRAWIF.bit.RXUDF
 *  @brief      Set if the processor attempts to read the receive buffer when it is empty by reading from the I2CDATACMD register. If the module is disabled (I2CENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
 */
#define I2CRAWIF_ALL_RXUDF_Pos (0)
#define I2CRAWIF_ALL_RXUDF_Msk (0x1UL << I2CRAWIF_ALL_RXUDF_Pos)

typedef enum
{
    I2CRAWIF_BIT_RXUDF_NOT_OCCUR     = 0,  /*!<    */
    I2CRAWIF_BIT_RXUDF_OCCUR         = 1,  /*!<    */
} I2CRAWIF_BIT_RXUDF;

#define I2CRAWIF_ALL_RXUDF_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_RXUDF_Pos)
#define I2CRAWIF_ALL_RXUDF_OCCUR         ((0x1UL) << I2CRAWIF_ALL_RXUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        RXOVF
 *  @access     I2C->I2CRAWIF.bit.RXOVF
 *  @brief      Set if the receive buffer is completely filled to RX_BUFFER_DEPTH and an additional byte is received from an external I2C device. The I2C acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2CENABLE[0]=0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
 */
#define I2CRAWIF_ALL_RXOVF_Pos (1)
#define I2CRAWIF_ALL_RXOVF_Msk (0x1UL << I2CRAWIF_ALL_RXOVF_Pos)

typedef enum
{
    I2CRAWIF_BIT_RXOVF_NOT_OCCUR     = 0,  /*!<    */
    I2CRAWIF_BIT_RXOVF_OCCUR         = 1,  /*!<    */
} I2CRAWIF_BIT_RXOVF;

#define I2CRAWIF_ALL_RXOVF_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_RXOVF_Pos)
#define I2CRAWIF_ALL_RXOVF_OCCUR         ((0x1UL) << I2CRAWIF_ALL_RXOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        RXFULL
 *  @access     I2C->I2CRAWIF.bit.RXFULL
 *  @brief      Set when the receive buffer reaches or goes above the threshold value in the I2CRXTH register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2CENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2CENABLE bit 0 is programmed with a 0, regardless of the activity that continues.
 */
#define I2CRAWIF_ALL_RXFULL_Pos (2)
#define I2CRAWIF_ALL_RXFULL_Msk (0x1UL << I2CRAWIF_ALL_RXFULL_Pos)

typedef enum
{
    I2CRAWIF_BIT_RXFULL_NOT_OCCUR     = 0,  /*!<    */
} I2CRAWIF_BIT_RXFULL;

#define I2CRAWIF_ALL_RXFULL_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_RXFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        TXOVF
 *  @access     I2C->I2CRAWIF.bit.TXOVF
 *  @brief      Set during transmit if the transmit buffer is filled to TX_BUFFER_DEPTH and the processor attempts to issue another I2C command by writing to the I2CDATACMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared.
 */
#define I2CRAWIF_ALL_TXOVF_Pos (3)
#define I2CRAWIF_ALL_TXOVF_Msk (0x1UL << I2CRAWIF_ALL_TXOVF_Pos)

typedef enum
{
    I2CRAWIF_BIT_TXOVF_NOT_OCCUR     = 0,  /*!<    */
} I2CRAWIF_BIT_TXOVF;

#define I2CRAWIF_ALL_TXOVF_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_TXOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        TXEMPTY
 *  @access     I2C->I2CRAWIF.bit.TXEMPTY
 *  @brief      This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2CTXTH register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the I2CENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en=0, this bit is set to 0.
 */
#define I2CRAWIF_ALL_TXEMPTY_Pos (4)
#define I2CRAWIF_ALL_TXEMPTY_Msk (0x1UL << I2CRAWIF_ALL_TXEMPTY_Pos)

typedef enum
{
    I2CRAWIF_BIT_TXEMPTY_NOT_OCCUR     = 0,  /*!<    */
} I2CRAWIF_BIT_TXEMPTY;

#define I2CRAWIF_ALL_TXEMPTY_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_TXEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        RDREQ
 *  @access     I2C->I2CRAWIF.bit.RDREQ
 *  @brief      This bit is set to 1 when I2C is acting as a slave and another I2C master is attempting to read data from I2C. The I2C holds the I2C bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2CDATACMD register. This bit is set to 0 just after the processor reads the I2CRDREQCLR register.
 */
#define I2CRAWIF_ALL_RDREQ_Pos (5)
#define I2CRAWIF_ALL_RDREQ_Msk (0x1UL << I2CRAWIF_ALL_RDREQ_Pos)

typedef enum
{
    I2CRAWIF_BIT_RDREQ_OCCUR     = 1,  /*!<    */
} I2CRAWIF_BIT_RDREQ;

#define I2CRAWIF_ALL_RDREQ_OCCUR     ((0x1UL) << I2CRAWIF_ALL_RDREQ_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        TXABRT
 *  @access     I2C->I2CRAWIF.bit.TXABRT
 *  @brief      This bit indicates if I2C, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the I2CTXABRTSRC register indicates the reason why the transmit abort takes places.
 *              NOTE: The I2C flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2CTXABRTCLR is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface.
 */
#define I2CRAWIF_ALL_TXABRT_Pos (6)
#define I2CRAWIF_ALL_TXABRT_Msk (0x1UL << I2CRAWIF_ALL_TXABRT_Pos)

typedef enum
{
    I2CRAWIF_BIT_TXABRT_NOT_OCCUR     = 0,  /*!<    */
    I2CRAWIF_BIT_TXABRT_OCCUR         = 1,  /*!<    */
} I2CRAWIF_BIT_TXABRT;

#define I2CRAWIF_ALL_TXABRT_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_TXABRT_Pos)
#define I2CRAWIF_ALL_TXABRT_OCCUR         ((0x1UL) << I2CRAWIF_ALL_TXABRT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        RXDONE
 *  @access     I2C->I2CRAWIF.bit.RXDONE
 *  @brief      When the I2C is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done.
 */
#define I2CRAWIF_ALL_RXDONE_Pos (7)
#define I2CRAWIF_ALL_RXDONE_Msk (0x1UL << I2CRAWIF_ALL_RXDONE_Pos)

typedef enum
{
    I2CRAWIF_BIT_RXDONE_NOT_OCCUR     = 0,  /*!<    */
    I2CRAWIF_BIT_RXDONE_OCCUR         = 1,  /*!<    */
} I2CRAWIF_BIT_RXDONE;

#define I2CRAWIF_ALL_RXDONE_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_RXDONE_Pos)
#define I2CRAWIF_ALL_RXDONE_OCCUR         ((0x1UL) << I2CRAWIF_ALL_RXDONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        ACT
 *  @access     I2C->I2CRAWIF.bit.ACT
 *  @brief      This bit captures I2C activity and stays set until it is cleared.
 *              There are four ways to clear it:
 *              - Disabling the I2C
 *              - Reading the I2CACTCLR register
 *              - Reading the I2CINTCLR register
 *              - System reset
 *              Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the I2C module is idle, this bit remains set until cleared, indicating that there was activity on the bus.
 */
#define I2CRAWIF_ALL_ACT_Pos (8)
#define I2CRAWIF_ALL_ACT_Msk (0x1UL << I2CRAWIF_ALL_ACT_Pos)

typedef enum
{
    I2CRAWIF_BIT_ACT_NOT_OCCUR     = 0,  /*!<    */
    I2CRAWIF_BIT_ACT_OCCUR         = 1,  /*!<    */
} I2CRAWIF_BIT_ACT;

#define I2CRAWIF_ALL_ACT_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_ACT_Pos)
#define I2CRAWIF_ALL_ACT_OCCUR         ((0x1UL) << I2CRAWIF_ALL_ACT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        STOPDET
 *  @access     I2C->I2CRAWIF.bit.STOPDET
 *  @brief      Indicates whether a STOP condition has occurred on the I2C interface regardless of whether I2C is operating in slave or master mode.
 */
#define I2CRAWIF_ALL_STOPDET_Pos (9)
#define I2CRAWIF_ALL_STOPDET_Msk (0x1UL << I2CRAWIF_ALL_STOPDET_Pos)

typedef enum
{
    I2CRAWIF_BIT_STOPDET_NOT_OCCUR     = 0,  /*!<    */
    I2CRAWIF_BIT_STOPDET_OCCUR         = 1,  /*!<    */
} I2CRAWIF_BIT_STOPDET;

#define I2CRAWIF_ALL_STOPDET_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_STOPDET_Pos)
#define I2CRAWIF_ALL_STOPDET_OCCUR         ((0x1UL) << I2CRAWIF_ALL_STOPDET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        STARTDET
 *  @access     I2C->I2CRAWIF.bit.STARTDET
 *  @brief      Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether I2C is operating in slave or master mode.
 */
#define I2CRAWIF_ALL_STARTDET_Pos (10)
#define I2CRAWIF_ALL_STARTDET_Msk (0x1UL << I2CRAWIF_ALL_STARTDET_Pos)

typedef enum
{
    I2CRAWIF_BIT_STARTDET_NOT_OCCUR     = 0,  /*!<    */
    I2CRAWIF_BIT_STARTDET_OCCUR         = 1,  /*!<    */
} I2CRAWIF_BIT_STARTDET;

#define I2CRAWIF_ALL_STARTDET_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_STARTDET_Pos)
#define I2CRAWIF_ALL_STARTDET_OCCUR         ((0x1UL) << I2CRAWIF_ALL_STARTDET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRAWIF        GENCALL
 *  @access     I2C->I2CRAWIF.bit.GENCALL
 *  @brief      Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling I2C or when the CPU reads bit 0 of the I2CGENCALLCLR register. I2C stores the received data in the Rx buffer.
 */
#define I2CRAWIF_ALL_GENCALL_Pos (11)
#define I2CRAWIF_ALL_GENCALL_Msk (0x1UL << I2CRAWIF_ALL_GENCALL_Pos)

typedef enum
{
    I2CRAWIF_BIT_GENCALL_NOT_OCCUR     = 0,  /*!<    */
    I2CRAWIF_BIT_GENCALL_OCCUR         = 1,  /*!<    */
} I2CRAWIF_BIT_GENCALL;

#define I2CRAWIF_ALL_GENCALL_NOT_OCCUR     ((0x0UL) << I2CRAWIF_ALL_GENCALL_Pos)
#define I2CRAWIF_ALL_GENCALL_OCCUR         ((0x1UL) << I2CRAWIF_ALL_GENCALL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRXTH         VAL
 *  @access     I2C->I2CRXTH.bit.VAL
 *  @brief      Receive FIFO Threshold Level
 *              Controls the level of entries (or above) that triggers the RXFULL interrupt (bit 2 in I2CRAWIF register). The valid range is 0-255, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 255 sets the threshold for 256 entries.
 */
#define I2CRXTH_ALL_VAL_Pos (0)
#define I2CRXTH_ALL_VAL_Msk (0xFUL << I2CRXTH_ALL_VAL_Pos)

#define I2CRXTH_BIT_VAL

#define I2CRXTH_ALL_VAL_(x) ((x) << I2CRXTH_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRXTH         KEY
 *  @access     I2C->I2CRXTH.bit.KEY
 *  @brief      Must write 0x0 to this field when write to low LSBs, else LSBs is always 0xF.
 *              Always readback 0
 */
#define I2CRXTH_ALL_KEY_Pos (4)
#define I2CRXTH_ALL_KEY_Msk (0xFUL << I2CRXTH_ALL_KEY_Pos)

#define I2CRXTH_BIT_KEY

#define I2CRXTH_ALL_KEY_(x) ((x) << I2CRXTH_ALL_KEY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXTH         VAL
 *  @access     I2C->I2CTXTH.bit.VAL
 *  @brief      Transmit FIFO Threshold Level
 *              Controls the level of entries (or below) that trigger the TXEMPTY interrupt (bit 4 in I2CRAWIF register). The valid range is 0-255, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 255 sets the threshold for 255 entries.
 */
#define I2CTXTH_ALL_VAL_Pos (0)
#define I2CTXTH_ALL_VAL_Msk (0xFUL << I2CTXTH_ALL_VAL_Pos)

#define I2CTXTH_BIT_VAL

#define I2CTXTH_ALL_VAL_(x) ((x) << I2CTXTH_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXTH         KEY
 *  @access     I2C->I2CTXTH.bit.KEY
 *  @brief      Must write 0x0 to this field when write to low LSBs, else LSBs is always 0xF.
 *              Always readback 0
 */
#define I2CTXTH_ALL_KEY_Pos (4)
#define I2CTXTH_ALL_KEY_Msk (0xFUL << I2CTXTH_ALL_KEY_Pos)

#define I2CTXTH_BIT_KEY

#define I2CTXTH_ALL_KEY_(x) ((x) << I2CTXTH_ALL_KEY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CINTCLR       CLR
 *  @access     I2C->I2CINTCLR.bit.CLR
 *  @brief      Read this register to clear the combined interrupt, all individual interrupts, and the I2CTXABRTSRC register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2CTXABRTSRC register for an exception to clearing TX_ABRT_SOURCE.
 */
#define I2CINTCLR_ALL_CLR_Pos (0)
#define I2CINTCLR_ALL_CLR_Msk (0x1UL << I2CINTCLR_ALL_CLR_Pos)

typedef enum
{
    I2CINTCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CINTCLR_BIT_CLR;

#define I2CINTCLR_ALL_CLR_0     ((0x0UL) << I2CINTCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRXUDFCLR     CLR
 *  @access     I2C->I2CRXUDFCLR.bit.CLR
 *  @brief      Read this register to clear the RXUDF interrupt (bit 0) of the I2CRAWIF register
 *              Reset value: 0x0
 */
#define I2CRXUDFCLR_ALL_CLR_Pos (0)
#define I2CRXUDFCLR_ALL_CLR_Msk (0x1UL << I2CRXUDFCLR_ALL_CLR_Pos)

typedef enum
{
    I2CRXUDFCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CRXUDFCLR_BIT_CLR;

#define I2CRXUDFCLR_ALL_CLR_0     ((0x0UL) << I2CRXUDFCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRXOVFCLR     CLR
 *  @access     I2C->I2CRXOVFCLR.bit.CLR
 *  @brief      Read this register to clear the RXOVF interrupt (bit 1) of the I2CRAWIF register
 */
#define I2CRXOVFCLR_ALL_CLR_Pos (0)
#define I2CRXOVFCLR_ALL_CLR_Msk (0x1UL << I2CRXOVFCLR_ALL_CLR_Pos)

typedef enum
{
    I2CRXOVFCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CRXOVFCLR_BIT_CLR;

#define I2CRXOVFCLR_ALL_CLR_0     ((0x0UL) << I2CRXOVFCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXOVFCLR     CLR
 *  @access     I2C->I2CTXOVFCLR.bit.CLR
 *  @brief      Read this register to clear the TXOVF interrupt (bit 3) of the I2CRAWIF register
 */
#define I2CTXOVFCLR_ALL_CLR_Pos (0)
#define I2CTXOVFCLR_ALL_CLR_Msk (0x1UL << I2CTXOVFCLR_ALL_CLR_Pos)

typedef enum
{
    I2CTXOVFCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CTXOVFCLR_BIT_CLR;

#define I2CTXOVFCLR_ALL_CLR_0     ((0x0UL) << I2CTXOVFCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRDREQCLR     CLR
 *  @access     I2C->I2CRDREQCLR.bit.CLR
 *  @brief      Read this register to clear the RDREQ interrupt (bit 5) of the I2CRAWIF register
 */
#define I2CRDREQCLR_ALL_CLR_Pos (0)
#define I2CRDREQCLR_ALL_CLR_Msk (0x1UL << I2CRDREQCLR_ALL_CLR_Pos)

typedef enum
{
    I2CRDREQCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CRDREQCLR_BIT_CLR;

#define I2CRDREQCLR_ALL_CLR_0     ((0x0UL) << I2CRDREQCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTCLR    CLR
 *  @access     I2C->I2CTXABRTCLR.bit.CLR
 *  @brief      Read this register to clear the TXABRT interrupt (bit 6) of the I2CRAWIF register, and the I2CTXABRTSRC register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2CTXABRTSRC register for an exception to clearing TX_ABRT_SOURCE.
 */
#define I2CTXABRTCLR_ALL_CLR_Pos (0)
#define I2CTXABRTCLR_ALL_CLR_Msk (0x1UL << I2CTXABRTCLR_ALL_CLR_Pos)

typedef enum
{
    I2CTXABRTCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CTXABRTCLR_BIT_CLR;

#define I2CTXABRTCLR_ALL_CLR_0     ((0x0UL) << I2CTXABRTCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRXDONECLR    CLR
 *  @access     I2C->I2CRXDONECLR.bit.CLR
 *  @brief      Read this register to clear the RXDONE interrupt (bit 7) of the I2CRAWIF register
 */
#define I2CRXDONECLR_ALL_CLR_Pos (0)
#define I2CRXDONECLR_ALL_CLR_Msk (0x1UL << I2CRXDONECLR_ALL_CLR_Pos)

typedef enum
{
    I2CRXDONECLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CRXDONECLR_BIT_CLR;

#define I2CRXDONECLR_ALL_CLR_0     ((0x0UL) << I2CRXDONECLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CACTCLR       CLR
 *  @access     I2C->I2CACTCLR.bit.CLR
 *  @brief      Reading this register clears the ACT interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACT interrupt (bit 8) of the I2CRAWIF register.
 */
#define I2CACTCLR_ALL_CLR_Pos (0)
#define I2CACTCLR_ALL_CLR_Msk (0x1UL << I2CACTCLR_ALL_CLR_Pos)

typedef enum
{
    I2CACTCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CACTCLR_BIT_CLR;

#define I2CACTCLR_ALL_CLR_0     ((0x0UL) << I2CACTCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTOPDETCLR   CLR
 *  @access     I2C->I2CSTOPDETCLR.bit.CLR
 *  @brief      Read this register to clear the STOPDET interrupt (bit 9) of the I2CRAWIF register
 */
#define I2CSTOPDETCLR_ALL_CLR_Pos (0)
#define I2CSTOPDETCLR_ALL_CLR_Msk (0x1UL << I2CSTOPDETCLR_ALL_CLR_Pos)

typedef enum
{
    I2CSTOPDETCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CSTOPDETCLR_BIT_CLR;

#define I2CSTOPDETCLR_ALL_CLR_0     ((0x0UL) << I2CSTOPDETCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTARTDETCLR  CLR
 *  @access     I2C->I2CSTARTDETCLR.bit.CLR
 *  @brief      Read this register to clear the STARTDET interrupt (bit 10) of the I2CRAWIF register
 */
#define I2CSTARTDETCLR_ALL_CLR_Pos (0)
#define I2CSTARTDETCLR_ALL_CLR_Msk (0x1UL << I2CSTARTDETCLR_ALL_CLR_Pos)

typedef enum
{
    I2CSTARTDETCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CSTARTDETCLR_BIT_CLR;

#define I2CSTARTDETCLR_ALL_CLR_0     ((0x0UL) << I2CSTARTDETCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CGENCALLCLR   CLR
 *  @access     I2C->I2CGENCALLCLR.bit.CLR
 *  @brief      Read this register to clear the GENCALL interrupt (bit 11) of I2CRAWIF register.
 */
#define I2CGENCALLCLR_ALL_CLR_Pos (0)
#define I2CGENCALLCLR_ALL_CLR_Msk (0x1UL << I2CGENCALLCLR_ALL_CLR_Pos)

typedef enum
{
    I2CGENCALLCLR_BIT_CLR_0     = 0,  /*!< Read to clear   */
} I2CGENCALLCLR_BIT_CLR;

#define I2CGENCALLCLR_ALL_CLR_0     ((0x0UL) << I2CGENCALLCLR_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CENABLE       EN
 *  @access     I2C->I2CENABLE.bit.EN
 *  @brief      Controls whether the I2C is enabled
 *              0x0: Disables I2C (TX and RX FIFOs are held in an erased state). Software can disable I2C while it is active. However, it is important that care be taken to ensure that i2c is disabled properly. When I2C is disabled, the following occurs:
 *              - The TX FIFO and RX FIFO get flushed.
 *              - Status bits in the I2CIF register are still active until i2c goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the I2C stops the current transfer at the end of the current byte and does not acknowledge the transfer. In systems with asynchronous pclk and ic_clk when CLK_TYPE parameter set to asynchronous, there is a two ic_clk delay when enabling or disabling the I2C.
 */
#define I2CENABLE_ALL_EN_Pos (0)
#define I2CENABLE_ALL_EN_Msk (0x1UL << I2CENABLE_ALL_EN_Pos)

typedef enum
{
    I2CENABLE_BIT_EN_DISABLE     = 0,  /*!< Disables I2C (TX and RX FIFOs are held in an erased state)   */
    I2CENABLE_BIT_EN_ENABLE      = 1,  /*!< Enables I2C                                                  */
} I2CENABLE_BIT_EN;

#define I2CENABLE_ALL_EN_DISABLE     ((0x0UL) << I2CENABLE_ALL_EN_Pos)
#define I2CENABLE_ALL_EN_ENABLE      ((0x1UL) << I2CENABLE_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTS          ACT
 *  @access     I2C->I2CSTS.bit.ACT
 *  @brief      I2C Activity Status
 *              Reset value: 0x0
 */
#define I2CSTS_ALL_ACT_Pos (0)
#define I2CSTS_ALL_ACT_Msk (0x1UL << I2CSTS_ALL_ACT_Pos)

typedef enum
{
    I2CSTS_BIT_ACT_NOT_OCCUR     = 0,  /*!< Idle     */
    I2CSTS_BIT_ACT_OCCUR         = 1,  /*!< Active   */
} I2CSTS_BIT_ACT;

#define I2CSTS_ALL_ACT_NOT_OCCUR     ((0x0UL) << I2CSTS_ALL_ACT_Pos)
#define I2CSTS_ALL_ACT_OCCUR         ((0x1UL) << I2CSTS_ALL_ACT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTS          TFNF
 *  @access     I2C->I2CSTS.bit.TFNF
 *  @brief      Transmit FIFO Not Full
 *              Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
 */
#define I2CSTS_ALL_TFNF_Pos (1)
#define I2CSTS_ALL_TFNF_Msk (0x1UL << I2CSTS_ALL_TFNF_Pos)

typedef enum
{
    I2CSTS_BIT_TFNF_NOT_OCCUR     = 0,  /*!< Transmit FIFO is full       */
    I2CSTS_BIT_TFNF_OCCUR         = 1,  /*!< Transmit FIFO is not full   */
} I2CSTS_BIT_TFNF;

#define I2CSTS_ALL_TFNF_NOT_OCCUR     ((0x0UL) << I2CSTS_ALL_TFNF_Pos)
#define I2CSTS_ALL_TFNF_OCCUR         ((0x1UL) << I2CSTS_ALL_TFNF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTS          TFE
 *  @access     I2C->I2CSTS.bit.TFE
 *  @brief      Transmit FIFO Completely Empty
 *              When the transmit FIFO is completely empty, this bit is set.
 *              When it contains one or more valid entries, this bit is cleared. This bit field does not request.
 */
#define I2CSTS_ALL_TFE_Pos (2)
#define I2CSTS_ALL_TFE_Msk (0x1UL << I2CSTS_ALL_TFE_Pos)

typedef enum
{
    I2CSTS_BIT_TFE_NOT_OCCUR     = 0,  /*!< Transmit FIFO is not empty   */
    I2CSTS_BIT_TFE_OCCUR         = 1,  /*!< Transmit FIFO is empty       */
} I2CSTS_BIT_TFE;

#define I2CSTS_ALL_TFE_NOT_OCCUR     ((0x0UL) << I2CSTS_ALL_TFE_Pos)
#define I2CSTS_ALL_TFE_OCCUR         ((0x1UL) << I2CSTS_ALL_TFE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTS          RFNE
 *  @access     I2C->I2CSTS.bit.RFNE
 *  @brief      Receive FIFO Not Empty
 *              This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
 */
#define I2CSTS_ALL_RFNE_Pos (3)
#define I2CSTS_ALL_RFNE_Msk (0x1UL << I2CSTS_ALL_RFNE_Pos)

typedef enum
{
    I2CSTS_BIT_RFNE_NOT_OCCUR     = 0,  /*!< Receive FIFO is empty       */
    I2CSTS_BIT_RFNE_OCCUR         = 1,  /*!< Receive FIFO is not empty   */
} I2CSTS_BIT_RFNE;

#define I2CSTS_ALL_RFNE_NOT_OCCUR     ((0x0UL) << I2CSTS_ALL_RFNE_Pos)
#define I2CSTS_ALL_RFNE_OCCUR         ((0x1UL) << I2CSTS_ALL_RFNE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTS          RFF
 *  @access     I2C->I2CSTS.bit.RFF
 *  @brief      Receive FIFO Completely Full
 *              When the receive FIFO is completely full, this bit is set.
 *              When the receive FIFO contains one or more empty location, this bit is cleared.
 */
#define I2CSTS_ALL_RFF_Pos (4)
#define I2CSTS_ALL_RFF_Msk (0x1UL << I2CSTS_ALL_RFF_Pos)

typedef enum
{
    I2CSTS_BIT_RFF_NOT_OCCUR     = 0,  /*!< Receive FIFO is not full   */
    I2CSTS_BIT_RFF_OCCUR         = 1,  /*!< Receive FIFO is full       */
} I2CSTS_BIT_RFF;

#define I2CSTS_ALL_RFF_NOT_OCCUR     ((0x0UL) << I2CSTS_ALL_RFF_Pos)
#define I2CSTS_ALL_RFF_OCCUR         ((0x1UL) << I2CSTS_ALL_RFF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTS          MACT
 *  @access     I2C->I2CSTS.bit.MACT
 *  @brief      Master FSM Activity Status
 *              When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
 *              Note: I2CSTS[0]-that is, ACT bit-is the OR of SACT and MACT bits.
 */
#define I2CSTS_ALL_MACT_Pos (5)
#define I2CSTS_ALL_MACT_Msk (0x1UL << I2CSTS_ALL_MACT_Pos)

typedef enum
{
    I2CSTS_BIT_MACT_NOT_OCCUR     = 0,  /*!< Master FSM is in IDLE state so the Master part of I2C is not Active   */
    I2CSTS_BIT_MACT_OCCUR         = 1,  /*!< Master FSM is not in IDLE state so the Master part of I2C is Active   */
} I2CSTS_BIT_MACT;

#define I2CSTS_ALL_MACT_NOT_OCCUR     ((0x0UL) << I2CSTS_ALL_MACT_Pos)
#define I2CSTS_ALL_MACT_OCCUR         ((0x1UL) << I2CSTS_ALL_MACT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSTS          SACT
 *  @access     I2C->I2CSTS.bit.SACT
 *  @brief      Slave FSM Activity Status
 *              When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
 */
#define I2CSTS_ALL_SACT_Pos (6)
#define I2CSTS_ALL_SACT_Msk (0x1UL << I2CSTS_ALL_SACT_Pos)

typedef enum
{
    I2CSTS_BIT_SACT_NOT_OCCUR     = 0,  /*!< Slave FSM is in IDLE state so the Slave part of I2C is not Active   */
    I2CSTS_BIT_SACT_OCCUR         = 1,  /*!< Slave FSM is not in IDLE state so the Slave part of I2C is Active   */
} I2CSTS_BIT_SACT;

#define I2CSTS_ALL_SACT_NOT_OCCUR     ((0x0UL) << I2CSTS_ALL_SACT_Pos)
#define I2CSTS_ALL_SACT_OCCUR         ((0x1UL) << I2CSTS_ALL_SACT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTFLVL        VAL
 *  @access     I2C->I2CTFLVL.bit.VAL
 *  @brief      Transmit FIFO Level
 *              Contains the number of valid data entries in the transmit FIFO.
 */
#define I2CTFLVL_ALL_VAL_Pos (0)
#define I2CTFLVL_ALL_VAL_Msk (0x1FUL << I2CTFLVL_ALL_VAL_Pos)

#define I2CTFLVL_BIT_VAL

#define I2CTFLVL_ALL_VAL_(x) ((x) << I2CTFLVL_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CRFLVL        VAL
 *  @access     I2C->I2CRFLVL.bit.VAL
 *  @brief      Receive FIFO Level
 *              Contains the number of valid data entries in the receive FIFO.
 */
#define I2CRFLVL_ALL_VAL_Pos (0)
#define I2CRFLVL_ALL_VAL_Msk (0x1FUL << I2CRFLVL_ALL_VAL_Pos)

#define I2CRFLVL_BIT_VAL

#define I2CRFLVL_ALL_VAL_(x) ((x) << I2CRFLVL_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    ADDR7BNACK
 *  @access     I2C->I2CTXABRTSRC.bit.ADDR7BNACK
 *  @brief      Role of I2C: Master-Transmitter or Master-Receiver
 *              0x1: Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
 */
#define I2CTXABRTSRC_ALL_ADDR7BNACK_Pos (0)
#define I2CTXABRTSRC_ALL_ADDR7BNACK_Msk (0x1UL << I2CTXABRTSRC_ALL_ADDR7BNACK_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_ADDR7BNACK_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_ADDR7BNACK_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_ADDR7BNACK;

#define I2CTXABRTSRC_ALL_ADDR7BNACK_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_ADDR7BNACK_Pos)
#define I2CTXABRTSRC_ALL_ADDR7BNACK_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_ADDR7BNACK_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    ADDR10B1NACK
 *  @access     I2C->I2CTXABRTSRC.bit.ADDR10B1NACK
 *  @brief      Role of I2C: Master-Transmitter or Master-Receiver
 *              0x1: Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
 */
#define I2CTXABRTSRC_ALL_ADDR10B1NACK_Pos (1)
#define I2CTXABRTSRC_ALL_ADDR10B1NACK_Msk (0x1UL << I2CTXABRTSRC_ALL_ADDR10B1NACK_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_ADDR10B1NACK_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_ADDR10B1NACK_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_ADDR10B1NACK;

#define I2CTXABRTSRC_ALL_ADDR10B1NACK_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_ADDR10B1NACK_Pos)
#define I2CTXABRTSRC_ALL_ADDR10B1NACK_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_ADDR10B1NACK_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    ADDR10B2NACK
 *  @access     I2C->I2CTXABRTSRC.bit.ADDR10B2NACK
 *  @brief      Role of I2C: Master-Transmitter or Master-Receiver
 *              0x1: Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave.
 */
#define I2CTXABRTSRC_ALL_ADDR10B2NACK_Pos (2)
#define I2CTXABRTSRC_ALL_ADDR10B2NACK_Msk (0x1UL << I2CTXABRTSRC_ALL_ADDR10B2NACK_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_ADDR10B2NACK_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_ADDR10B2NACK_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_ADDR10B2NACK;

#define I2CTXABRTSRC_ALL_ADDR10B2NACK_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_ADDR10B2NACK_Pos)
#define I2CTXABRTSRC_ALL_ADDR10B2NACK_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_ADDR10B2NACK_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    TXDATANACK
 *  @access     I2C->I2CTXABRTSRC.bit.TXDATANACK
 *  @brief      Role of I2C: Master-Transmitter
 *              0x1: This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
 */
#define I2CTXABRTSRC_ALL_TXDATANACK_Pos (3)
#define I2CTXABRTSRC_ALL_TXDATANACK_Msk (0x1UL << I2CTXABRTSRC_ALL_TXDATANACK_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_TXDATANACK_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_TXDATANACK_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_TXDATANACK;

#define I2CTXABRTSRC_ALL_TXDATANACK_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_TXDATANACK_Pos)
#define I2CTXABRTSRC_ALL_TXDATANACK_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_TXDATANACK_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    GCNACK
 *  @access     I2C->I2CTXABRTSRC.bit.GCNACK
 *  @brief      Role of I2C: Master-Transmitter
 *              0x1: I2C in master mode sent a General Call and no slave on the bus acknowledged the General Call.
 */
#define I2CTXABRTSRC_ALL_GCNACK_Pos (4)
#define I2CTXABRTSRC_ALL_GCNACK_Msk (0x1UL << I2CTXABRTSRC_ALL_GCNACK_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_GCNACK_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_GCNACK_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_GCNACK;

#define I2CTXABRTSRC_ALL_GCNACK_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_GCNACK_Pos)
#define I2CTXABRTSRC_ALL_GCNACK_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_GCNACK_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    GCREAD
 *  @access     I2C->I2CTXABRTSRC.bit.GCREAD
 *  @brief      Role of I2C: Master-Transmitter
 *              0x1: I2C in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (I2CDATACMD[9] is set to 1).
 */
#define I2CTXABRTSRC_ALL_GCREAD_Pos (5)
#define I2CTXABRTSRC_ALL_GCREAD_Msk (0x1UL << I2CTXABRTSRC_ALL_GCREAD_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_GCREAD_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_GCREAD_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_GCREAD;

#define I2CTXABRTSRC_ALL_GCREAD_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_GCREAD_Pos)
#define I2CTXABRTSRC_ALL_GCREAD_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_GCREAD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    HSACKDET
 *  @access     I2C->I2CTXABRTSRC.bit.HSACKDET
 *  @brief      Role of I2C: Master
 *              0x1: Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
 */
#define I2CTXABRTSRC_ALL_HSACKDET_Pos (6)
#define I2CTXABRTSRC_ALL_HSACKDET_Msk (0x1UL << I2CTXABRTSRC_ALL_HSACKDET_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_HSACKDET_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_HSACKDET_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_HSACKDET;

#define I2CTXABRTSRC_ALL_HSACKDET_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_HSACKDET_Pos)
#define I2CTXABRTSRC_ALL_HSACKDET_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_HSACKDET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    STARTACKDET
 *  @access     I2C->I2CTXABRTSRC.bit.STARTACKDET
 *  @brief      Role of I2C: Master
 *              0x1: Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).
 */
#define I2CTXABRTSRC_ALL_STARTACKDET_Pos (7)
#define I2CTXABRTSRC_ALL_STARTACKDET_Msk (0x1UL << I2CTXABRTSRC_ALL_STARTACKDET_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_STARTACKDET_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_STARTACKDET_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_STARTACKDET;

#define I2CTXABRTSRC_ALL_STARTACKDET_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_STARTACKDET_Pos)
#define I2CTXABRTSRC_ALL_STARTACKDET_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_STARTACKDET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    HSNORESTART
 *  @access     I2C->I2CTXABRTSRC.bit.HSNORESTART
 *  @brief      Role of I2C: Master-Transmitter or Master-Receiver
 *              0x1: The restart is disabled (RESTARTEN bit (I2CCTL[5]) =0) and the user is trying to use the master to transfer data in High Speed mode.
 */
#define I2CTXABRTSRC_ALL_HSNORESTART_Pos (8)
#define I2CTXABRTSRC_ALL_HSNORESTART_Msk (0x1UL << I2CTXABRTSRC_ALL_HSNORESTART_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_HSNORESTART_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_HSNORESTART_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_HSNORESTART;

#define I2CTXABRTSRC_ALL_HSNORESTART_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_HSNORESTART_Pos)
#define I2CTXABRTSRC_ALL_HSNORESTART_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_HSNORESTART_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    STARTNORESTART
 *  @access     I2C->I2CTXABRTSRC.bit.STARTNORESTART
 *  @brief      To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2CCTL[5]=1), the SPECIAL bit must be cleared (I2CMASTERADDR[11]), or the GCORSTART bit must be cleared (I2CMASTERADDR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets reasserted.
 *              Role of I2C: Master
 *              0x1: The restart is disabled (RESTARTEN bit (I2CCTL[5]) =0) and the user is trying to send a START Byte.
 */
#define I2CTXABRTSRC_ALL_STARTNORESTART_Pos (9)
#define I2CTXABRTSRC_ALL_STARTNORESTART_Msk (0x1UL << I2CTXABRTSRC_ALL_STARTNORESTART_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_STARTNORESTART_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_STARTNORESTART_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_STARTNORESTART;

#define I2CTXABRTSRC_ALL_STARTNORESTART_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_STARTNORESTART_Pos)
#define I2CTXABRTSRC_ALL_STARTNORESTART_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_STARTNORESTART_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    RD10BNORESTART
 *  @access     I2C->I2CTXABRTSRC.bit.RD10BNORESTART
 *  @brief      Role of I2C: Master-Receiver
 *              0x1: The restart is disabled (RESTARTEN bit (I2CCTL[5]) =0) and the master sends a read command in 10-bit addressing mode.
 */
#define I2CTXABRTSRC_ALL_RD10BNORESTART_Pos (10)
#define I2CTXABRTSRC_ALL_RD10BNORESTART_Msk (0x1UL << I2CTXABRTSRC_ALL_RD10BNORESTART_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_RD10BNORESTART_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_RD10BNORESTART_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_RD10BNORESTART;

#define I2CTXABRTSRC_ALL_RD10BNORESTART_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_RD10BNORESTART_Pos)
#define I2CTXABRTSRC_ALL_RD10BNORESTART_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_RD10BNORESTART_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    MASTERDIS
 *  @access     I2C->I2CTXABRTSRC.bit.MASTERDIS
 *  @brief      Role of I2C: Master-Transmitter or Master-Receiver
 *              0x1: User tries to initiate a Master operation with the Master mode disabled.
 */
#define I2CTXABRTSRC_ALL_MASTERDIS_Pos (11)
#define I2CTXABRTSRC_ALL_MASTERDIS_Msk (0x1UL << I2CTXABRTSRC_ALL_MASTERDIS_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_MASTERDIS_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_MASTERDIS_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_MASTERDIS;

#define I2CTXABRTSRC_ALL_MASTERDIS_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_MASTERDIS_Pos)
#define I2CTXABRTSRC_ALL_MASTERDIS_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_MASTERDIS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    MARBLOST
 *  @access     I2C->I2CTXABRTSRC.bit.MARBLOST
 *  @brief      Role of I2C: Master-Transmitter or Slave-Transmitter
 *              0x1: Master has lost arbitration, or if I2CTXABRTSRC[14] is also set, then the slave transmitter has lost arbitration.
 *              Note: I2C can be both master and slave at the same time.
 */
#define I2CTXABRTSRC_ALL_MARBLOST_Pos (12)
#define I2CTXABRTSRC_ALL_MARBLOST_Msk (0x1UL << I2CTXABRTSRC_ALL_MARBLOST_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_MARBLOST_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_MARBLOST_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_MARBLOST;

#define I2CTXABRTSRC_ALL_MARBLOST_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_MARBLOST_Pos)
#define I2CTXABRTSRC_ALL_MARBLOST_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_MARBLOST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    SLVFLUSHTF
 *  @access     I2C->I2CTXABRTSRC.bit.SLVFLUSHTF
 *  @brief      Role of I2C: Slave-Transmitter
 *              0x1: Slave has received a read command and some data exists in the TX FIFO so the slave issues a TXABRT interrupt to flush old data in TX FIFO.
 */
#define I2CTXABRTSRC_ALL_SLVFLUSHTF_Pos (13)
#define I2CTXABRTSRC_ALL_SLVFLUSHTF_Msk (0x1UL << I2CTXABRTSRC_ALL_SLVFLUSHTF_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_SLVFLUSHTF_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_SLVFLUSHTF_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_SLVFLUSHTF;

#define I2CTXABRTSRC_ALL_SLVFLUSHTF_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_SLVFLUSHTF_Pos)
#define I2CTXABRTSRC_ALL_SLVFLUSHTF_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_SLVFLUSHTF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    SARBLOST
 *  @access     I2C->I2CTXABRTSRC.bit.SARBLOST
 *  @brief      Role of i2c: Slave-Transmitter
 *              0x1: Slave lost the bus while transmitting data to a remote master. I2CTXABRTSRC[12] is set at the same time.
 *              Note: Even though the slave never 'owns' the bus, something could go wrong on the bus. This is a failsafe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then I2C no longer own the bus.
 */
#define I2CTXABRTSRC_ALL_SARBLOST_Pos (14)
#define I2CTXABRTSRC_ALL_SARBLOST_Msk (0x1UL << I2CTXABRTSRC_ALL_SARBLOST_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_SARBLOST_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_SARBLOST_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_SARBLOST;

#define I2CTXABRTSRC_ALL_SARBLOST_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_SARBLOST_Pos)
#define I2CTXABRTSRC_ALL_SARBLOST_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_SARBLOST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CTXABRTSRC    SLVRDINTX
 *  @access     I2C->I2CTXABRTSRC.bit.SLVRDINTX
 *  @brief      Role of I2C: Slave-Transmitter
 *              0x1: When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of I2CDATACMD register.
 */
#define I2CTXABRTSRC_ALL_SLVRDINTX_Pos (15)
#define I2CTXABRTSRC_ALL_SLVRDINTX_Msk (0x1UL << I2CTXABRTSRC_ALL_SLVRDINTX_Pos)

typedef enum
{
    I2CTXABRTSRC_BIT_SLVRDINTX_NOT_OCCUR     = 0,  /*!<    */
    I2CTXABRTSRC_BIT_SLVRDINTX_OCCUR         = 1,  /*!<    */
} I2CTXABRTSRC_BIT_SLVRDINTX;

#define I2CTXABRTSRC_ALL_SLVRDINTX_NOT_OCCUR     ((0x0UL) << I2CTXABRTSRC_ALL_SLVRDINTX_Pos)
#define I2CTXABRTSRC_ALL_SLVRDINTX_OCCUR         ((0x1UL) << I2CTXABRTSRC_ALL_SLVRDINTX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CSDASETUP     VAL
 *  @access     I2C->I2CSDASETUP.bit.VAL
 *  @brief      SDA Setup
 *              It is recommended that if the required delay is 1000ns, then for an ic_clk frequency of 10 MHz, SDA_SETUP should be programmed to a value of 11.
 */
#define I2CSDASETUP_ALL_VAL_Pos (0)
#define I2CSDASETUP_ALL_VAL_Msk (0xFFUL << I2CSDASETUP_ALL_VAL_Pos)

#define I2CSDASETUP_BIT_VAL

#define I2CSDASETUP_ALL_VAL_(x) ((x) << I2CSDASETUP_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CACKGC        ACKGC
 *  @access     I2C->I2CACKGC.bit.ACKGC
 *  @brief      ACK General Call
 *              When set to 1, I2C responds with a ACK (by asserting ic_data_oe) when it receives a General Call. Otherwise, I2C responds with a NACK (by negating ic_data_oe).
 */
#define I2CACKGC_ALL_ACKGC_Pos (0)
#define I2CACKGC_ALL_ACKGC_Msk (0x1UL << I2CACKGC_ALL_ACKGC_Pos)

typedef enum
{
    I2CACKGC_BIT_ACKGC_DISABLE     = 0,  /*!< I2C responds with a NACK   */
    I2CACKGC_BIT_ACKGC_ENABLE      = 1,  /*!< I2C responds with a ACK    */
} I2CACKGC_BIT_ACKGC;

#define I2CACKGC_ALL_ACKGC_DISABLE     ((0x0UL) << I2CACKGC_ALL_ACKGC_Pos)
#define I2CACKGC_ALL_ACKGC_ENABLE      ((0x1UL) << I2CACKGC_ALL_ACKGC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CENSTS        EN
 *  @access     I2C->I2CENSTS.bit.EN
 *  @brief      ic_en Status
 *              This bit always reflects the value driven on the output port ic_en. When read as 1, I2C is deemed to be in an enabled state. When read as 0, I2C is deemed completely inactive.
 *              NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLVRDLOST (bit 2) and SLVDISONBUSY (bit 1).
 */
#define I2CENSTS_ALL_EN_Pos (0)
#define I2CENSTS_ALL_EN_Msk (0x1UL << I2CENSTS_ALL_EN_Pos)

typedef enum
{
    I2CENSTS_BIT_EN_NOT_OCCUR     = 0,  /*!< I2C is deemed completely inactive         */
    I2CENSTS_BIT_EN_OCCUR         = 1,  /*!< I2C is deemed to be in an enabled state   */
} I2CENSTS_BIT_EN;

#define I2CENSTS_ALL_EN_NOT_OCCUR     ((0x0UL) << I2CENSTS_ALL_EN_Pos)
#define I2CENSTS_ALL_EN_OCCUR         ((0x1UL) << I2CENSTS_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CENSTS        SLVDISONBUSY
 *  @access     I2C->I2CENSTS.bit.SLVDISONBUSY
 *  @brief      Slave Disabled While Busy (Transmit, Receive)
 *              This bit indicates if a potential or active Slave operation has been aborted due to the setting of the I2CENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the I2CENABLE register while: (a) I2C is receiving the address byte of the Slave-Transmitter operation from a remote master; OR, (b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, I2C is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C (SAR register) OR if the transfer is completed before I2CENABLE is set to 0 but has not taken effect.
 *              NOTE: If the remote I2C master terminates the transfer with a STOP condition before the i2c has a chance to NACK a transfer, and I2CENABLE has been set to 0, then this bit will also be set to 1. When read as 0, I2C is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
 *              NOTE: The CPU can safely read this bit when EN (bit 0) is read as 0.
 */
#define I2CENSTS_ALL_SLVDISONBUSY_Pos (1)
#define I2CENSTS_ALL_SLVDISONBUSY_Msk (0x1UL << I2CENSTS_ALL_SLVDISONBUSY_Pos)

typedef enum
{
    I2CENSTS_BIT_SLVDISONBUSY_NOT_OCCUR     = 0,  /*!<    */
    I2CENSTS_BIT_SLVDISONBUSY_OCCUR         = 1,  /*!<    */
} I2CENSTS_BIT_SLVDISONBUSY;

#define I2CENSTS_ALL_SLVDISONBUSY_NOT_OCCUR     ((0x0UL) << I2CENSTS_ALL_SLVDISONBUSY_Pos)
#define I2CENSTS_ALL_SLVDISONBUSY_OCCUR         ((0x1UL) << I2CENSTS_ALL_SLVDISONBUSY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   I2C             I2CENSTS        SLVRDLOST
 *  @access     I2C->I2CENSTS.bit.SLVRDLOST
 *  @brief      Slave Received Data Lost
 *              This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting of I2CENABLE from 1 to 0. When read as 1, I2C is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK.
 *              NOTE: If the remote I2C master terminates the transfer with a STOP condition before the I2C has a chance to NACK a transfer, and I2CENABLE has been set to 0, then this bit is also set to 1. When read as 0, I2C is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
 *              NOTE: The CPU can safely read this bit when EN (bit 0) is read as 0.
 */
#define I2CENSTS_ALL_SLVRDLOST_Pos (2)
#define I2CENSTS_ALL_SLVRDLOST_Msk (0x1UL << I2CENSTS_ALL_SLVRDLOST_Pos)

typedef enum
{
    I2CENSTS_BIT_SLVRDLOST_NOT_OCCUR     = 0,  /*!<    */
    I2CENSTS_BIT_SLVRDLOST_OCCUR         = 1,  /*!<    */
} I2CENSTS_BIT_SLVRDLOST;

#define I2CENSTS_ALL_SLVRDLOST_NOT_OCCUR     ((0x0UL) << I2CENSTS_ALL_SLVRDLOST_Pos)
#define I2CENSTS_ALL_SLVRDLOST_OCCUR         ((0x1UL) << I2CENSTS_ALL_SLVRDLOST_Pos)





/********************************************************************************
*
* Module Name     PWM0
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBPRD           VAL
 *  @access     PWM->TBPRD.bit.VAL
 *  @brief      Time-base counter period
 *              TBCTL.PRDLD=0: Access to this register will actually goes to the internal shadow register (sharing the same address), and the active value will be updated from shadow register when TBCNT is zero.
 *              TBCTL.PRDLD=1: Access to this register will directly affect the active value.
 */
#define TBPRD_ALL_VAL_Pos (0)
#define TBPRD_ALL_VAL_Msk (0xFFFFUL << TBPRD_ALL_VAL_Pos)

#define TBPRD_BIT_VAL

#define TBPRD_ALL_VAL_(x) ((x) << TBPRD_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBPHS           VAL
 *  @access     PWM->TBPHS.bit.VAL
 *  @brief      Time-base counter phase when synchronization event occurs
 *              TBCTL.PHSEN=0: The synchronization event is ignored and TBCNT keeps its value.
 *              TBCTL.PHSEN=1: Time-base counter (TBCNT) will be loaded with TBPHS when synchronization event occurs.
 */
#define TBPHS_ALL_VAL_Pos (0)
#define TBPHS_ALL_VAL_Msk (0xFFFFUL << TBPHS_ALL_VAL_Pos)

#define TBPHS_BIT_VAL

#define TBPHS_ALL_VAL_(x) ((x) << TBPHS_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCNT           VAL
 *  @access     PWM->TBCNT.bit.VAL
 *  @brief      Current value of the time-base counter
 */
#define TBCNT_ALL_VAL_Pos (0)
#define TBCNT_ALL_VAL_Msk (0xFFFFUL << TBCNT_ALL_VAL_Pos)

#define TBCNT_BIT_VAL

#define TBCNT_ALL_VAL_(x) ((x) << TBCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCTL           CNTMODE
 *  @access     PWM->TBCTL.bit.CNTMODE
 *  @brief      Counter mode
 */
#define TBCTL_ALL_CNTMODE_Pos (0)
#define TBCTL_ALL_CNTMODE_Msk (0x3UL << TBCTL_ALL_CNTMODE_Pos)

typedef enum
{
    TBCTL_BIT_CNTMODE_COUNT_UP_AND_RUN          = 0,  /*!< Up-count                             */
    TBCTL_BIT_CNTMODE_COUNT_DOWN_AND_RUN        = 1,  /*!< Down-count                           */
    TBCTL_BIT_CNTMODE_COUNT_UP_DOWN_AND_RUN     = 2,  /*!< Up-down-count                        */
    TBCTL_BIT_CNTMODE_COUNT_STOP                = 3,  /*!< Stop and freeze (default on reset)   */
} TBCTL_BIT_CNTMODE;

#define TBCTL_ALL_CNTMODE_COUNT_UP_AND_RUN          ((0x0UL) << TBCTL_ALL_CNTMODE_Pos)
#define TBCTL_ALL_CNTMODE_COUNT_DOWN_AND_RUN        ((0x1UL) << TBCTL_ALL_CNTMODE_Pos)
#define TBCTL_ALL_CNTMODE_COUNT_UP_DOWN_AND_RUN     ((0x2UL) << TBCTL_ALL_CNTMODE_Pos)
#define TBCTL_ALL_CNTMODE_COUNT_STOP                ((0x3UL) << TBCTL_ALL_CNTMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCTL           PHSEN
 *  @access     PWM->TBCTL.bit.PHSEN
 *  @brief      Phase register enable
 */
#define TBCTL_ALL_PHSEN_Pos (2)
#define TBCTL_ALL_PHSEN_Msk (0x1UL << TBCTL_ALL_PHSEN_Pos)

typedef enum
{
    TBCTL_BIT_PHSEN_DISABLE     = 0,  /*!< Do not load time-base counter (TBCNT) from time-base phase register (TBPHS)                                                     */
    TBCTL_BIT_PHSEN_ENABLE      = 1,  /*!< Load TBCNT from TBPHS when synchronization event occurs (SYNCI input, software synchronization or digital compare sync event)   */
} TBCTL_BIT_PHSEN;

#define TBCTL_ALL_PHSEN_DISABLE     ((0x0UL) << TBCTL_ALL_PHSEN_Pos)
#define TBCTL_ALL_PHSEN_ENABLE      ((0x1UL) << TBCTL_ALL_PHSEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCTL           PRDLD
 *  @access     PWM->TBCTL.bit.PRDLD
 *  @brief      Time-base counter period register (TBPRD) load mode
 */
#define TBCTL_ALL_PRDLD_Pos (3)
#define TBCTL_ALL_PRDLD_Msk (0x1UL << TBCTL_ALL_PRDLD_Pos)

typedef enum
{
    TBCTL_BIT_PRDLD_TBPRD_FROM_SHADOW     = 0,  /*!< TBPRD is loaded from its shadow register when time-base counter (TBCNT) is zero   */
    TBCTL_BIT_PRDLD_TBPRD_IMMEDIATE       = 1,  /*!< TBPRD is directly accessed without a shadow register                              */
} TBCTL_BIT_PRDLD;

#define TBCTL_ALL_PRDLD_TBPRD_FROM_SHADOW     ((0x0UL) << TBCTL_ALL_PRDLD_Pos)
#define TBCTL_ALL_PRDLD_TBPRD_IMMEDIATE       ((0x1UL) << TBCTL_ALL_PRDLD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCTL           SYNCOSEL
 *  @access     PWM->TBCTL.bit.SYNCOSEL
 *  @brief      Synchronization output select
 */
#define TBCTL_ALL_SYNCOSEL_Pos (4)
#define TBCTL_ALL_SYNCOSEL_Msk (0x3UL << TBCTL_ALL_SYNCOSEL_Pos)

typedef enum
{
    TBCTL_BIT_SYNCOSEL_PWMxSYNC           = 0,  /*!< SYNCI           */
    TBCTL_BIT_SYNCOSEL_TBCNT_EQU_ZERO     = 1,  /*!< TBCNT=Zero      */
    TBCTL_BIT_SYNCOSEL_TBCNT_EQU_CMPB     = 2,  /*!< TBCNT=TBPRD     */
    TBCTL_BIT_SYNCOSEL_DISABLE            = 3,  /*!< Disable SYNCO   */
} TBCTL_BIT_SYNCOSEL;

#define TBCTL_ALL_SYNCOSEL_PWMxSYNC           ((0x0UL) << TBCTL_ALL_SYNCOSEL_Pos)
#define TBCTL_ALL_SYNCOSEL_TBCNT_EQU_ZERO     ((0x1UL) << TBCTL_ALL_SYNCOSEL_Pos)
#define TBCTL_ALL_SYNCOSEL_TBCNT_EQU_CMPB     ((0x2UL) << TBCTL_ALL_SYNCOSEL_Pos)
#define TBCTL_ALL_SYNCOSEL_DISABLE            ((0x3UL) << TBCTL_ALL_SYNCOSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCTL           FRCSYNC
 *  @access     PWM->TBCTL.bit.FRCSYNC
 *  @brief      Software forced synchronization
 *              This event is ORed with SYNCI input and is valid only when SYNCOSEL=00
 */
#define TBCTL_ALL_FRCSYNC_Pos (6)
#define TBCTL_ALL_FRCSYNC_Msk (0x1UL << TBCTL_ALL_FRCSYNC_Pos)

typedef enum
{
    TBCTL_BIT_FRCSYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect and reads always return a 0   */
    TBCTL_BIT_FRCSYNC_ENABLE        = 1,  /*!< Write a 1 forces a one-time synchronization pulse     */
} TBCTL_BIT_FRCSYNC;

#define TBCTL_ALL_FRCSYNC_NO_EFFECT     ((0x0UL) << TBCTL_ALL_FRCSYNC_Pos)
#define TBCTL_ALL_FRCSYNC_ENABLE        ((0x1UL) << TBCTL_ALL_FRCSYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCTL           TBCLKDIV
 *  @access     PWM->TBCTL.bit.TBCLKDIV
 *  @brief      Time-base clock dividing ratio from PWM clock input
 */
#define TBCTL_ALL_TBCLKDIV_Pos (10)
#define TBCTL_ALL_TBCLKDIV_Msk (0x7UL << TBCTL_ALL_TBCLKDIV_Pos)

typedef enum
{
    TBCTL_BIT_TBCLKDIV_1       = 0,  /*!< /1 (default on reset)   */
    TBCTL_BIT_TBCLKDIV_2       = 1,  /*!< /2                      */
    TBCTL_BIT_TBCLKDIV_4       = 2,  /*!< /4                      */
    TBCTL_BIT_TBCLKDIV_8       = 3,  /*!< /8                      */
    TBCTL_BIT_TBCLKDIV_16      = 4,  /*!< /16                     */
    TBCTL_BIT_TBCLKDIV_32      = 5,  /*!< /32                     */
    TBCTL_BIT_TBCLKDIV_64      = 6,  /*!< /64                     */
    TBCTL_BIT_TBCLKDIV_128     = 7,  /*!< /128                    */
} TBCTL_BIT_TBCLKDIV;

#define TBCTL_ALL_TBCLKDIV_1       ((0x0UL) << TBCTL_ALL_TBCLKDIV_Pos)
#define TBCTL_ALL_TBCLKDIV_2       ((0x1UL) << TBCTL_ALL_TBCLKDIV_Pos)
#define TBCTL_ALL_TBCLKDIV_4       ((0x2UL) << TBCTL_ALL_TBCLKDIV_Pos)
#define TBCTL_ALL_TBCLKDIV_8       ((0x3UL) << TBCTL_ALL_TBCLKDIV_Pos)
#define TBCTL_ALL_TBCLKDIV_16      ((0x4UL) << TBCTL_ALL_TBCLKDIV_Pos)
#define TBCTL_ALL_TBCLKDIV_32      ((0x5UL) << TBCTL_ALL_TBCLKDIV_Pos)
#define TBCTL_ALL_TBCLKDIV_64      ((0x6UL) << TBCTL_ALL_TBCLKDIV_Pos)
#define TBCTL_ALL_TBCLKDIV_128     ((0x7UL) << TBCTL_ALL_TBCLKDIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCTL           PHSDIR
 *  @access     PWM->TBCTL.bit.PHSDIR
 *  @brief      Phase direction
 *              It is valid only when TBCNT is in up-down-count mode (CNTMODE=10)
 */
#define TBCTL_ALL_PHSDIR_Pos (13)
#define TBCTL_ALL_PHSDIR_Msk (0x1UL << TBCTL_ALL_PHSDIR_Pos)

typedef enum
{
    TBCTL_BIT_PHSDIR_COUNT_DOWN_AFTER_SYNC     = 0,  /*!< Count down after synchronization event   */
    TBCTL_BIT_PHSDIR_COUNT_UP_AFTER_SYNC       = 1,  /*!< Count up after synchronization event     */
} TBCTL_BIT_PHSDIR;

#define TBCTL_ALL_PHSDIR_COUNT_DOWN_AFTER_SYNC     ((0x0UL) << TBCTL_ALL_PHSDIR_Pos)
#define TBCTL_ALL_PHSDIR_COUNT_UP_AFTER_SYNC       ((0x1UL) << TBCTL_ALL_PHSDIR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBCTL           DBGRUN
 *  @access     PWM->TBCTL.bit.DBGRUN
 *  @brief      PWM counter behaviour when CPU is halted
 *              
 *              Note: Debug operation and CPU fault exceptions both can cause CPU halted.
 */
#define TBCTL_ALL_DBGRUN_Pos (14)
#define TBCTL_ALL_DBGRUN_Msk (0x3UL << TBCTL_ALL_DBGRUN_Pos)

typedef enum
{
    TBCTL_BIT_DBGRUN_STOP_AFTER_COUNTING     = 0,  /*!< Stop after the next time-base counter increment or decrement                                       */
    TBCTL_BIT_DBGRUN_STOP_AFTER_CYCLE        = 1,  /*!< Stop when TBCNT completes a whole cycle (TBCNT=TBPRD for up-count mode and zero for other modes)   */
    TBCTL_BIT_DBGRUN_KEEP_RUN                = 2,  /*!< Counter keep running when CPU is halted                                                            */
} TBCTL_BIT_DBGRUN;

#define TBCTL_ALL_DBGRUN_STOP_AFTER_COUNTING     ((0x0UL) << TBCTL_ALL_DBGRUN_Pos)
#define TBCTL_ALL_DBGRUN_STOP_AFTER_CYCLE        ((0x1UL) << TBCTL_ALL_DBGRUN_Pos)
#define TBCTL_ALL_DBGRUN_KEEP_RUN                ((0x2UL) << TBCTL_ALL_DBGRUN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBSTS           CNTDIR
 *  @access     PWM->TBSTS.bit.CNTDIR
 *  @brief      Time-base counter direction status
 */
#define TBSTS_ALL_CNTDIR_Pos (0)
#define TBSTS_ALL_CNTDIR_Msk (0x1UL << TBSTS_ALL_CNTDIR_Pos)

typedef enum
{
    TBSTS_BIT_CNTDIR_COUNTING_DOWN     = 0,  /*!< Time-base counter is currently counting down   */
    TBSTS_BIT_CNTDIR_COUNTING_UP       = 1,  /*!< Time-base counter is currently counting up     */
} TBSTS_BIT_CNTDIR;

#define TBSTS_ALL_CNTDIR_COUNTING_DOWN     ((0x0UL) << TBSTS_ALL_CNTDIR_Pos)
#define TBSTS_ALL_CNTDIR_COUNTING_UP       ((0x1UL) << TBSTS_ALL_CNTDIR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBSTS           SYNCI
 *  @access     PWM->TBSTS.bit.SYNCI
 *  @brief      Input synchronization latched status
 */
#define TBSTS_ALL_SYNCI_Pos (1)
#define TBSTS_ALL_SYNCI_Msk (0x1UL << TBSTS_ALL_SYNCI_Pos)

typedef enum
{
    TBSTS_BIT_SYNCI_NO_EVENT        = 0,  /*!< Reading a 0 indicates no input synchronization event has occurred. Writing a 0 has no effect.                   */
    TBSTS_BIT_SYNCI_EVENT_OCCUR     = 1,  /*!< Reading a 1 indicates an input synchronization event has occurred. Writing a 1 will clear the latched status.   */
} TBSTS_BIT_SYNCI;

#define TBSTS_ALL_SYNCI_NO_EVENT        ((0x0UL) << TBSTS_ALL_SYNCI_Pos)
#define TBSTS_ALL_SYNCI_EVENT_OCCUR     ((0x1UL) << TBSTS_ALL_SYNCI_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TBSTS           CNTMAX
 *  @access     PWM->TBSTS.bit.CNTMAX
 *  @brief      Time-base counter reaching max latched status
 */
#define TBSTS_ALL_CNTMAX_Pos (2)
#define TBSTS_ALL_CNTMAX_Msk (0x1UL << TBSTS_ALL_CNTMAX_Pos)

typedef enum
{
    TBSTS_BIT_CNTMAX_NOT_REACHED     = 0,  /*!< Reading a 0 indicates TBCNT never reaches 0xFFFF. Writing a 0 has no effect.             */
    TBSTS_BIT_CNTMAX_REACHED         = 1,  /*!< Reading a 1 indicates TBCNT reached 0xFFFF. Writing a 1 will clear the latched status.   */
} TBSTS_BIT_CNTMAX;

#define TBSTS_ALL_CNTMAX_NOT_REACHED     ((0x0UL) << TBSTS_ALL_CNTMAX_Pos)
#define TBSTS_ALL_CNTMAX_REACHED         ((0x1UL) << TBSTS_ALL_CNTMAX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPA            VAL
 *  @access     PWM->CMPA.bit.VAL
 *  @brief      Comparator A threshold
 *              A TBCNT=CMPA event will be generated while TBCNT is equal to the threshold value
 *              CMPCTL.SHDWAMODE=0: Access to this register will actually go to the internal shadow register. The CMPCTL.LOADAMODE determines when the active value will be loaded from the shadow register.
 *              CMPCTL.SHDWAMODE=1: Access to this register will directly affect the active value.
 */
#define CMPA_ALL_VAL_Pos (0)
#define CMPA_ALL_VAL_Msk (0xFFFFUL << CMPA_ALL_VAL_Pos)

#define CMPA_BIT_VAL

#define CMPA_ALL_VAL_(x) ((x) << CMPA_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPB            VAL
 *  @access     PWM->CMPB.bit.VAL
 *  @brief      Comparator B threshold
 *              A TBCNT=CMPB event will be generated while TBCNT is equal to the threshold value
 *              CMPCTL.SHDWBMODE=0: Access to this register will actually go to the internal shadow register. The CMPCTL.LOADBMODE determines when the active value will be loaded from the shadow register.
 *              CMPCTL.SHDWBMODE=1: Access to this register will directly affect the active value.
 */
#define CMPB_ALL_VAL_Pos (0)
#define CMPB_ALL_VAL_Msk (0xFFFFUL << CMPB_ALL_VAL_Pos)

#define CMPB_BIT_VAL

#define CMPB_ALL_VAL_(x) ((x) << CMPB_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPCTL          LOADAMODE
 *  @access     PWM->CMPCTL.bit.LOADAMODE
 *  @brief      Mode to load CMPA active value from shadow register
 *              It has no effect when CMPCTL.SHDWAMODE=1
 */
#define CMPCTL_ALL_LOADAMODE_Pos (0)
#define CMPCTL_ALL_LOADAMODE_Msk (0x3UL << CMPCTL_ALL_LOADAMODE_Pos)

typedef enum
{
    CMPCTL_BIT_LOADAMODE_LOAD_ON_ZERO            = 0,  /*!< Load on TBCNT=Zero                             */
    CMPCTL_BIT_LOADAMODE_LOAD_ON_PERIOD          = 1,  /*!< Load on TBCNT=TBPRD                            */
    CMPCTL_BIT_LOADAMODE_LOAD_ON_ZERO_PERIOD     = 2,  /*!< Load on either TBCNT=Zero or TBCNT=TBPRD       */
    CMPCTL_BIT_LOADAMODE_FREEZE                  = 3,  /*!< Freeze CMPA active value (No loads possible)   */
} CMPCTL_BIT_LOADAMODE;

#define CMPCTL_ALL_LOADAMODE_LOAD_ON_ZERO            ((0x0UL) << CMPCTL_ALL_LOADAMODE_Pos)
#define CMPCTL_ALL_LOADAMODE_LOAD_ON_PERIOD          ((0x1UL) << CMPCTL_ALL_LOADAMODE_Pos)
#define CMPCTL_ALL_LOADAMODE_LOAD_ON_ZERO_PERIOD     ((0x2UL) << CMPCTL_ALL_LOADAMODE_Pos)
#define CMPCTL_ALL_LOADAMODE_FREEZE                  ((0x3UL) << CMPCTL_ALL_LOADAMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPCTL          LOADBMODE
 *  @access     PWM->CMPCTL.bit.LOADBMODE
 *  @brief      Mode to load CMPB active value from shadow register
 *              It has no effect when CMPCTL.SHDWBMODE=1
 */
#define CMPCTL_ALL_LOADBMODE_Pos (2)
#define CMPCTL_ALL_LOADBMODE_Msk (0x3UL << CMPCTL_ALL_LOADBMODE_Pos)

typedef enum
{
    CMPCTL_BIT_LOADBMODE_LOAD_ON_ZERO            = 0,  /*!< Load on TBCNT=Zero                             */
    CMPCTL_BIT_LOADBMODE_LOAD_ON_PERIOD          = 1,  /*!< Load on TBCNT=TBPRD                            */
    CMPCTL_BIT_LOADBMODE_LOAD_ON_ZERO_PERIOD     = 2,  /*!< Load on either TBCNT=Zero or TBCNT=TBPRD       */
    CMPCTL_BIT_LOADBMODE_FREEZE                  = 3,  /*!< Freeze CMPA active value (No loads possible)   */
} CMPCTL_BIT_LOADBMODE;

#define CMPCTL_ALL_LOADBMODE_LOAD_ON_ZERO            ((0x0UL) << CMPCTL_ALL_LOADBMODE_Pos)
#define CMPCTL_ALL_LOADBMODE_LOAD_ON_PERIOD          ((0x1UL) << CMPCTL_ALL_LOADBMODE_Pos)
#define CMPCTL_ALL_LOADBMODE_LOAD_ON_ZERO_PERIOD     ((0x2UL) << CMPCTL_ALL_LOADBMODE_Pos)
#define CMPCTL_ALL_LOADBMODE_FREEZE                  ((0x3UL) << CMPCTL_ALL_LOADBMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPCTL          SHDWAMODE
 *  @access     PWM->CMPCTL.bit.SHDWAMODE
 *  @brief      CMPA register mode
 */
#define CMPCTL_ALL_SHDWAMODE_Pos (4)
#define CMPCTL_ALL_SHDWAMODE_Msk (0x1UL << CMPCTL_ALL_SHDWAMODE_Pos)

typedef enum
{
    CMPCTL_BIT_SHDWAMODE_SHADOW_MODE        = 0,  /*!< Shadow mode      */
    CMPCTL_BIT_SHDWAMODE_IMMEDIATE_MODE     = 1,  /*!< Immediate mode   */
} CMPCTL_BIT_SHDWAMODE;

#define CMPCTL_ALL_SHDWAMODE_SHADOW_MODE        ((0x0UL) << CMPCTL_ALL_SHDWAMODE_Pos)
#define CMPCTL_ALL_SHDWAMODE_IMMEDIATE_MODE     ((0x1UL) << CMPCTL_ALL_SHDWAMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPCTL          ADVCMPA
 *  @access     PWM->CMPCTL.bit.ADVCMPA
 *  @brief      Advanced mode for CMPA
 */
#define CMPCTL_ALL_ADVCMPA_Pos (5)
#define CMPCTL_ALL_ADVCMPA_Msk (0x1UL << CMPCTL_ALL_ADVCMPA_Pos)

typedef enum
{
    CMPCTL_BIT_ADVCMPA_NORMAL_MODE       = 0,  /*!< Normal mode: No TBCNT=CMPA event will be generated when CMPA=0 or CMPA=TBPRD   */
    CMPCTL_BIT_ADVCMPA_ADVANCED_MODE     = 1,  /*!< Advanced mode: CMPA can be 0 or TBPRD                                          */
} CMPCTL_BIT_ADVCMPA;

#define CMPCTL_ALL_ADVCMPA_NORMAL_MODE       ((0x0UL) << CMPCTL_ALL_ADVCMPA_Pos)
#define CMPCTL_ALL_ADVCMPA_ADVANCED_MODE     ((0x1UL) << CMPCTL_ALL_ADVCMPA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPCTL          SHDWBMODE
 *  @access     PWM->CMPCTL.bit.SHDWBMODE
 *  @brief      CMPB register mode
 */
#define CMPCTL_ALL_SHDWBMODE_Pos (6)
#define CMPCTL_ALL_SHDWBMODE_Msk (0x1UL << CMPCTL_ALL_SHDWBMODE_Pos)

typedef enum
{
    CMPCTL_BIT_SHDWBMODE_SHADOW_MODE        = 0,  /*!< Shadow mode      */
    CMPCTL_BIT_SHDWBMODE_IMMEDIATE_MODE     = 1,  /*!< Immediate mode   */
} CMPCTL_BIT_SHDWBMODE;

#define CMPCTL_ALL_SHDWBMODE_SHADOW_MODE        ((0x0UL) << CMPCTL_ALL_SHDWBMODE_Pos)
#define CMPCTL_ALL_SHDWBMODE_IMMEDIATE_MODE     ((0x1UL) << CMPCTL_ALL_SHDWBMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPCTL          ADVCMPB
 *  @access     PWM->CMPCTL.bit.ADVCMPB
 *  @brief      Advanced mode for CMPB
 */
#define CMPCTL_ALL_ADVCMPB_Pos (7)
#define CMPCTL_ALL_ADVCMPB_Msk (0x1UL << CMPCTL_ALL_ADVCMPB_Pos)

typedef enum
{
    CMPCTL_BIT_ADVCMPB_NORMAL_MODE       = 0,  /*!< Normal mode: No TBCNT=CMPB event will be generated when CMPB=0 or CMPB=TBPRD   */
    CMPCTL_BIT_ADVCMPB_ADVANCED_MODE     = 1,  /*!< Advanced mode: CMPB can be 0 or TBPRD                                          */
} CMPCTL_BIT_ADVCMPB;

#define CMPCTL_ALL_ADVCMPB_NORMAL_MODE       ((0x0UL) << CMPCTL_ALL_ADVCMPB_Pos)
#define CMPCTL_ALL_ADVCMPB_ADVANCED_MODE     ((0x1UL) << CMPCTL_ALL_ADVCMPB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPCTL          SHDWAFULL
 *  @access     PWM->CMPCTL.bit.SHDWAFULL
 *  @brief      CMPA shadow register full status flag
 *              A write to the shadow register will overwrite current value. A load from the shadow register to the active register will clear this bit.
 */
#define CMPCTL_ALL_SHDWAFULL_Pos (8)
#define CMPCTL_ALL_SHDWAFULL_Msk (0x1UL << CMPCTL_ALL_SHDWAFULL_Pos)

typedef enum
{
    CMPCTL_BIT_SHDWAFULL_NOT_OCCUR     = 0,  /*!< CMPA shadow FIFO not full yet   */
    CMPCTL_BIT_SHDWAFULL_OCCUR         = 1,  /*!< CMPA shadow FIFO is full        */
} CMPCTL_BIT_SHDWAFULL;

#define CMPCTL_ALL_SHDWAFULL_NOT_OCCUR     ((0x0UL) << CMPCTL_ALL_SHDWAFULL_Pos)
#define CMPCTL_ALL_SHDWAFULL_OCCUR         ((0x1UL) << CMPCTL_ALL_SHDWAFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             CMPCTL          SHDWBFULL
 *  @access     PWM->CMPCTL.bit.SHDWBFULL
 *  @brief      CMPB shadow register full status flag
 *              A write to the shadow register will overwrite current value. A load from the shadow register to the active register will clear this bit.
 */
#define CMPCTL_ALL_SHDWBFULL_Pos (9)
#define CMPCTL_ALL_SHDWBFULL_Msk (0x1UL << CMPCTL_ALL_SHDWBFULL_Pos)

typedef enum
{
    CMPCTL_BIT_SHDWBFULL_NOT_OCCUR     = 0,  /*!< CMPB shadow FIFO not full yet   */
    CMPCTL_BIT_SHDWBFULL_OCCUR         = 1,  /*!< CMPB shadow FIFO is full        */
} CMPCTL_BIT_SHDWBFULL;

#define CMPCTL_ALL_SHDWBFULL_NOT_OCCUR     ((0x0UL) << CMPCTL_ALL_SHDWBFULL_Pos)
#define CMPCTL_ALL_SHDWBFULL_OCCUR         ((0x1UL) << CMPCTL_ALL_SHDWBFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLA          ZRO
 *  @access     PWM->AQCTLA.bit.ZRO
 *  @brief      Action on output A when TBCNT=Zero
 */
#define AQCTLA_ALL_ZRO_Pos (0)
#define AQCTLA_ALL_ZRO_Msk (0x3UL << AQCTLA_ALL_ZRO_Pos)

typedef enum
{
    AQCTLA_BIT_ZRO_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLA_BIT_ZRO_SET_LOW        = 1,  /*!< Clear (force PWM output A to low)             */
    AQCTLA_BIT_ZRO_SET_HIGH       = 2,  /*!< Set (force PWM output A to high)              */
    AQCTLA_BIT_ZRO_TOGGLE         = 3,  /*!< Toggle (invert current PWM output A status)   */
} AQCTLA_BIT_ZRO;

#define AQCTLA_ALL_ZRO_DO_NOTHING     ((0x0UL) << AQCTLA_ALL_ZRO_Pos)
#define AQCTLA_ALL_ZRO_SET_LOW        ((0x1UL) << AQCTLA_ALL_ZRO_Pos)
#define AQCTLA_ALL_ZRO_SET_HIGH       ((0x2UL) << AQCTLA_ALL_ZRO_Pos)
#define AQCTLA_ALL_ZRO_TOGGLE         ((0x3UL) << AQCTLA_ALL_ZRO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLA          PRD
 *  @access     PWM->AQCTLA.bit.PRD
 *  @brief      Action on output A when TBCNT=TBPRD
 */
#define AQCTLA_ALL_PRD_Pos (2)
#define AQCTLA_ALL_PRD_Msk (0x3UL << AQCTLA_ALL_PRD_Pos)

typedef enum
{
    AQCTLA_BIT_PRD_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLA_BIT_PRD_SET_LOW        = 1,  /*!< Clear (force PWM output A to low)             */
    AQCTLA_BIT_PRD_SET_HIGH       = 2,  /*!< Set (force PWM output A to high)              */
    AQCTLA_BIT_PRD_TOGGLE         = 3,  /*!< Toggle (invert current PWM output A status)   */
} AQCTLA_BIT_PRD;

#define AQCTLA_ALL_PRD_DO_NOTHING     ((0x0UL) << AQCTLA_ALL_PRD_Pos)
#define AQCTLA_ALL_PRD_SET_LOW        ((0x1UL) << AQCTLA_ALL_PRD_Pos)
#define AQCTLA_ALL_PRD_SET_HIGH       ((0x2UL) << AQCTLA_ALL_PRD_Pos)
#define AQCTLA_ALL_PRD_TOGGLE         ((0x3UL) << AQCTLA_ALL_PRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLA          CAU
 *  @access     PWM->AQCTLA.bit.CAU
 *  @brief      Action on output A when TBCNT=CMPA and TBCNT is counting up
 */
#define AQCTLA_ALL_CAU_Pos (4)
#define AQCTLA_ALL_CAU_Msk (0x3UL << AQCTLA_ALL_CAU_Pos)

typedef enum
{
    AQCTLA_BIT_CAU_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLA_BIT_CAU_SET_LOW        = 1,  /*!< Clear (force PWM output A to low)             */
    AQCTLA_BIT_CAU_SET_HIGH       = 2,  /*!< Set (force PWM output A to high)              */
    AQCTLA_BIT_CAU_TOGGLE         = 3,  /*!< Toggle (invert current PWM output A status)   */
} AQCTLA_BIT_CAU;

#define AQCTLA_ALL_CAU_DO_NOTHING     ((0x0UL) << AQCTLA_ALL_CAU_Pos)
#define AQCTLA_ALL_CAU_SET_LOW        ((0x1UL) << AQCTLA_ALL_CAU_Pos)
#define AQCTLA_ALL_CAU_SET_HIGH       ((0x2UL) << AQCTLA_ALL_CAU_Pos)
#define AQCTLA_ALL_CAU_TOGGLE         ((0x3UL) << AQCTLA_ALL_CAU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLA          CAD
 *  @access     PWM->AQCTLA.bit.CAD
 *  @brief      Action on output A when TBCNT=CMPA and TBCNT is counting down
 */
#define AQCTLA_ALL_CAD_Pos (6)
#define AQCTLA_ALL_CAD_Msk (0x3UL << AQCTLA_ALL_CAD_Pos)

typedef enum
{
    AQCTLA_BIT_CAD_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLA_BIT_CAD_SET_LOW        = 1,  /*!< Clear (force PWM output A to low)             */
    AQCTLA_BIT_CAD_SET_HIGH       = 2,  /*!< Set (force PWM output A to high)              */
    AQCTLA_BIT_CAD_TOGGLE         = 3,  /*!< Toggle (invert current PWM output A status)   */
} AQCTLA_BIT_CAD;

#define AQCTLA_ALL_CAD_DO_NOTHING     ((0x0UL) << AQCTLA_ALL_CAD_Pos)
#define AQCTLA_ALL_CAD_SET_LOW        ((0x1UL) << AQCTLA_ALL_CAD_Pos)
#define AQCTLA_ALL_CAD_SET_HIGH       ((0x2UL) << AQCTLA_ALL_CAD_Pos)
#define AQCTLA_ALL_CAD_TOGGLE         ((0x3UL) << AQCTLA_ALL_CAD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLA          CBU
 *  @access     PWM->AQCTLA.bit.CBU
 *  @brief      Action on output A when TBCNT=CMPB and TBCNT is counting up
 */
#define AQCTLA_ALL_CBU_Pos (8)
#define AQCTLA_ALL_CBU_Msk (0x3UL << AQCTLA_ALL_CBU_Pos)

typedef enum
{
    AQCTLA_BIT_CBU_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLA_BIT_CBU_SET_LOW        = 1,  /*!< Clear (force PWM output A to low)             */
    AQCTLA_BIT_CBU_SET_HIGH       = 2,  /*!< Set (force PWM output A to high)              */
    AQCTLA_BIT_CBU_TOGGLE         = 3,  /*!< Toggle (invert current PWM output A status)   */
} AQCTLA_BIT_CBU;

#define AQCTLA_ALL_CBU_DO_NOTHING     ((0x0UL) << AQCTLA_ALL_CBU_Pos)
#define AQCTLA_ALL_CBU_SET_LOW        ((0x1UL) << AQCTLA_ALL_CBU_Pos)
#define AQCTLA_ALL_CBU_SET_HIGH       ((0x2UL) << AQCTLA_ALL_CBU_Pos)
#define AQCTLA_ALL_CBU_TOGGLE         ((0x3UL) << AQCTLA_ALL_CBU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLA          CBD
 *  @access     PWM->AQCTLA.bit.CBD
 *  @brief      Action on output A when TBCNT=CMPB and TBCNT is counting down
 */
#define AQCTLA_ALL_CBD_Pos (10)
#define AQCTLA_ALL_CBD_Msk (0x3UL << AQCTLA_ALL_CBD_Pos)

typedef enum
{
    AQCTLA_BIT_CBD_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLA_BIT_CBD_SET_LOW        = 1,  /*!< Clear (force PWM output A to low)             */
    AQCTLA_BIT_CBD_SET_HIGH       = 2,  /*!< Set (force PWM output A to high)              */
    AQCTLA_BIT_CBD_TOGGLE         = 3,  /*!< Toggle (invert current PWM output A status)   */
} AQCTLA_BIT_CBD;

#define AQCTLA_ALL_CBD_DO_NOTHING     ((0x0UL) << AQCTLA_ALL_CBD_Pos)
#define AQCTLA_ALL_CBD_SET_LOW        ((0x1UL) << AQCTLA_ALL_CBD_Pos)
#define AQCTLA_ALL_CBD_SET_HIGH       ((0x2UL) << AQCTLA_ALL_CBD_Pos)
#define AQCTLA_ALL_CBD_TOGGLE         ((0x3UL) << AQCTLA_ALL_CBD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLB          ZRO
 *  @access     PWM->AQCTLB.bit.ZRO
 *  @brief      Action on output B when TBCNT=Zero
 */
#define AQCTLB_ALL_ZRO_Pos (0)
#define AQCTLB_ALL_ZRO_Msk (0x3UL << AQCTLB_ALL_ZRO_Pos)

typedef enum
{
    AQCTLB_BIT_ZRO_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLB_BIT_ZRO_SET_LOW        = 1,  /*!< Clear (force PWM output B to low)             */
    AQCTLB_BIT_ZRO_SET_HIGH       = 2,  /*!< Set (force PWM output B to high)              */
    AQCTLB_BIT_ZRO_TOGGLE         = 3,  /*!< Toggle (invert current PWM output B status)   */
} AQCTLB_BIT_ZRO;

#define AQCTLB_ALL_ZRO_DO_NOTHING     ((0x0UL) << AQCTLB_ALL_ZRO_Pos)
#define AQCTLB_ALL_ZRO_SET_LOW        ((0x1UL) << AQCTLB_ALL_ZRO_Pos)
#define AQCTLB_ALL_ZRO_SET_HIGH       ((0x2UL) << AQCTLB_ALL_ZRO_Pos)
#define AQCTLB_ALL_ZRO_TOGGLE         ((0x3UL) << AQCTLB_ALL_ZRO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLB          PRD
 *  @access     PWM->AQCTLB.bit.PRD
 *  @brief      Action on output B when TBCNT=TBPRD
 */
#define AQCTLB_ALL_PRD_Pos (2)
#define AQCTLB_ALL_PRD_Msk (0x3UL << AQCTLB_ALL_PRD_Pos)

typedef enum
{
    AQCTLB_BIT_PRD_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLB_BIT_PRD_SET_LOW        = 1,  /*!< Clear (force PWM output B to low)             */
    AQCTLB_BIT_PRD_SET_HIGH       = 2,  /*!< Set (force PWM output B to high)              */
    AQCTLB_BIT_PRD_TOGGLE         = 3,  /*!< Toggle (invert current PWM output B status)   */
} AQCTLB_BIT_PRD;

#define AQCTLB_ALL_PRD_DO_NOTHING     ((0x0UL) << AQCTLB_ALL_PRD_Pos)
#define AQCTLB_ALL_PRD_SET_LOW        ((0x1UL) << AQCTLB_ALL_PRD_Pos)
#define AQCTLB_ALL_PRD_SET_HIGH       ((0x2UL) << AQCTLB_ALL_PRD_Pos)
#define AQCTLB_ALL_PRD_TOGGLE         ((0x3UL) << AQCTLB_ALL_PRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLB          CAU
 *  @access     PWM->AQCTLB.bit.CAU
 *  @brief      Action on output B when TBCNT=CMPA and TBCNT is counting up
 */
#define AQCTLB_ALL_CAU_Pos (4)
#define AQCTLB_ALL_CAU_Msk (0x3UL << AQCTLB_ALL_CAU_Pos)

typedef enum
{
    AQCTLB_BIT_CAU_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLB_BIT_CAU_SET_LOW        = 1,  /*!< Clear (force PWM output B to low)             */
    AQCTLB_BIT_CAU_SET_HIGH       = 2,  /*!< Set (force PWM output B to high)              */
    AQCTLB_BIT_CAU_TOGGLE         = 3,  /*!< Toggle (invert current PWM output B status)   */
} AQCTLB_BIT_CAU;

#define AQCTLB_ALL_CAU_DO_NOTHING     ((0x0UL) << AQCTLB_ALL_CAU_Pos)
#define AQCTLB_ALL_CAU_SET_LOW        ((0x1UL) << AQCTLB_ALL_CAU_Pos)
#define AQCTLB_ALL_CAU_SET_HIGH       ((0x2UL) << AQCTLB_ALL_CAU_Pos)
#define AQCTLB_ALL_CAU_TOGGLE         ((0x3UL) << AQCTLB_ALL_CAU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLB          CAD
 *  @access     PWM->AQCTLB.bit.CAD
 *  @brief      Action on output B when TBCNT=CMPA and TBCNT is counting down
 */
#define AQCTLB_ALL_CAD_Pos (6)
#define AQCTLB_ALL_CAD_Msk (0x3UL << AQCTLB_ALL_CAD_Pos)

typedef enum
{
    AQCTLB_BIT_CAD_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLB_BIT_CAD_SET_LOW        = 1,  /*!< Clear (force PWM output B to low)             */
    AQCTLB_BIT_CAD_SET_HIGH       = 2,  /*!< Set (force PWM output B to high)              */
    AQCTLB_BIT_CAD_TOGGLE         = 3,  /*!< Toggle (invert current PWM output B status)   */
} AQCTLB_BIT_CAD;

#define AQCTLB_ALL_CAD_DO_NOTHING     ((0x0UL) << AQCTLB_ALL_CAD_Pos)
#define AQCTLB_ALL_CAD_SET_LOW        ((0x1UL) << AQCTLB_ALL_CAD_Pos)
#define AQCTLB_ALL_CAD_SET_HIGH       ((0x2UL) << AQCTLB_ALL_CAD_Pos)
#define AQCTLB_ALL_CAD_TOGGLE         ((0x3UL) << AQCTLB_ALL_CAD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLB          CBU
 *  @access     PWM->AQCTLB.bit.CBU
 *  @brief      Action on output B when TBCNT=CMPB and TBCNT is counting up
 */
#define AQCTLB_ALL_CBU_Pos (8)
#define AQCTLB_ALL_CBU_Msk (0x3UL << AQCTLB_ALL_CBU_Pos)

typedef enum
{
    AQCTLB_BIT_CBU_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLB_BIT_CBU_SET_LOW        = 1,  /*!< Clear (force PWM output B to low)             */
    AQCTLB_BIT_CBU_SET_HIGH       = 2,  /*!< Set (force PWM output B to high)              */
    AQCTLB_BIT_CBU_TOGGLE         = 3,  /*!< Toggle (invert current PWM output B status)   */
} AQCTLB_BIT_CBU;

#define AQCTLB_ALL_CBU_DO_NOTHING     ((0x0UL) << AQCTLB_ALL_CBU_Pos)
#define AQCTLB_ALL_CBU_SET_LOW        ((0x1UL) << AQCTLB_ALL_CBU_Pos)
#define AQCTLB_ALL_CBU_SET_HIGH       ((0x2UL) << AQCTLB_ALL_CBU_Pos)
#define AQCTLB_ALL_CBU_TOGGLE         ((0x3UL) << AQCTLB_ALL_CBU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCTLB          CBD
 *  @access     PWM->AQCTLB.bit.CBD
 *  @brief      Action on output B when TBCNT=CMPA and TBCNT is counting down
 */
#define AQCTLB_ALL_CBD_Pos (10)
#define AQCTLB_ALL_CBD_Msk (0x3UL << AQCTLB_ALL_CBD_Pos)

typedef enum
{
    AQCTLB_BIT_CBD_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQCTLB_BIT_CBD_SET_LOW        = 1,  /*!< Clear (force PWM output B to low)             */
    AQCTLB_BIT_CBD_SET_HIGH       = 2,  /*!< Set (force PWM output B to high)              */
    AQCTLB_BIT_CBD_TOGGLE         = 3,  /*!< Toggle (invert current PWM output B status)   */
} AQCTLB_BIT_CBD;

#define AQCTLB_ALL_CBD_DO_NOTHING     ((0x0UL) << AQCTLB_ALL_CBD_Pos)
#define AQCTLB_ALL_CBD_SET_LOW        ((0x1UL) << AQCTLB_ALL_CBD_Pos)
#define AQCTLB_ALL_CBD_SET_HIGH       ((0x2UL) << AQCTLB_ALL_CBD_Pos)
#define AQCTLB_ALL_CBD_TOGGLE         ((0x3UL) << AQCTLB_ALL_CBD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQSFRC          ACTSFA
 *  @access     PWM->AQSFRC.bit.ACTSFA
 *  @brief      Action when one-time software force A is invoked
 */
#define AQSFRC_ALL_ACTSFA_Pos (0)
#define AQSFRC_ALL_ACTSFA_Msk (0x3UL << AQSFRC_ALL_ACTSFA_Pos)

typedef enum
{
    AQSFRC_BIT_ACTSFA_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQSFRC_BIT_ACTSFA_SET_LOW        = 1,  /*!< Clear (force PWM output A to low              */
    AQSFRC_BIT_ACTSFA_SET_HIGH       = 2,  /*!< Set (force PWM output A to high               */
    AQSFRC_BIT_ACTSFA_TOGGLE         = 3,  /*!< Toggle (invert current PWM output A status)   */
} AQSFRC_BIT_ACTSFA;

#define AQSFRC_ALL_ACTSFA_DO_NOTHING     ((0x0UL) << AQSFRC_ALL_ACTSFA_Pos)
#define AQSFRC_ALL_ACTSFA_SET_LOW        ((0x1UL) << AQSFRC_ALL_ACTSFA_Pos)
#define AQSFRC_ALL_ACTSFA_SET_HIGH       ((0x2UL) << AQSFRC_ALL_ACTSFA_Pos)
#define AQSFRC_ALL_ACTSFA_TOGGLE         ((0x3UL) << AQSFRC_ALL_ACTSFA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQSFRC          OTSFA
 *  @access     PWM->AQSFRC.bit.OTSFA
 *  @brief      One-time software forced event on output A
 *              This bit is auto cleared once a write to it is complete
 */
#define AQSFRC_ALL_OTSFA_Pos (2)
#define AQSFRC_ALL_OTSFA_Msk (0x1UL << AQSFRC_ALL_OTSFA_Pos)

typedef enum
{
    AQSFRC_BIT_OTSFA_NO_EFFECT          = 0,  /*!< Write a 0 has no effect. Always reads back a 0   */
    AQSFRC_BIT_OTSFA_FORCE_ONE_TIME     = 1,  /*!< Initiate a single software forced event          */
} AQSFRC_BIT_OTSFA;

#define AQSFRC_ALL_OTSFA_NO_EFFECT          ((0x0UL) << AQSFRC_ALL_OTSFA_Pos)
#define AQSFRC_ALL_OTSFA_FORCE_ONE_TIME     ((0x1UL) << AQSFRC_ALL_OTSFA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQSFRC          ACTSFB
 *  @access     PWM->AQSFRC.bit.ACTSFB
 *  @brief      Action when one-time software force B is invoked
 */
#define AQSFRC_ALL_ACTSFB_Pos (3)
#define AQSFRC_ALL_ACTSFB_Msk (0x3UL << AQSFRC_ALL_ACTSFB_Pos)

typedef enum
{
    AQSFRC_BIT_ACTSFB_DO_NOTHING     = 0,  /*!< Do nothing (action disabled)                  */
    AQSFRC_BIT_ACTSFB_SET_LOW        = 1,  /*!< Clear (force PWM output B to low              */
    AQSFRC_BIT_ACTSFB_SET_HIGH       = 2,  /*!< Set (force PWM output B to high               */
    AQSFRC_BIT_ACTSFB_TOGGLE         = 3,  /*!< Toggle (invert current PWM output B status)   */
} AQSFRC_BIT_ACTSFB;

#define AQSFRC_ALL_ACTSFB_DO_NOTHING     ((0x0UL) << AQSFRC_ALL_ACTSFB_Pos)
#define AQSFRC_ALL_ACTSFB_SET_LOW        ((0x1UL) << AQSFRC_ALL_ACTSFB_Pos)
#define AQSFRC_ALL_ACTSFB_SET_HIGH       ((0x2UL) << AQSFRC_ALL_ACTSFB_Pos)
#define AQSFRC_ALL_ACTSFB_TOGGLE         ((0x3UL) << AQSFRC_ALL_ACTSFB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQSFRC          OTSFB
 *  @access     PWM->AQSFRC.bit.OTSFB
 *  @brief      One-time software forced event on output B
 *              This bit is auto cleared once a write to it is complete
 */
#define AQSFRC_ALL_OTSFB_Pos (5)
#define AQSFRC_ALL_OTSFB_Msk (0x1UL << AQSFRC_ALL_OTSFB_Pos)

typedef enum
{
    AQSFRC_BIT_OTSFB_NO_EFFECT          = 0,  /*!< Write a 0 has no effect. Always reads back a 0   */
    AQSFRC_BIT_OTSFB_FORCE_ONE_TIME     = 1,  /*!< Initiate a single software forced event          */
} AQSFRC_BIT_OTSFB;

#define AQSFRC_ALL_OTSFB_NO_EFFECT          ((0x0UL) << AQSFRC_ALL_OTSFB_Pos)
#define AQSFRC_ALL_OTSFB_FORCE_ONE_TIME     ((0x1UL) << AQSFRC_ALL_OTSFB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQSFRC          RLDCSF
 *  @access     PWM->AQSFRC.bit.RLDCSF
 *  @brief      Options to load continuous software force register (AQCSFRC) active value from shadow register
 */
#define AQSFRC_ALL_RLDCSF_Pos (6)
#define AQSFRC_ALL_RLDCSF_Msk (0x3UL << AQSFRC_ALL_RLDCSF_Pos)

typedef enum
{
    AQSFRC_BIT_RLDCSF_LOAD_ON_ZERO            = 0,  /*!< Load on TBCNT=Zero                  */
    AQSFRC_BIT_RLDCSF_LOAD_ON_PERIOD          = 1,  /*!< Load on TBCNT=TBPRD                 */
    AQSFRC_BIT_RLDCSF_LOAD_ON_ZERO_PERIOD     = 2,  /*!< Load on TBCNT=Zero or TBCNT=TBPRD   */
    AQSFRC_BIT_RLDCSF_LOAD_IMMEDIATE          = 3,  /*!< Load immediately (No shadowing)     */
} AQSFRC_BIT_RLDCSF;

#define AQSFRC_ALL_RLDCSF_LOAD_ON_ZERO            ((0x0UL) << AQSFRC_ALL_RLDCSF_Pos)
#define AQSFRC_ALL_RLDCSF_LOAD_ON_PERIOD          ((0x1UL) << AQSFRC_ALL_RLDCSF_Pos)
#define AQSFRC_ALL_RLDCSF_LOAD_ON_ZERO_PERIOD     ((0x2UL) << AQSFRC_ALL_RLDCSF_Pos)
#define AQSFRC_ALL_RLDCSF_LOAD_IMMEDIATE          ((0x3UL) << AQSFRC_ALL_RLDCSF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCSFRC         CSFA
 *  @access     PWM->AQCSFRC.bit.CSFA
 *  @brief      Continuous software force on output A
 *              The register can be in immediate mode or shadow mode as determined by AQSFRC.RLDCSF
 */
#define AQCSFRC_ALL_CSFA_Pos (0)
#define AQCSFRC_ALL_CSFA_Msk (0x3UL << AQCSFRC_ALL_CSFA_Pos)

typedef enum
{
    AQCSFRC_BIT_CSFA_NO_EFFECT                 = 0,  /*!< Forcing disabled                      */
    AQCSFRC_BIT_CSFA_FORCE_CONTINUOUS_LOW      = 1,  /*!< Force a continuous low on output A    */
    AQCSFRC_BIT_CSFA_FORCE_CONTINUOUS_HIGH     = 2,  /*!< Force a continuous high on output A   */
    AQCSFRC_BIT_CSFA_DISABLE                   = 3,  /*!< Forcing disabled                      */
} AQCSFRC_BIT_CSFA;

#define AQCSFRC_ALL_CSFA_NO_EFFECT                 ((0x0UL) << AQCSFRC_ALL_CSFA_Pos)
#define AQCSFRC_ALL_CSFA_FORCE_CONTINUOUS_LOW      ((0x1UL) << AQCSFRC_ALL_CSFA_Pos)
#define AQCSFRC_ALL_CSFA_FORCE_CONTINUOUS_HIGH     ((0x2UL) << AQCSFRC_ALL_CSFA_Pos)
#define AQCSFRC_ALL_CSFA_DISABLE                   ((0x3UL) << AQCSFRC_ALL_CSFA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             AQCSFRC         CSFB
 *  @access     PWM->AQCSFRC.bit.CSFB
 *  @brief      Continuous software force on output B
 *              The register can be in immediate mode or shadow mode as determined by AQSFRC.RLDCSF
 */
#define AQCSFRC_ALL_CSFB_Pos (2)
#define AQCSFRC_ALL_CSFB_Msk (0x3UL << AQCSFRC_ALL_CSFB_Pos)

typedef enum
{
    AQCSFRC_BIT_CSFB_NO_EFFECT                 = 0,  /*!< Forcing disabled                      */
    AQCSFRC_BIT_CSFB_FORCE_CONTINUOUS_LOW      = 1,  /*!< Force a continuous low on output B    */
    AQCSFRC_BIT_CSFB_FORCE_CONTINUOUS_HIGH     = 2,  /*!< Force a continuous high on output B   */
    AQCSFRC_BIT_CSFB_DISABLE                   = 3,  /*!< Forcing disabled                      */
} AQCSFRC_BIT_CSFB;

#define AQCSFRC_ALL_CSFB_NO_EFFECT                 ((0x0UL) << AQCSFRC_ALL_CSFB_Pos)
#define AQCSFRC_ALL_CSFB_FORCE_CONTINUOUS_LOW      ((0x1UL) << AQCSFRC_ALL_CSFB_Pos)
#define AQCSFRC_ALL_CSFB_FORCE_CONTINUOUS_HIGH     ((0x2UL) << AQCSFRC_ALL_CSFB_Pos)
#define AQCSFRC_ALL_CSFB_DISABLE                   ((0x3UL) << AQCSFRC_ALL_CSFB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DBCTL           OUTMODE
 *  @access     PWM->DBCTL.bit.OUTMODE
 *  @brief      Dead-band output mode
 */
#define DBCTL_ALL_OUTMODE_Pos (0)
#define DBCTL_ALL_OUTMODE_Msk (0x3UL << DBCTL_ALL_OUTMODE_Pos)

typedef enum
{
    DBCTL_BIT_OUTMODE_0     = 0,  /*!< Dead-band is bypassed for both outputs. Input A and B from the action-qualifier are passed directly to the PWM-chopper submodule.                                     
                                       POLSEL and IN_MODE are not used in this mode.                                                                                                                          */
    DBCTL_BIT_OUTMODE_1     = 1,  /*!< Disable rising-edge delay. Input A from the action-qualifier is directly passed through to the input A of the PWM-chopper submodule.                                  
                                       The falling-edge delay is applied at output B. The input signal for the delay is determined by DBCTL.IN_MODE.                                                          */
    DBCTL_BIT_OUTMODE_2     = 2,  /*!< The rising-edge delay is applied at output A. The input signal for the delay is determined by DBCTL.IN_MODE.                                                          
                                       Disable falling-edge delay. Input B from the action-qualifier is directly passed through to the input B of the PWM-chopper submodule.                                  */
    DBCTL_BIT_OUTMODE_3     = 3,  /*!< Dead-band is fully enabled for both rising-edge delay on output A and falling-edge delay on output B. The input signal for the delay is determined by DBCTL.IN_MODE.   */
} DBCTL_BIT_OUTMODE;

#define DBCTL_ALL_OUTMODE_0     ((0x0UL) << DBCTL_ALL_OUTMODE_Pos)
#define DBCTL_ALL_OUTMODE_1     ((0x1UL) << DBCTL_ALL_OUTMODE_Pos)
#define DBCTL_ALL_OUTMODE_2     ((0x2UL) << DBCTL_ALL_OUTMODE_Pos)
#define DBCTL_ALL_OUTMODE_3     ((0x3UL) << DBCTL_ALL_OUTMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DBCTL           POLSEL
 *  @access     PWM->DBCTL.bit.POLSEL
 *  @brief      Polarity select
 */
#define DBCTL_ALL_POLSEL_Pos (2)
#define DBCTL_ALL_POLSEL_Msk (0x3UL << DBCTL_ALL_POLSEL_Pos)

typedef enum
{
    DBCTL_BIT_POLSEL_MODE_AHH     = 0,  /*!< Neither output A or output B is inverted (default)   */
    DBCTL_BIT_POLSEL_MODE_ALH     = 1,  /*!< Output A is inverted                                 */
    DBCTL_BIT_POLSEL_MODE_AHL     = 2,  /*!< Output B is inverted                                 */
    DBCTL_BIT_POLSEL_MODE_ALL     = 3,  /*!< Both output A and output B are inverted              */
} DBCTL_BIT_POLSEL;

#define DBCTL_ALL_POLSEL_MODE_AHH     ((0x0UL) << DBCTL_ALL_POLSEL_Pos)
#define DBCTL_ALL_POLSEL_MODE_ALH     ((0x1UL) << DBCTL_ALL_POLSEL_Pos)
#define DBCTL_ALL_POLSEL_MODE_AHL     ((0x2UL) << DBCTL_ALL_POLSEL_Pos)
#define DBCTL_ALL_POLSEL_MODE_ALL     ((0x3UL) << DBCTL_ALL_POLSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DBCTL           INMODE
 *  @access     PWM->DBCTL.bit.INMODE
 *  @brief      Dead-band input mode
 */
#define DBCTL_ALL_INMODE_Pos (4)
#define DBCTL_ALL_INMODE_Msk (0x3UL << DBCTL_ALL_INMODE_Pos)

typedef enum
{
    DBCTL_BIT_INMODE_0     = 0,  /*!< Input A is the source for both rising-edge and falling-edge delay   */
    DBCTL_BIT_INMODE_1     = 1,  /*!< Input B is the source for rising-edge delay                        
                                      Input A is the source for falling-edge delay                        */
    DBCTL_BIT_INMODE_2     = 2,  /*!< Input A is the source for rising-edge delay                        
                                      Input B is the source for falling-edge delay                        */
    DBCTL_BIT_INMODE_3     = 3,  /*!< Input B is the source for both rising-edge and falling-edge delay   */
} DBCTL_BIT_INMODE;

#define DBCTL_ALL_INMODE_0     ((0x0UL) << DBCTL_ALL_INMODE_Pos)
#define DBCTL_ALL_INMODE_1     ((0x1UL) << DBCTL_ALL_INMODE_Pos)
#define DBCTL_ALL_INMODE_2     ((0x2UL) << DBCTL_ALL_INMODE_Pos)
#define DBCTL_ALL_INMODE_3     ((0x3UL) << DBCTL_ALL_INMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DBCTL           HALFCYCLE
 *  @access     PWM->DBCTL.bit.HALFCYCLE
 *  @brief      Half cycle clocking enable
 */
#define DBCTL_ALL_HALFCYCLE_Pos (15)
#define DBCTL_ALL_HALFCYCLE_Msk (0x1UL << DBCTL_ALL_HALFCYCLE_Pos)

typedef enum
{
    DBCTL_BIT_HALFCYCLE_DISABLE     = 0,  /*!< Full cycle clocking enabled. The dead-band counter is clocked at TBCLK      */
    DBCTL_BIT_HALFCYCLE_ENABLE      = 1,  /*!< Half cycle clocking enabled. The dead-band counter is clocked at 2x TBCLK   */
} DBCTL_BIT_HALFCYCLE;

#define DBCTL_ALL_HALFCYCLE_DISABLE     ((0x0UL) << DBCTL_ALL_HALFCYCLE_Pos)
#define DBCTL_ALL_HALFCYCLE_ENABLE      ((0x1UL) << DBCTL_ALL_HALFCYCLE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DBRED           VAL
 *  @access     PWM->DBRED.bit.VAL
 *  @brief      Rising-edge delay
 */
#define DBRED_ALL_VAL_Pos (0)
#define DBRED_ALL_VAL_Msk (0x3FFUL << DBRED_ALL_VAL_Pos)

#define DBRED_BIT_VAL

#define DBRED_ALL_VAL_(x) ((x) << DBRED_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DBFED           VAL
 *  @access     PWM->DBFED.bit.VAL
 *  @brief      Falling-edge delay
 */
#define DBFED_ALL_VAL_Pos (0)
#define DBFED_ALL_VAL_Msk (0x3FFUL << DBFED_ALL_VAL_Pos)

#define DBFED_BIT_VAL

#define DBFED_ALL_VAL_(x) ((x) << DBFED_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBC1
 *  @access     PWM->TZSEL.bit.CBC1
 *  @brief      TZ1 as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBC1_Pos (0)
#define TZSEL_ALL_CBC1_Msk (0x1UL << TZSEL_ALL_CBC1_Pos)

typedef enum
{
    TZSEL_BIT_CBC1_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBC1_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBC1;

#define TZSEL_ALL_CBC1_DISABLE     ((0x0UL) << TZSEL_ALL_CBC1_Pos)
#define TZSEL_ALL_CBC1_ENABLE      ((0x1UL) << TZSEL_ALL_CBC1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBC2
 *  @access     PWM->TZSEL.bit.CBC2
 *  @brief      TZ2 as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBC2_Pos (1)
#define TZSEL_ALL_CBC2_Msk (0x1UL << TZSEL_ALL_CBC2_Pos)

typedef enum
{
    TZSEL_BIT_CBC2_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBC2_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBC2;

#define TZSEL_ALL_CBC2_DISABLE     ((0x0UL) << TZSEL_ALL_CBC2_Pos)
#define TZSEL_ALL_CBC2_ENABLE      ((0x1UL) << TZSEL_ALL_CBC2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBC3
 *  @access     PWM->TZSEL.bit.CBC3
 *  @brief      TZ3 as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBC3_Pos (2)
#define TZSEL_ALL_CBC3_Msk (0x1UL << TZSEL_ALL_CBC3_Pos)

typedef enum
{
    TZSEL_BIT_CBC3_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBC3_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBC3;

#define TZSEL_ALL_CBC3_DISABLE     ((0x0UL) << TZSEL_ALL_CBC3_Pos)
#define TZSEL_ALL_CBC3_ENABLE      ((0x1UL) << TZSEL_ALL_CBC3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBC4
 *  @access     PWM->TZSEL.bit.CBC4
 *  @brief      TZ4 as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBC4_Pos (3)
#define TZSEL_ALL_CBC4_Msk (0x1UL << TZSEL_ALL_CBC4_Pos)

typedef enum
{
    TZSEL_BIT_CBC4_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBC4_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBC4;

#define TZSEL_ALL_CBC4_DISABLE     ((0x0UL) << TZSEL_ALL_CBC4_Pos)
#define TZSEL_ALL_CBC4_ENABLE      ((0x1UL) << TZSEL_ALL_CBC4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBC5
 *  @access     PWM->TZSEL.bit.CBC5
 *  @brief      TZ5 as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBC5_Pos (4)
#define TZSEL_ALL_CBC5_Msk (0x1UL << TZSEL_ALL_CBC5_Pos)

typedef enum
{
    TZSEL_BIT_CBC5_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBC5_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBC5;

#define TZSEL_ALL_CBC5_DISABLE     ((0x0UL) << TZSEL_ALL_CBC5_Pos)
#define TZSEL_ALL_CBC5_ENABLE      ((0x1UL) << TZSEL_ALL_CBC5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBCCLKERR
 *  @access     PWM->TZSEL.bit.CBCCLKERR
 *  @brief      CLKDET error as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBCCLKERR_Pos (5)
#define TZSEL_ALL_CBCCLKERR_Msk (0x1UL << TZSEL_ALL_CBCCLKERR_Pos)

typedef enum
{
    TZSEL_BIT_CBCCLKERR_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBCCLKERR_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBCCLKERR;

#define TZSEL_ALL_CBCCLKERR_DISABLE     ((0x0UL) << TZSEL_ALL_CBCCLKERR_Pos)
#define TZSEL_ALL_CBCCLKERR_ENABLE      ((0x1UL) << TZSEL_ALL_CBCCLKERR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           DCAEVT2
 *  @access     PWM->TZSEL.bit.DCAEVT2
 *  @brief      Digital compare output A event 2 as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_DCAEVT2_Pos (6)
#define TZSEL_ALL_DCAEVT2_Msk (0x1UL << TZSEL_ALL_DCAEVT2_Pos)

typedef enum
{
    TZSEL_BIT_DCAEVT2_CBC_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_DCAEVT2_CBC_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_DCAEVT2;

#define TZSEL_ALL_DCAEVT2_CBC_DISABLE     ((0x0UL) << TZSEL_ALL_DCAEVT2_Pos)
#define TZSEL_ALL_DCAEVT2_CBC_ENABLE      ((0x1UL) << TZSEL_ALL_DCAEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           DCBEVT2
 *  @access     PWM->TZSEL.bit.DCBEVT2
 *  @brief      Digital compare output B event 2 as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_DCBEVT2_Pos (7)
#define TZSEL_ALL_DCBEVT2_Msk (0x1UL << TZSEL_ALL_DCBEVT2_Pos)

typedef enum
{
    TZSEL_BIT_DCBEVT2_CBC_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_DCBEVT2_CBC_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_DCBEVT2;

#define TZSEL_ALL_DCBEVT2_CBC_DISABLE     ((0x0UL) << TZSEL_ALL_DCBEVT2_Pos)
#define TZSEL_ALL_DCBEVT2_CBC_ENABLE      ((0x1UL) << TZSEL_ALL_DCBEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHT1
 *  @access     PWM->TZSEL.bit.OSHT1
 *  @brief      TZ1 as a one-shot trip source
 */
#define TZSEL_ALL_OSHT1_Pos (8)
#define TZSEL_ALL_OSHT1_Msk (0x1UL << TZSEL_ALL_OSHT1_Pos)

typedef enum
{
    TZSEL_BIT_OSHT1_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHT1_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHT1;

#define TZSEL_ALL_OSHT1_DISABLE     ((0x0UL) << TZSEL_ALL_OSHT1_Pos)
#define TZSEL_ALL_OSHT1_ENABLE      ((0x1UL) << TZSEL_ALL_OSHT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHT2
 *  @access     PWM->TZSEL.bit.OSHT2
 *  @brief      TZ2 as a one-shot trip source
 */
#define TZSEL_ALL_OSHT2_Pos (9)
#define TZSEL_ALL_OSHT2_Msk (0x1UL << TZSEL_ALL_OSHT2_Pos)

typedef enum
{
    TZSEL_BIT_OSHT2_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHT2_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHT2;

#define TZSEL_ALL_OSHT2_DISABLE     ((0x0UL) << TZSEL_ALL_OSHT2_Pos)
#define TZSEL_ALL_OSHT2_ENABLE      ((0x1UL) << TZSEL_ALL_OSHT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHT3
 *  @access     PWM->TZSEL.bit.OSHT3
 *  @brief      TZ3 as a one-shot trip source
 */
#define TZSEL_ALL_OSHT3_Pos (10)
#define TZSEL_ALL_OSHT3_Msk (0x1UL << TZSEL_ALL_OSHT3_Pos)

typedef enum
{
    TZSEL_BIT_OSHT3_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHT3_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHT3;

#define TZSEL_ALL_OSHT3_DISABLE     ((0x0UL) << TZSEL_ALL_OSHT3_Pos)
#define TZSEL_ALL_OSHT3_ENABLE      ((0x1UL) << TZSEL_ALL_OSHT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHT4
 *  @access     PWM->TZSEL.bit.OSHT4
 *  @brief      TZ4 as a one-shot trip source
 */
#define TZSEL_ALL_OSHT4_Pos (11)
#define TZSEL_ALL_OSHT4_Msk (0x1UL << TZSEL_ALL_OSHT4_Pos)

typedef enum
{
    TZSEL_BIT_OSHT4_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHT4_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHT4;

#define TZSEL_ALL_OSHT4_DISABLE     ((0x0UL) << TZSEL_ALL_OSHT4_Pos)
#define TZSEL_ALL_OSHT4_ENABLE      ((0x1UL) << TZSEL_ALL_OSHT4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHT5
 *  @access     PWM->TZSEL.bit.OSHT5
 *  @brief      TZ5 as a one-shot trip source
 */
#define TZSEL_ALL_OSHT5_Pos (12)
#define TZSEL_ALL_OSHT5_Msk (0x1UL << TZSEL_ALL_OSHT5_Pos)

typedef enum
{
    TZSEL_BIT_OSHT5_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHT5_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHT5;

#define TZSEL_ALL_OSHT5_DISABLE     ((0x0UL) << TZSEL_ALL_OSHT5_Pos)
#define TZSEL_ALL_OSHT5_ENABLE      ((0x1UL) << TZSEL_ALL_OSHT5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHTCLKERR
 *  @access     PWM->TZSEL.bit.OSHTCLKERR
 *  @brief      Clock error as a one-shot trip source
 */
#define TZSEL_ALL_OSHTCLKERR_Pos (13)
#define TZSEL_ALL_OSHTCLKERR_Msk (0x1UL << TZSEL_ALL_OSHTCLKERR_Pos)

typedef enum
{
    TZSEL_BIT_OSHTCLKERR_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHTCLKERR_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHTCLKERR;

#define TZSEL_ALL_OSHTCLKERR_DISABLE     ((0x0UL) << TZSEL_ALL_OSHTCLKERR_Pos)
#define TZSEL_ALL_OSHTCLKERR_ENABLE      ((0x1UL) << TZSEL_ALL_OSHTCLKERR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           DCAEVT1
 *  @access     PWM->TZSEL.bit.DCAEVT1
 *  @brief      Digital compare A event 1 as a one-shot trip source
 */
#define TZSEL_ALL_DCAEVT1_Pos (14)
#define TZSEL_ALL_DCAEVT1_Msk (0x1UL << TZSEL_ALL_DCAEVT1_Pos)

typedef enum
{
    TZSEL_BIT_DCAEVT1_ONESHOT_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_DCAEVT1_ONESHOT_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_DCAEVT1;

#define TZSEL_ALL_DCAEVT1_ONESHOT_DISABLE     ((0x0UL) << TZSEL_ALL_DCAEVT1_Pos)
#define TZSEL_ALL_DCAEVT1_ONESHOT_ENABLE      ((0x1UL) << TZSEL_ALL_DCAEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           DCBEVT1
 *  @access     PWM->TZSEL.bit.DCBEVT1
 *  @brief      Digital compare B event 1 as a one-shot trip source
 */
#define TZSEL_ALL_DCBEVT1_Pos (15)
#define TZSEL_ALL_DCBEVT1_Msk (0x1UL << TZSEL_ALL_DCBEVT1_Pos)

typedef enum
{
    TZSEL_BIT_DCBEVT1_ONESHOT_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_DCBEVT1_ONESHOT_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_DCBEVT1;

#define TZSEL_ALL_DCBEVT1_ONESHOT_DISABLE     ((0x0UL) << TZSEL_ALL_DCBEVT1_Pos)
#define TZSEL_ALL_DCBEVT1_ONESHOT_ENABLE      ((0x1UL) << TZSEL_ALL_DCBEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBCCOMP0H
 *  @access     PWM->TZSEL.bit.CBCCOMP0H
 *  @brief      COMP0H as a cycle-by-cycle  trip source
 */
#define TZSEL_ALL_CBCCOMP0H_Pos (16)
#define TZSEL_ALL_CBCCOMP0H_Msk (0x1UL << TZSEL_ALL_CBCCOMP0H_Pos)

typedef enum
{
    TZSEL_BIT_CBCCOMP0H_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBCCOMP0H_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBCCOMP0H;

#define TZSEL_ALL_CBCCOMP0H_DISABLE     ((0x0UL) << TZSEL_ALL_CBCCOMP0H_Pos)
#define TZSEL_ALL_CBCCOMP0H_ENABLE      ((0x1UL) << TZSEL_ALL_CBCCOMP0H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBCCOMP0L
 *  @access     PWM->TZSEL.bit.CBCCOMP0L
 *  @brief      COMP0L as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBCCOMP0L_Pos (17)
#define TZSEL_ALL_CBCCOMP0L_Msk (0x1UL << TZSEL_ALL_CBCCOMP0L_Pos)

typedef enum
{
    TZSEL_BIT_CBCCOMP0L_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBCCOMP0L_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBCCOMP0L;

#define TZSEL_ALL_CBCCOMP0L_DISABLE     ((0x0UL) << TZSEL_ALL_CBCCOMP0L_Pos)
#define TZSEL_ALL_CBCCOMP0L_ENABLE      ((0x1UL) << TZSEL_ALL_CBCCOMP0L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBCCOMP1H
 *  @access     PWM->TZSEL.bit.CBCCOMP1H
 *  @brief      COMP1H as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBCCOMP1H_Pos (18)
#define TZSEL_ALL_CBCCOMP1H_Msk (0x1UL << TZSEL_ALL_CBCCOMP1H_Pos)

typedef enum
{
    TZSEL_BIT_CBCCOMP1H_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBCCOMP1H_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBCCOMP1H;

#define TZSEL_ALL_CBCCOMP1H_DISABLE     ((0x0UL) << TZSEL_ALL_CBCCOMP1H_Pos)
#define TZSEL_ALL_CBCCOMP1H_ENABLE      ((0x1UL) << TZSEL_ALL_CBCCOMP1H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBCCOMP1L
 *  @access     PWM->TZSEL.bit.CBCCOMP1L
 *  @brief      COMP1L as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBCCOMP1L_Pos (19)
#define TZSEL_ALL_CBCCOMP1L_Msk (0x1UL << TZSEL_ALL_CBCCOMP1L_Pos)

typedef enum
{
    TZSEL_BIT_CBCCOMP1L_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBCCOMP1L_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBCCOMP1L;

#define TZSEL_ALL_CBCCOMP1L_DISABLE     ((0x0UL) << TZSEL_ALL_CBCCOMP1L_Pos)
#define TZSEL_ALL_CBCCOMP1L_ENABLE      ((0x1UL) << TZSEL_ALL_CBCCOMP1L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBCCOMP2H
 *  @access     PWM->TZSEL.bit.CBCCOMP2H
 *  @brief      COMP2H as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBCCOMP2H_Pos (20)
#define TZSEL_ALL_CBCCOMP2H_Msk (0x1UL << TZSEL_ALL_CBCCOMP2H_Pos)

typedef enum
{
    TZSEL_BIT_CBCCOMP2H_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBCCOMP2H_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBCCOMP2H;

#define TZSEL_ALL_CBCCOMP2H_DISABLE     ((0x0UL) << TZSEL_ALL_CBCCOMP2H_Pos)
#define TZSEL_ALL_CBCCOMP2H_ENABLE      ((0x1UL) << TZSEL_ALL_CBCCOMP2H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBCCOMP2L
 *  @access     PWM->TZSEL.bit.CBCCOMP2L
 *  @brief      COMP2L as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBCCOMP2L_Pos (21)
#define TZSEL_ALL_CBCCOMP2L_Msk (0x1UL << TZSEL_ALL_CBCCOMP2L_Pos)

typedef enum
{
    TZSEL_BIT_CBCCOMP2L_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBCCOMP2L_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBCCOMP2L;

#define TZSEL_ALL_CBCCOMP2L_DISABLE     ((0x0UL) << TZSEL_ALL_CBCCOMP2L_Pos)
#define TZSEL_ALL_CBCCOMP2L_ENABLE      ((0x1UL) << TZSEL_ALL_CBCCOMP2L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHTCOMP0H
 *  @access     PWM->TZSEL.bit.OSHTCOMP0H
 *  @brief      COMP0H as a one-shot trip source
 */
#define TZSEL_ALL_OSHTCOMP0H_Pos (22)
#define TZSEL_ALL_OSHTCOMP0H_Msk (0x1UL << TZSEL_ALL_OSHTCOMP0H_Pos)

typedef enum
{
    TZSEL_BIT_OSHTCOMP0H_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHTCOMP0H_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHTCOMP0H;

#define TZSEL_ALL_OSHTCOMP0H_DISABLE     ((0x0UL) << TZSEL_ALL_OSHTCOMP0H_Pos)
#define TZSEL_ALL_OSHTCOMP0H_ENABLE      ((0x1UL) << TZSEL_ALL_OSHTCOMP0H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHTCOMP0L
 *  @access     PWM->TZSEL.bit.OSHTCOMP0L
 *  @brief      COMP0L as a one-shot trip source
 */
#define TZSEL_ALL_OSHTCOMP0L_Pos (23)
#define TZSEL_ALL_OSHTCOMP0L_Msk (0x1UL << TZSEL_ALL_OSHTCOMP0L_Pos)

typedef enum
{
    TZSEL_BIT_OSHTCOMP0L_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHTCOMP0L_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHTCOMP0L;

#define TZSEL_ALL_OSHTCOMP0L_DISABLE     ((0x0UL) << TZSEL_ALL_OSHTCOMP0L_Pos)
#define TZSEL_ALL_OSHTCOMP0L_ENABLE      ((0x1UL) << TZSEL_ALL_OSHTCOMP0L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHTCOMP1H
 *  @access     PWM->TZSEL.bit.OSHTCOMP1H
 *  @brief      COMP1H as a one-shot trip source
 */
#define TZSEL_ALL_OSHTCOMP1H_Pos (24)
#define TZSEL_ALL_OSHTCOMP1H_Msk (0x1UL << TZSEL_ALL_OSHTCOMP1H_Pos)

typedef enum
{
    TZSEL_BIT_OSHTCOMP1H_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHTCOMP1H_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHTCOMP1H;

#define TZSEL_ALL_OSHTCOMP1H_DISABLE     ((0x0UL) << TZSEL_ALL_OSHTCOMP1H_Pos)
#define TZSEL_ALL_OSHTCOMP1H_ENABLE      ((0x1UL) << TZSEL_ALL_OSHTCOMP1H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHTCOMP1L
 *  @access     PWM->TZSEL.bit.OSHTCOMP1L
 *  @brief      COMP1L as a one-shot trip source
 */
#define TZSEL_ALL_OSHTCOMP1L_Pos (25)
#define TZSEL_ALL_OSHTCOMP1L_Msk (0x1UL << TZSEL_ALL_OSHTCOMP1L_Pos)

typedef enum
{
    TZSEL_BIT_OSHTCOMP1L_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHTCOMP1L_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHTCOMP1L;

#define TZSEL_ALL_OSHTCOMP1L_DISABLE     ((0x0UL) << TZSEL_ALL_OSHTCOMP1L_Pos)
#define TZSEL_ALL_OSHTCOMP1L_ENABLE      ((0x1UL) << TZSEL_ALL_OSHTCOMP1L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHTCOMP2H
 *  @access     PWM->TZSEL.bit.OSHTCOMP2H
 *  @brief      COMP2H as a one-shot trip source
 */
#define TZSEL_ALL_OSHTCOMP2H_Pos (26)
#define TZSEL_ALL_OSHTCOMP2H_Msk (0x1UL << TZSEL_ALL_OSHTCOMP2H_Pos)

typedef enum
{
    TZSEL_BIT_OSHTCOMP2H_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHTCOMP2H_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHTCOMP2H;

#define TZSEL_ALL_OSHTCOMP2H_DISABLE     ((0x0UL) << TZSEL_ALL_OSHTCOMP2H_Pos)
#define TZSEL_ALL_OSHTCOMP2H_ENABLE      ((0x1UL) << TZSEL_ALL_OSHTCOMP2H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHTCOMP2L
 *  @access     PWM->TZSEL.bit.OSHTCOMP2L
 *  @brief      COMP2L as a one-shot trip
 */
#define TZSEL_ALL_OSHTCOMP2L_Pos (27)
#define TZSEL_ALL_OSHTCOMP2L_Msk (0x1UL << TZSEL_ALL_OSHTCOMP2L_Pos)

typedef enum
{
    TZSEL_BIT_OSHTCOMP2L_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHTCOMP2L_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHTCOMP2L;

#define TZSEL_ALL_OSHTCOMP2L_DISABLE     ((0x0UL) << TZSEL_ALL_OSHTCOMP2L_Pos)
#define TZSEL_ALL_OSHTCOMP2L_ENABLE      ((0x1UL) << TZSEL_ALL_OSHTCOMP2L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           CBCDBG
 *  @access     PWM->TZSEL.bit.CBCDBG
 *  @brief      EMUSTOP as a cycle-by-cycle trip source
 */
#define TZSEL_ALL_CBCDBG_Pos (28)
#define TZSEL_ALL_CBCDBG_Msk (0x1UL << TZSEL_ALL_CBCDBG_Pos)

typedef enum
{
    TZSEL_BIT_CBCDBG_DEBUG_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_CBCDBG_DEBUG_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_CBCDBG;

#define TZSEL_ALL_CBCDBG_DEBUG_DISABLE     ((0x0UL) << TZSEL_ALL_CBCDBG_Pos)
#define TZSEL_ALL_CBCDBG_DEBUG_ENABLE      ((0x1UL) << TZSEL_ALL_CBCDBG_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZSEL           OSHTDBG
 *  @access     PWM->TZSEL.bit.OSHTDBG
 *  @brief      EMUSTOP as a one-shot trip source
 */
#define TZSEL_ALL_OSHTDBG_Pos (29)
#define TZSEL_ALL_OSHTDBG_Msk (0x1UL << TZSEL_ALL_OSHTDBG_Pos)

typedef enum
{
    TZSEL_BIT_OSHTDBG_DEBUG_DISABLE     = 0,  /*!< Disable   */
    TZSEL_BIT_OSHTDBG_DEBUG_ENABLE      = 1,  /*!< Enable    */
} TZSEL_BIT_OSHTDBG;

#define TZSEL_ALL_OSHTDBG_DEBUG_DISABLE     ((0x0UL) << TZSEL_ALL_OSHTDBG_Pos)
#define TZSEL_ALL_OSHTDBG_DEBUG_ENABLE      ((0x1UL) << TZSEL_ALL_OSHTDBG_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCTL           TZA
 *  @access     PWM->TZCTL.bit.TZA
 *  @brief      Action on output A when a trip event occurs
 */
#define TZCTL_ALL_TZA_Pos (0)
#define TZCTL_ALL_TZA_Msk (0x3UL << TZCTL_ALL_TZA_Pos)

typedef enum
{
    TZCTL_BIT_TZA_TRI_STATE      = 0,  /*!< Set output A to high-impedance   */
    TZCTL_BIT_TZA_SET_HIGH       = 1,  /*!< Force output A to high state     */
    TZCTL_BIT_TZA_SET_LOW        = 2,  /*!< Force output A to low state      */
    TZCTL_BIT_TZA_DO_NOTHING     = 3,  /*!< Do nothing for output A          */
} TZCTL_BIT_TZA;

#define TZCTL_ALL_TZA_TRI_STATE      ((0x0UL) << TZCTL_ALL_TZA_Pos)
#define TZCTL_ALL_TZA_SET_HIGH       ((0x1UL) << TZCTL_ALL_TZA_Pos)
#define TZCTL_ALL_TZA_SET_LOW        ((0x2UL) << TZCTL_ALL_TZA_Pos)
#define TZCTL_ALL_TZA_DO_NOTHING     ((0x3UL) << TZCTL_ALL_TZA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCTL           TZB
 *  @access     PWM->TZCTL.bit.TZB
 *  @brief      Action on output B when a trip event occurs
 */
#define TZCTL_ALL_TZB_Pos (2)
#define TZCTL_ALL_TZB_Msk (0x3UL << TZCTL_ALL_TZB_Pos)

typedef enum
{
    TZCTL_BIT_TZB_TRI_STATE      = 0,  /*!< Set output B to high-impedance   */
    TZCTL_BIT_TZB_SET_HIGH       = 1,  /*!< Force output B to high state     */
    TZCTL_BIT_TZB_SET_LOW        = 2,  /*!< Force output B to low state      */
    TZCTL_BIT_TZB_DO_NOTHING     = 3,  /*!< Do nothing for output B          */
} TZCTL_BIT_TZB;

#define TZCTL_ALL_TZB_TRI_STATE      ((0x0UL) << TZCTL_ALL_TZB_Pos)
#define TZCTL_ALL_TZB_SET_HIGH       ((0x1UL) << TZCTL_ALL_TZB_Pos)
#define TZCTL_ALL_TZB_SET_LOW        ((0x2UL) << TZCTL_ALL_TZB_Pos)
#define TZCTL_ALL_TZB_DO_NOTHING     ((0x3UL) << TZCTL_ALL_TZB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCTL           DCAEVT1
 *  @access     PWM->TZCTL.bit.DCAEVT1
 *  @brief      Action on output A when a digital compare A event 1 occurs
 */
#define TZCTL_ALL_DCAEVT1_Pos (4)
#define TZCTL_ALL_DCAEVT1_Msk (0x3UL << TZCTL_ALL_DCAEVT1_Pos)

typedef enum
{
    TZCTL_BIT_DCAEVT1_TRI_STATE      = 0,  /*!< Set output A to high-impedance   */
    TZCTL_BIT_DCAEVT1_SET_HIGH       = 1,  /*!< Force output A to high state     */
    TZCTL_BIT_DCAEVT1_SET_LOW        = 2,  /*!< Force output A to low state      */
    TZCTL_BIT_DCAEVT1_DO_NOTHING     = 3,  /*!< Do nothing for output A          */
} TZCTL_BIT_DCAEVT1;

#define TZCTL_ALL_DCAEVT1_TRI_STATE      ((0x0UL) << TZCTL_ALL_DCAEVT1_Pos)
#define TZCTL_ALL_DCAEVT1_SET_HIGH       ((0x1UL) << TZCTL_ALL_DCAEVT1_Pos)
#define TZCTL_ALL_DCAEVT1_SET_LOW        ((0x2UL) << TZCTL_ALL_DCAEVT1_Pos)
#define TZCTL_ALL_DCAEVT1_DO_NOTHING     ((0x3UL) << TZCTL_ALL_DCAEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCTL           DCAEVT2
 *  @access     PWM->TZCTL.bit.DCAEVT2
 *  @brief      Action on output A when a digital compare A event 2 occurs
 */
#define TZCTL_ALL_DCAEVT2_Pos (6)
#define TZCTL_ALL_DCAEVT2_Msk (0x3UL << TZCTL_ALL_DCAEVT2_Pos)

typedef enum
{
    TZCTL_BIT_DCAEVT2_TRI_STATE      = 0,  /*!< Set output A to high-impedance   */
    TZCTL_BIT_DCAEVT2_SET_HIGH       = 1,  /*!< Force output A to high state     */
    TZCTL_BIT_DCAEVT2_SET_LOW        = 2,  /*!< Force output A to low state      */
    TZCTL_BIT_DCAEVT2_DO_NOTHING     = 3,  /*!< Do nothing for output A          */
} TZCTL_BIT_DCAEVT2;

#define TZCTL_ALL_DCAEVT2_TRI_STATE      ((0x0UL) << TZCTL_ALL_DCAEVT2_Pos)
#define TZCTL_ALL_DCAEVT2_SET_HIGH       ((0x1UL) << TZCTL_ALL_DCAEVT2_Pos)
#define TZCTL_ALL_DCAEVT2_SET_LOW        ((0x2UL) << TZCTL_ALL_DCAEVT2_Pos)
#define TZCTL_ALL_DCAEVT2_DO_NOTHING     ((0x3UL) << TZCTL_ALL_DCAEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCTL           DCBEVT1
 *  @access     PWM->TZCTL.bit.DCBEVT1
 *  @brief      Action on output B when a digital compare B event 1 occurs
 */
#define TZCTL_ALL_DCBEVT1_Pos (8)
#define TZCTL_ALL_DCBEVT1_Msk (0x3UL << TZCTL_ALL_DCBEVT1_Pos)

typedef enum
{
    TZCTL_BIT_DCBEVT1_TRI_STATE      = 0,  /*!< Set output B to high-impedance   */
    TZCTL_BIT_DCBEVT1_SET_HIGH       = 1,  /*!< Force output B to high state     */
    TZCTL_BIT_DCBEVT1_SET_LOW        = 2,  /*!< Force output B to low state      */
    TZCTL_BIT_DCBEVT1_DO_NOTHING     = 3,  /*!< Do nothing for output B          */
} TZCTL_BIT_DCBEVT1;

#define TZCTL_ALL_DCBEVT1_TRI_STATE      ((0x0UL) << TZCTL_ALL_DCBEVT1_Pos)
#define TZCTL_ALL_DCBEVT1_SET_HIGH       ((0x1UL) << TZCTL_ALL_DCBEVT1_Pos)
#define TZCTL_ALL_DCBEVT1_SET_LOW        ((0x2UL) << TZCTL_ALL_DCBEVT1_Pos)
#define TZCTL_ALL_DCBEVT1_DO_NOTHING     ((0x3UL) << TZCTL_ALL_DCBEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCTL           DCBEVT2
 *  @access     PWM->TZCTL.bit.DCBEVT2
 *  @brief      Action on output B when a digital compare B event 2 occurs
 */
#define TZCTL_ALL_DCBEVT2_Pos (10)
#define TZCTL_ALL_DCBEVT2_Msk (0x3UL << TZCTL_ALL_DCBEVT2_Pos)

typedef enum
{
    TZCTL_BIT_DCBEVT2_TRI_STATE      = 0,  /*!< Set output B to high-impedance   */
    TZCTL_BIT_DCBEVT2_SET_HIGH       = 1,  /*!< Force output B to high state     */
    TZCTL_BIT_DCBEVT2_SET_LOW        = 2,  /*!< Force output B to low state      */
    TZCTL_BIT_DCBEVT2_DO_NOTHING     = 3,  /*!< Do nothing for output B          */
} TZCTL_BIT_DCBEVT2;

#define TZCTL_ALL_DCBEVT2_TRI_STATE      ((0x0UL) << TZCTL_ALL_DCBEVT2_Pos)
#define TZCTL_ALL_DCBEVT2_SET_HIGH       ((0x1UL) << TZCTL_ALL_DCBEVT2_Pos)
#define TZCTL_ALL_DCBEVT2_SET_LOW        ((0x2UL) << TZCTL_ALL_DCBEVT2_Pos)
#define TZCTL_ALL_DCBEVT2_DO_NOTHING     ((0x3UL) << TZCTL_ALL_DCBEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZIE            CBC
 *  @access     PWM->TZIE.bit.CBC
 *  @brief      Cycle-by-cycle trip-zone interrupt
 */
#define TZIE_ALL_CBC_Pos (1)
#define TZIE_ALL_CBC_Msk (0x1UL << TZIE_ALL_CBC_Pos)

typedef enum
{
    TZIE_BIT_CBC_DISABLE     = 0,  /*!< Disable   */
    TZIE_BIT_CBC_ENABLE      = 1,  /*!< Enable    */
} TZIE_BIT_CBC;

#define TZIE_ALL_CBC_DISABLE     ((0x0UL) << TZIE_ALL_CBC_Pos)
#define TZIE_ALL_CBC_ENABLE      ((0x1UL) << TZIE_ALL_CBC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZIE            OST
 *  @access     PWM->TZIE.bit.OST
 *  @brief      One-shot trip-zone interrupt
 */
#define TZIE_ALL_OST_Pos (2)
#define TZIE_ALL_OST_Msk (0x1UL << TZIE_ALL_OST_Pos)

typedef enum
{
    TZIE_BIT_OST_DISABLE     = 0,  /*!< Disable   */
    TZIE_BIT_OST_ENABLE      = 1,  /*!< Enable    */
} TZIE_BIT_OST;

#define TZIE_ALL_OST_DISABLE     ((0x0UL) << TZIE_ALL_OST_Pos)
#define TZIE_ALL_OST_ENABLE      ((0x1UL) << TZIE_ALL_OST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZIE            DCAEVT1
 *  @access     PWM->TZIE.bit.DCAEVT1
 *  @brief      Digital compare A event 1 interrupt
 */
#define TZIE_ALL_DCAEVT1_Pos (3)
#define TZIE_ALL_DCAEVT1_Msk (0x1UL << TZIE_ALL_DCAEVT1_Pos)

typedef enum
{
    TZIE_BIT_DCAEVT1_DISABLE     = 0,  /*!< Disable   */
    TZIE_BIT_DCAEVT1_ENABLE      = 1,  /*!< Enable    */
} TZIE_BIT_DCAEVT1;

#define TZIE_ALL_DCAEVT1_DISABLE     ((0x0UL) << TZIE_ALL_DCAEVT1_Pos)
#define TZIE_ALL_DCAEVT1_ENABLE      ((0x1UL) << TZIE_ALL_DCAEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZIE            DCAEVT2
 *  @access     PWM->TZIE.bit.DCAEVT2
 *  @brief      Digital compare A event 2 interrupt
 */
#define TZIE_ALL_DCAEVT2_Pos (4)
#define TZIE_ALL_DCAEVT2_Msk (0x1UL << TZIE_ALL_DCAEVT2_Pos)

typedef enum
{
    TZIE_BIT_DCAEVT2_DISABLE     = 0,  /*!< Disable   */
    TZIE_BIT_DCAEVT2_ENABLE      = 1,  /*!< Enable    */
} TZIE_BIT_DCAEVT2;

#define TZIE_ALL_DCAEVT2_DISABLE     ((0x0UL) << TZIE_ALL_DCAEVT2_Pos)
#define TZIE_ALL_DCAEVT2_ENABLE      ((0x1UL) << TZIE_ALL_DCAEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZIE            DCBEVT1
 *  @access     PWM->TZIE.bit.DCBEVT1
 *  @brief      Digital compare B event 1 interrupt
 */
#define TZIE_ALL_DCBEVT1_Pos (5)
#define TZIE_ALL_DCBEVT1_Msk (0x1UL << TZIE_ALL_DCBEVT1_Pos)

typedef enum
{
    TZIE_BIT_DCBEVT1_DISABLE     = 0,  /*!< Disable   */
    TZIE_BIT_DCBEVT1_ENABLE      = 1,  /*!< Enable    */
} TZIE_BIT_DCBEVT1;

#define TZIE_ALL_DCBEVT1_DISABLE     ((0x0UL) << TZIE_ALL_DCBEVT1_Pos)
#define TZIE_ALL_DCBEVT1_ENABLE      ((0x1UL) << TZIE_ALL_DCBEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZIE            DCBEVT2
 *  @access     PWM->TZIE.bit.DCBEVT2
 *  @brief      Digital compare B event 2 interrupt
 */
#define TZIE_ALL_DCBEVT2_Pos (6)
#define TZIE_ALL_DCBEVT2_Msk (0x1UL << TZIE_ALL_DCBEVT2_Pos)

typedef enum
{
    TZIE_BIT_DCBEVT2_DISABLE     = 0,  /*!< Disable   */
    TZIE_BIT_DCBEVT2_ENABLE      = 1,  /*!< Enable    */
} TZIE_BIT_DCBEVT2;

#define TZIE_ALL_DCBEVT2_DISABLE     ((0x0UL) << TZIE_ALL_DCBEVT2_Pos)
#define TZIE_ALL_DCBEVT2_ENABLE      ((0x1UL) << TZIE_ALL_DCBEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFLG           INT
 *  @access     PWM->TZFLG.bit.INT
 *  @brief      Latched trip interrupt status flag
 */
#define TZFLG_ALL_INT_Pos (0)
#define TZFLG_ALL_INT_Msk (0x1UL << TZFLG_ALL_INT_Pos)

typedef enum
{
    TZFLG_BIT_INT_NOT_OCCUR     = 0,  /*!< No interrupt has been generated                                                                                                                                                                                                                    */
    TZFLG_BIT_INT_OCCUR         = 1,  /*!< Trip-zone interrupt was generated. No further trip-zone interrupt will be generated until this flag is cleared by writing 1 to TZCLR.INT. If eigher CBC or OST flag is set, another interrupt pulse will be generated when this flag is cleared.   */
} TZFLG_BIT_INT;

#define TZFLG_ALL_INT_NOT_OCCUR     ((0x0UL) << TZFLG_ALL_INT_Pos)
#define TZFLG_ALL_INT_OCCUR         ((0x1UL) << TZFLG_ALL_INT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFLG           CBC
 *  @access     PWM->TZFLG.bit.CBC
 *  @brief      Latched cycle-by-cycle trip event status flag
 */
#define TZFLG_ALL_CBC_Pos (1)
#define TZFLG_ALL_CBC_Msk (0x1UL << TZFLG_ALL_CBC_Pos)

typedef enum
{
    TZFLG_BIT_CBC_NOT_OCCUR     = 0,  /*!< No cycle-by-cycle trip event has occurred                                                                                                                                                                                         */
    TZFLG_BIT_CBC_OCCUR         = 1,  /*!< A cycle-by-cycle trip event occurred. It will remain set until it is manually cleared by wring 1 to TZCLR.CBC. If the cycle-by-cycle trip event is still present when the CBC bit is cleared, it will be immediately set agian.   */
} TZFLG_BIT_CBC;

#define TZFLG_ALL_CBC_NOT_OCCUR     ((0x0UL) << TZFLG_ALL_CBC_Pos)
#define TZFLG_ALL_CBC_OCCUR         ((0x1UL) << TZFLG_ALL_CBC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFLG           OST
 *  @access     PWM->TZFLG.bit.OST
 *  @brief      Latched one-shot trip event status flag
 */
#define TZFLG_ALL_OST_Pos (2)
#define TZFLG_ALL_OST_Msk (0x1UL << TZFLG_ALL_OST_Pos)

typedef enum
{
    TZFLG_BIT_OST_NOT_OCCUR     = 0,  /*!< No one-shot trip event has occurred                                        */
    TZFLG_BIT_OST_OCCUR         = 1,  /*!< A one-shot trip event occurred. It is cleared by writing 1 to TZCLR.OST.   */
} TZFLG_BIT_OST;

#define TZFLG_ALL_OST_NOT_OCCUR     ((0x0UL) << TZFLG_ALL_OST_Pos)
#define TZFLG_ALL_OST_OCCUR         ((0x1UL) << TZFLG_ALL_OST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFLG           DCAEVT1
 *  @access     PWM->TZFLG.bit.DCAEVT1
 *  @brief      Latched digital compare A event 1 status flag
 */
#define TZFLG_ALL_DCAEVT1_Pos (3)
#define TZFLG_ALL_DCAEVT1_Msk (0x1UL << TZFLG_ALL_DCAEVT1_Pos)

typedef enum
{
    TZFLG_BIT_DCAEVT1_NOT_OCCUR     = 0,  /*!< No comprator A event 1 has occurred                                               */
    TZFLG_BIT_DCAEVT1_OCCUR         = 1,  /*!< Comparator A event 1 has occurred. It is cleared by writing 1 to TZCLR.DCAEVT1.   */
} TZFLG_BIT_DCAEVT1;

#define TZFLG_ALL_DCAEVT1_NOT_OCCUR     ((0x0UL) << TZFLG_ALL_DCAEVT1_Pos)
#define TZFLG_ALL_DCAEVT1_OCCUR         ((0x1UL) << TZFLG_ALL_DCAEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFLG           DCAEVT2
 *  @access     PWM->TZFLG.bit.DCAEVT2
 *  @brief      Latched digital compare A event 2 status flag
 */
#define TZFLG_ALL_DCAEVT2_Pos (4)
#define TZFLG_ALL_DCAEVT2_Msk (0x1UL << TZFLG_ALL_DCAEVT2_Pos)

typedef enum
{
    TZFLG_BIT_DCAEVT2_NOT_OCCUR     = 0,  /*!< No comprator A event 2 has occurred                                               */
    TZFLG_BIT_DCAEVT2_OCCUR         = 1,  /*!< Comparator A event 2 has occurred. It is cleared by writing 1 to TZCLR.DCAEVT2.   */
} TZFLG_BIT_DCAEVT2;

#define TZFLG_ALL_DCAEVT2_NOT_OCCUR     ((0x0UL) << TZFLG_ALL_DCAEVT2_Pos)
#define TZFLG_ALL_DCAEVT2_OCCUR         ((0x1UL) << TZFLG_ALL_DCAEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFLG           DCBEVT1
 *  @access     PWM->TZFLG.bit.DCBEVT1
 *  @brief      Latched digital compare B event 1 status flag
 */
#define TZFLG_ALL_DCBEVT1_Pos (5)
#define TZFLG_ALL_DCBEVT1_Msk (0x1UL << TZFLG_ALL_DCBEVT1_Pos)

typedef enum
{
    TZFLG_BIT_DCBEVT1_NOT_OCCUR     = 0,  /*!< No comprator B event 1 has occurred                                               */
    TZFLG_BIT_DCBEVT1_OCCUR         = 1,  /*!< Comparator B event 1 has occurred. It is cleared by writing 1 to TZCLR.DCBEVT1.   */
} TZFLG_BIT_DCBEVT1;

#define TZFLG_ALL_DCBEVT1_NOT_OCCUR     ((0x0UL) << TZFLG_ALL_DCBEVT1_Pos)
#define TZFLG_ALL_DCBEVT1_OCCUR         ((0x1UL) << TZFLG_ALL_DCBEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFLG           DCBEVT2
 *  @access     PWM->TZFLG.bit.DCBEVT2
 *  @brief      Latched digital compare B event 2 status flag
 */
#define TZFLG_ALL_DCBEVT2_Pos (6)
#define TZFLG_ALL_DCBEVT2_Msk (0x1UL << TZFLG_ALL_DCBEVT2_Pos)

typedef enum
{
    TZFLG_BIT_DCBEVT2_NOT_OCCUR     = 0,  /*!< No comprator B event 2 has occurred                                               */
    TZFLG_BIT_DCBEVT2_OCCUR         = 1,  /*!< Comparator B event 2 has occurred. It is cleared by writing 1 to TZCLR.DCBEVT2.   */
} TZFLG_BIT_DCBEVT2;

#define TZFLG_ALL_DCBEVT2_NOT_OCCUR     ((0x0UL) << TZFLG_ALL_DCBEVT2_Pos)
#define TZFLG_ALL_DCBEVT2_OCCUR         ((0x1UL) << TZFLG_ALL_DCBEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCLR           INT
 *  @access     PWM->TZCLR.bit.INT
 *  @brief      Clear global interrupt status flag
 */
#define TZCLR_ALL_INT_Pos (0)
#define TZCLR_ALL_INT_Msk (0x1UL << TZCLR_ALL_INT_Pos)

typedef enum
{
    TZCLR_BIT_INT_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    TZCLR_BIT_INT_CLEAR_FLAG     = 1,  /*!< Write a 1 clears TZFLG.INT                          */
} TZCLR_BIT_INT;

#define TZCLR_ALL_INT_NO_EFFECT      ((0x0UL) << TZCLR_ALL_INT_Pos)
#define TZCLR_ALL_INT_CLEAR_FLAG     ((0x1UL) << TZCLR_ALL_INT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCLR           CBC
 *  @access     PWM->TZCLR.bit.CBC
 *  @brief      Clear cycle-by-cycle trip status flag
 */
#define TZCLR_ALL_CBC_Pos (1)
#define TZCLR_ALL_CBC_Msk (0x1UL << TZCLR_ALL_CBC_Pos)

typedef enum
{
    TZCLR_BIT_CBC_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    TZCLR_BIT_CBC_CLEAR_FLAG     = 1,  /*!< Write a 1 clears TZFLG.CBC                          */
} TZCLR_BIT_CBC;

#define TZCLR_ALL_CBC_NO_EFFECT      ((0x0UL) << TZCLR_ALL_CBC_Pos)
#define TZCLR_ALL_CBC_CLEAR_FLAG     ((0x1UL) << TZCLR_ALL_CBC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCLR           OST
 *  @access     PWM->TZCLR.bit.OST
 *  @brief      Clear one-shot trip status flag
 */
#define TZCLR_ALL_OST_Pos (2)
#define TZCLR_ALL_OST_Msk (0x1UL << TZCLR_ALL_OST_Pos)

typedef enum
{
    TZCLR_BIT_OST_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    TZCLR_BIT_OST_CLEAR_FLAG     = 1,  /*!< Write a 1 clears TZFLG.OST                          */
} TZCLR_BIT_OST;

#define TZCLR_ALL_OST_NO_EFFECT      ((0x0UL) << TZCLR_ALL_OST_Pos)
#define TZCLR_ALL_OST_CLEAR_FLAG     ((0x1UL) << TZCLR_ALL_OST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCLR           DCAEVT1
 *  @access     PWM->TZCLR.bit.DCAEVT1
 *  @brief      Clear digital compare A event 1 status flag
 */
#define TZCLR_ALL_DCAEVT1_Pos (3)
#define TZCLR_ALL_DCAEVT1_Msk (0x1UL << TZCLR_ALL_DCAEVT1_Pos)

typedef enum
{
    TZCLR_BIT_DCAEVT1_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    TZCLR_BIT_DCAEVT1_CLEAR_FLAG     = 1,  /*!< Write a 1 clears TZFLG.DCAEVT1                      */
} TZCLR_BIT_DCAEVT1;

#define TZCLR_ALL_DCAEVT1_NO_EFFECT      ((0x0UL) << TZCLR_ALL_DCAEVT1_Pos)
#define TZCLR_ALL_DCAEVT1_CLEAR_FLAG     ((0x1UL) << TZCLR_ALL_DCAEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCLR           DCAEVT2
 *  @access     PWM->TZCLR.bit.DCAEVT2
 *  @brief      Clear digital compare A event 2 status flag
 */
#define TZCLR_ALL_DCAEVT2_Pos (4)
#define TZCLR_ALL_DCAEVT2_Msk (0x1UL << TZCLR_ALL_DCAEVT2_Pos)

typedef enum
{
    TZCLR_BIT_DCAEVT2_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    TZCLR_BIT_DCAEVT2_CLEAR_FLAG     = 1,  /*!< Write a 1 clears TZFLG.DCAEVT2                      */
} TZCLR_BIT_DCAEVT2;

#define TZCLR_ALL_DCAEVT2_NO_EFFECT      ((0x0UL) << TZCLR_ALL_DCAEVT2_Pos)
#define TZCLR_ALL_DCAEVT2_CLEAR_FLAG     ((0x1UL) << TZCLR_ALL_DCAEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCLR           DCBEVT1
 *  @access     PWM->TZCLR.bit.DCBEVT1
 *  @brief      Clear digital compare B event 1 status flag
 */
#define TZCLR_ALL_DCBEVT1_Pos (5)
#define TZCLR_ALL_DCBEVT1_Msk (0x1UL << TZCLR_ALL_DCBEVT1_Pos)

typedef enum
{
    TZCLR_BIT_DCBEVT1_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    TZCLR_BIT_DCBEVT1_CLEAR_FLAG     = 1,  /*!< Write a 1 clears TZFLG.DCBEVT1                      */
} TZCLR_BIT_DCBEVT1;

#define TZCLR_ALL_DCBEVT1_NO_EFFECT      ((0x0UL) << TZCLR_ALL_DCBEVT1_Pos)
#define TZCLR_ALL_DCBEVT1_CLEAR_FLAG     ((0x1UL) << TZCLR_ALL_DCBEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZCLR           DCBEVT2
 *  @access     PWM->TZCLR.bit.DCBEVT2
 *  @brief      Clear digital compare B event 2 status flag
 */
#define TZCLR_ALL_DCBEVT2_Pos (6)
#define TZCLR_ALL_DCBEVT2_Msk (0x1UL << TZCLR_ALL_DCBEVT2_Pos)

typedef enum
{
    TZCLR_BIT_DCBEVT2_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    TZCLR_BIT_DCBEVT2_CLEAR_FLAG     = 1,  /*!< Write a 1 clears TZFLG.DCBEVT2                      */
} TZCLR_BIT_DCBEVT2;

#define TZCLR_ALL_DCBEVT2_NO_EFFECT      ((0x0UL) << TZCLR_ALL_DCBEVT2_Pos)
#define TZCLR_ALL_DCBEVT2_CLEAR_FLAG     ((0x1UL) << TZCLR_ALL_DCBEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFRC           CBC
 *  @access     PWM->TZFRC.bit.CBC
 *  @brief      Software force a cycle-by-cycle trip event
 */
#define TZFRC_ALL_CBC_Pos (1)
#define TZFRC_ALL_CBC_Msk (0x1UL << TZFRC_ALL_CBC_Pos)

typedef enum
{
    TZFRC_BIT_CBC_NO_EFFECT       = 0,  /*!< Write a 0 has no effect and always reads back a 0                 */
    TZFRC_BIT_CBC_FORCE_EVENT     = 1,  /*!< Write a 1 forces a cycle-by-cycle trip event and sets TZFLG.CBC   */
} TZFRC_BIT_CBC;

#define TZFRC_ALL_CBC_NO_EFFECT       ((0x0UL) << TZFRC_ALL_CBC_Pos)
#define TZFRC_ALL_CBC_FORCE_EVENT     ((0x1UL) << TZFRC_ALL_CBC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFRC           OST
 *  @access     PWM->TZFRC.bit.OST
 *  @brief      Software force a one-shot trip event
 */
#define TZFRC_ALL_OST_Pos (2)
#define TZFRC_ALL_OST_Msk (0x1UL << TZFRC_ALL_OST_Pos)

typedef enum
{
    TZFRC_BIT_OST_NO_EFFECT       = 0,  /*!< Write a 0 has no effect and always reads back a 0           */
    TZFRC_BIT_OST_FORCE_EVENT     = 1,  /*!< Write a 1 forces a one-shot trip event and sets TZFLG.OST   */
} TZFRC_BIT_OST;

#define TZFRC_ALL_OST_NO_EFFECT       ((0x0UL) << TZFRC_ALL_OST_Pos)
#define TZFRC_ALL_OST_FORCE_EVENT     ((0x1UL) << TZFRC_ALL_OST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFRC           DCAEVT1
 *  @access     PWM->TZFRC.bit.DCAEVT1
 *  @brief      Software force a digital compare A event 1
 */
#define TZFRC_ALL_DCAEVT1_Pos (3)
#define TZFRC_ALL_DCAEVT1_Msk (0x1UL << TZFRC_ALL_DCAEVT1_Pos)

typedef enum
{
    TZFRC_BIT_DCAEVT1_NO_EFFECT       = 0,  /*!< Write a 0 has no effect and always reads back a 0                     */
    TZFRC_BIT_DCAEVT1_FORCE_EVENT     = 1,  /*!< Write a 1 forces a digital compare A event 1 and sets TZFLG.DCAEVT1   */
} TZFRC_BIT_DCAEVT1;

#define TZFRC_ALL_DCAEVT1_NO_EFFECT       ((0x0UL) << TZFRC_ALL_DCAEVT1_Pos)
#define TZFRC_ALL_DCAEVT1_FORCE_EVENT     ((0x1UL) << TZFRC_ALL_DCAEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFRC           DCAEVT2
 *  @access     PWM->TZFRC.bit.DCAEVT2
 *  @brief      Software force a digital compare A event 2
 */
#define TZFRC_ALL_DCAEVT2_Pos (4)
#define TZFRC_ALL_DCAEVT2_Msk (0x1UL << TZFRC_ALL_DCAEVT2_Pos)

typedef enum
{
    TZFRC_BIT_DCAEVT2_NO_EFFECT       = 0,  /*!< Write a 0 has no effect and always reads back a 0                     */
    TZFRC_BIT_DCAEVT2_FORCE_EVENT     = 1,  /*!< Write a 1 forces a digital compare A event 2 and sets TZFLG.DCAEVT2   */
} TZFRC_BIT_DCAEVT2;

#define TZFRC_ALL_DCAEVT2_NO_EFFECT       ((0x0UL) << TZFRC_ALL_DCAEVT2_Pos)
#define TZFRC_ALL_DCAEVT2_FORCE_EVENT     ((0x1UL) << TZFRC_ALL_DCAEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFRC           DCBEVT1
 *  @access     PWM->TZFRC.bit.DCBEVT1
 *  @brief      Software force a digital compare B event 1
 */
#define TZFRC_ALL_DCBEVT1_Pos (5)
#define TZFRC_ALL_DCBEVT1_Msk (0x1UL << TZFRC_ALL_DCBEVT1_Pos)

typedef enum
{
    TZFRC_BIT_DCBEVT1_NO_EFFECT       = 0,  /*!< Write a 0 has no effect and always reads back a 0                     */
    TZFRC_BIT_DCBEVT1_FORCE_EVENT     = 1,  /*!< Write a 1 forces a digital compare B event 1 and sets TZFLG.DCBEVT1   */
} TZFRC_BIT_DCBEVT1;

#define TZFRC_ALL_DCBEVT1_NO_EFFECT       ((0x0UL) << TZFRC_ALL_DCBEVT1_Pos)
#define TZFRC_ALL_DCBEVT1_FORCE_EVENT     ((0x1UL) << TZFRC_ALL_DCBEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZFRC           DCBEVT2
 *  @access     PWM->TZFRC.bit.DCBEVT2
 *  @brief      Software force a digital compare B event 2
 */
#define TZFRC_ALL_DCBEVT2_Pos (6)
#define TZFRC_ALL_DCBEVT2_Msk (0x1UL << TZFRC_ALL_DCBEVT2_Pos)

typedef enum
{
    TZFRC_BIT_DCBEVT2_NO_EFFECT       = 0,  /*!< Write a 0 has no effect and always reads back a 0                     */
    TZFRC_BIT_DCBEVT2_FORCE_EVENT     = 1,  /*!< Write a 1 forces a digital compare B event 2 and sets TZFLG.DCBEVT2   */
} TZFRC_BIT_DCBEVT2;

#define TZFRC_ALL_DCBEVT2_NO_EFFECT       ((0x0UL) << TZFRC_ALL_DCBEVT2_Pos)
#define TZFRC_ALL_DCBEVT2_FORCE_EVENT     ((0x1UL) << TZFRC_ALL_DCBEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZDCSEL         DCAEVT1
 *  @access     PWM->TZDCSEL.bit.DCAEVT1
 *  @brief      Digital compare A event 1 option
 */
#define TZDCSEL_ALL_DCAEVT1_Pos (0)
#define TZDCSEL_ALL_DCAEVT1_Msk (0x7UL << TZDCSEL_ALL_DCAEVT1_Pos)

typedef enum
{
    TZDCSEL_BIT_DCAEVT1_DISABLE                = 0,  /*!< Event disabled               */
    TZDCSEL_BIT_DCAEVT1_DCAH_LOW_DCAL_X        = 1,  /*!< DCAH=low, DCAL=don't care    */
    TZDCSEL_BIT_DCAEVT1_DCAH_HIGH_DCAL_X       = 2,  /*!< DCAH=high, DCAL=don't care   */
    TZDCSEL_BIT_DCAEVT1_DCAH_X_DCAL_LOW        = 3,  /*!< DCAL=low, DCAH=don't care    */
    TZDCSEL_BIT_DCAEVT1_DCAH_X_DCAL_HIGH       = 4,  /*!< DCAL=high, DCAH=don't care   */
    TZDCSEL_BIT_DCAEVT1_DCAH_LOW_DCAL_HIGH     = 5,  /*!< DCAL=high, DCAH=low          */
} TZDCSEL_BIT_DCAEVT1;

#define TZDCSEL_ALL_DCAEVT1_DISABLE                ((0x0UL) << TZDCSEL_ALL_DCAEVT1_Pos)
#define TZDCSEL_ALL_DCAEVT1_DCAH_LOW_DCAL_X        ((0x1UL) << TZDCSEL_ALL_DCAEVT1_Pos)
#define TZDCSEL_ALL_DCAEVT1_DCAH_HIGH_DCAL_X       ((0x2UL) << TZDCSEL_ALL_DCAEVT1_Pos)
#define TZDCSEL_ALL_DCAEVT1_DCAH_X_DCAL_LOW        ((0x3UL) << TZDCSEL_ALL_DCAEVT1_Pos)
#define TZDCSEL_ALL_DCAEVT1_DCAH_X_DCAL_HIGH       ((0x4UL) << TZDCSEL_ALL_DCAEVT1_Pos)
#define TZDCSEL_ALL_DCAEVT1_DCAH_LOW_DCAL_HIGH     ((0x5UL) << TZDCSEL_ALL_DCAEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZDCSEL         DCAEVT2
 *  @access     PWM->TZDCSEL.bit.DCAEVT2
 *  @brief      Digital compare A event 2 option
 */
#define TZDCSEL_ALL_DCAEVT2_Pos (3)
#define TZDCSEL_ALL_DCAEVT2_Msk (0x7UL << TZDCSEL_ALL_DCAEVT2_Pos)

typedef enum
{
    TZDCSEL_BIT_DCAEVT2_DISABLE                = 0,  /*!< Event disabled               */
    TZDCSEL_BIT_DCAEVT2_DCAH_LOW_DCAL_X        = 1,  /*!< DCAH=low, DCAL=don't care    */
    TZDCSEL_BIT_DCAEVT2_DCAH_HIGH_DCAL_X       = 2,  /*!< DCAH=high, DCAL=don't care   */
    TZDCSEL_BIT_DCAEVT2_DCAH_X_DCAL_LOW        = 3,  /*!< DCAL=low, DCAH=don't care    */
    TZDCSEL_BIT_DCAEVT2_DCAH_X_DCAL_HIGH       = 4,  /*!< DCAL=high, DCAH=don't care   */
    TZDCSEL_BIT_DCAEVT2_DCAH_LOW_DCAL_HIGH     = 5,  /*!< DCAL=high, DCAH=low          */
} TZDCSEL_BIT_DCAEVT2;

#define TZDCSEL_ALL_DCAEVT2_DISABLE                ((0x0UL) << TZDCSEL_ALL_DCAEVT2_Pos)
#define TZDCSEL_ALL_DCAEVT2_DCAH_LOW_DCAL_X        ((0x1UL) << TZDCSEL_ALL_DCAEVT2_Pos)
#define TZDCSEL_ALL_DCAEVT2_DCAH_HIGH_DCAL_X       ((0x2UL) << TZDCSEL_ALL_DCAEVT2_Pos)
#define TZDCSEL_ALL_DCAEVT2_DCAH_X_DCAL_LOW        ((0x3UL) << TZDCSEL_ALL_DCAEVT2_Pos)
#define TZDCSEL_ALL_DCAEVT2_DCAH_X_DCAL_HIGH       ((0x4UL) << TZDCSEL_ALL_DCAEVT2_Pos)
#define TZDCSEL_ALL_DCAEVT2_DCAH_LOW_DCAL_HIGH     ((0x5UL) << TZDCSEL_ALL_DCAEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZDCSEL         DCBEVT1
 *  @access     PWM->TZDCSEL.bit.DCBEVT1
 *  @brief      Digital compare B event 1 option
 */
#define TZDCSEL_ALL_DCBEVT1_Pos (6)
#define TZDCSEL_ALL_DCBEVT1_Msk (0x7UL << TZDCSEL_ALL_DCBEVT1_Pos)

typedef enum
{
    TZDCSEL_BIT_DCBEVT1_DISABLE                = 0,  /*!< Event disabled               */
    TZDCSEL_BIT_DCBEVT1_DCBH_LOW_DCBL_X        = 1,  /*!< DCBH=low, DCBL=don't care    */
    TZDCSEL_BIT_DCBEVT1_DCBH_HIGH_DCBL_X       = 2,  /*!< DCBH=high, DCBL=don't care   */
    TZDCSEL_BIT_DCBEVT1_DCBH_X_DCBL_LOW        = 3,  /*!< DCBL=low, DCBH=don't care    */
    TZDCSEL_BIT_DCBEVT1_DCBH_X_DCBL_HIGH       = 4,  /*!< DCBL=high, DCBH=don't care   */
    TZDCSEL_BIT_DCBEVT1_DCBH_LOW_DCBL_HIGH     = 5,  /*!< DCBL=high, DCBH=low          */
} TZDCSEL_BIT_DCBEVT1;

#define TZDCSEL_ALL_DCBEVT1_DISABLE                ((0x0UL) << TZDCSEL_ALL_DCBEVT1_Pos)
#define TZDCSEL_ALL_DCBEVT1_DCBH_LOW_DCBL_X        ((0x1UL) << TZDCSEL_ALL_DCBEVT1_Pos)
#define TZDCSEL_ALL_DCBEVT1_DCBH_HIGH_DCBL_X       ((0x2UL) << TZDCSEL_ALL_DCBEVT1_Pos)
#define TZDCSEL_ALL_DCBEVT1_DCBH_X_DCBL_LOW        ((0x3UL) << TZDCSEL_ALL_DCBEVT1_Pos)
#define TZDCSEL_ALL_DCBEVT1_DCBH_X_DCBL_HIGH       ((0x4UL) << TZDCSEL_ALL_DCBEVT1_Pos)
#define TZDCSEL_ALL_DCBEVT1_DCBH_LOW_DCBL_HIGH     ((0x5UL) << TZDCSEL_ALL_DCBEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             TZDCSEL         DCBEVT2
 *  @access     PWM->TZDCSEL.bit.DCBEVT2
 *  @brief      Digital compare B event 2 option
 */
#define TZDCSEL_ALL_DCBEVT2_Pos (9)
#define TZDCSEL_ALL_DCBEVT2_Msk (0x7UL << TZDCSEL_ALL_DCBEVT2_Pos)

typedef enum
{
    TZDCSEL_BIT_DCBEVT2_DISABLE                = 0,  /*!< Event disabled               */
    TZDCSEL_BIT_DCBEVT2_DCBH_LOW_DCBL_X        = 1,  /*!< DCBH=low, DCBL=don't care    */
    TZDCSEL_BIT_DCBEVT2_DCBH_HIGH_DCBL_X       = 2,  /*!< DCBH=high, DCBL=don't care   */
    TZDCSEL_BIT_DCBEVT2_DCBH_X_DCBL_LOW        = 3,  /*!< DCBL=low, DCBH=don't care    */
    TZDCSEL_BIT_DCBEVT2_DCBH_X_DCBL_HIGH       = 4,  /*!< DCBL=high, DCBH=don't care   */
    TZDCSEL_BIT_DCBEVT2_DCBH_LOW_DCBL_HIGH     = 5,  /*!< DCBL=high, DCBH=low          */
} TZDCSEL_BIT_DCBEVT2;

#define TZDCSEL_ALL_DCBEVT2_DISABLE                ((0x0UL) << TZDCSEL_ALL_DCBEVT2_Pos)
#define TZDCSEL_ALL_DCBEVT2_DCBH_LOW_DCBL_X        ((0x1UL) << TZDCSEL_ALL_DCBEVT2_Pos)
#define TZDCSEL_ALL_DCBEVT2_DCBH_HIGH_DCBL_X       ((0x2UL) << TZDCSEL_ALL_DCBEVT2_Pos)
#define TZDCSEL_ALL_DCBEVT2_DCBH_X_DCBL_LOW        ((0x3UL) << TZDCSEL_ALL_DCBEVT2_Pos)
#define TZDCSEL_ALL_DCBEVT2_DCBH_X_DCBL_HIGH       ((0x4UL) << TZDCSEL_ALL_DCBEVT2_Pos)
#define TZDCSEL_ALL_DCBEVT2_DCBH_LOW_DCBL_HIGH     ((0x5UL) << TZDCSEL_ALL_DCBEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCTRIPSEL       DCAHCOMPSEL
 *  @access     PWM->DCTRIPSEL.bit.DCAHCOMPSEL
 *  @brief      Digital compare A high input select
 */
#define DCTRIPSEL_ALL_DCAHCOMPSEL_Pos (0)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_Msk (0xFUL << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)

typedef enum
{
    DCTRIPSEL_BIT_DCAHCOMPSEL_TZ1        = 0,  /*!< TZ1      */
    DCTRIPSEL_BIT_DCAHCOMPSEL_TZ2        = 1,  /*!< TZ2      */
    DCTRIPSEL_BIT_DCAHCOMPSEL_TZ3        = 2,  /*!< TZ3      */
    DCTRIPSEL_BIT_DCAHCOMPSEL_TZ4        = 3,  /*!< TZ4      */
    DCTRIPSEL_BIT_DCAHCOMPSEL_TZ5        = 4,  /*!< TZ5      */
    DCTRIPSEL_BIT_DCAHCOMPSEL_COMP0H     = 8,  /*!< COMP0H   */
    DCTRIPSEL_BIT_DCAHCOMPSEL_COMP0L     = 9,  /*!< COMP0L   */
    DCTRIPSEL_BIT_DCAHCOMPSEL_COMP1H     = 10,  /*!< COMP1H   */
    DCTRIPSEL_BIT_DCAHCOMPSEL_COMP1L     = 11,  /*!< COMP1L   */
    DCTRIPSEL_BIT_DCAHCOMPSEL_COMP2H     = 12,  /*!< COMP2H   */
    DCTRIPSEL_BIT_DCAHCOMPSEL_COMP2L     = 13,  /*!< COMP2L   */
} DCTRIPSEL_BIT_DCAHCOMPSEL;

#define DCTRIPSEL_ALL_DCAHCOMPSEL_TZ1        ((0x00UL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_TZ2        ((0x01UL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_TZ3        ((0x02UL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_TZ4        ((0x03UL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_TZ5        ((0x04UL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_COMP0H     ((0x08UL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_COMP0L     ((0x09UL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_COMP1H     ((0x0AUL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_COMP1L     ((0x0BUL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_COMP2H     ((0x0CUL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCAHCOMPSEL_COMP2L     ((0x0DUL) << DCTRIPSEL_ALL_DCAHCOMPSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCTRIPSEL       DCALCOMPSEL
 *  @access     PWM->DCTRIPSEL.bit.DCALCOMPSEL
 *  @brief      Digital compare A low input select
 */
#define DCTRIPSEL_ALL_DCALCOMPSEL_Pos (4)
#define DCTRIPSEL_ALL_DCALCOMPSEL_Msk (0xFUL << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)

typedef enum
{
    DCTRIPSEL_BIT_DCALCOMPSEL_TZ1        = 0,  /*!< TZ1      */
    DCTRIPSEL_BIT_DCALCOMPSEL_TZ2        = 1,  /*!< TZ2      */
    DCTRIPSEL_BIT_DCALCOMPSEL_TZ3        = 2,  /*!< TZ3      */
    DCTRIPSEL_BIT_DCALCOMPSEL_TZ4        = 3,  /*!< TZ4      */
    DCTRIPSEL_BIT_DCALCOMPSEL_TZ5        = 4,  /*!< TZ5      */
    DCTRIPSEL_BIT_DCALCOMPSEL_COMP0H     = 8,  /*!< COMP0H   */
    DCTRIPSEL_BIT_DCALCOMPSEL_COMP0L     = 9,  /*!< COMP0L   */
    DCTRIPSEL_BIT_DCALCOMPSEL_COMP1H     = 10,  /*!< COMP1H   */
    DCTRIPSEL_BIT_DCALCOMPSEL_COMP1L     = 11,  /*!< COMP1L   */
    DCTRIPSEL_BIT_DCALCOMPSEL_COMP2H     = 12,  /*!< COMP2H   */
    DCTRIPSEL_BIT_DCALCOMPSEL_COMP2L     = 13,  /*!< COMP2L   */
} DCTRIPSEL_BIT_DCALCOMPSEL;

#define DCTRIPSEL_ALL_DCALCOMPSEL_TZ1        ((0x00UL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_TZ2        ((0x01UL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_TZ3        ((0x02UL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_TZ4        ((0x03UL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_TZ5        ((0x04UL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_COMP0H     ((0x08UL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_COMP0L     ((0x09UL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_COMP1H     ((0x0AUL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_COMP1L     ((0x0BUL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_COMP2H     ((0x0CUL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCALCOMPSEL_COMP2L     ((0x0DUL) << DCTRIPSEL_ALL_DCALCOMPSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCTRIPSEL       DCBHCOMPSEL
 *  @access     PWM->DCTRIPSEL.bit.DCBHCOMPSEL
 *  @brief      Digital compare B high input select
 */
#define DCTRIPSEL_ALL_DCBHCOMPSEL_Pos (8)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_Msk (0xFUL << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)

typedef enum
{
    DCTRIPSEL_BIT_DCBHCOMPSEL_TZ1        = 0,  /*!< TZ1      */
    DCTRIPSEL_BIT_DCBHCOMPSEL_TZ2        = 1,  /*!< TZ2      */
    DCTRIPSEL_BIT_DCBHCOMPSEL_TZ3        = 2,  /*!< TZ3      */
    DCTRIPSEL_BIT_DCBHCOMPSEL_TZ4        = 3,  /*!< TZ4      */
    DCTRIPSEL_BIT_DCBHCOMPSEL_TZ5        = 4,  /*!< TZ5      */
    DCTRIPSEL_BIT_DCBHCOMPSEL_COMP0H     = 8,  /*!< COMP0H   */
    DCTRIPSEL_BIT_DCBHCOMPSEL_COMP0L     = 9,  /*!< COMP0L   */
    DCTRIPSEL_BIT_DCBHCOMPSEL_COMP1H     = 10,  /*!< COMP1H   */
    DCTRIPSEL_BIT_DCBHCOMPSEL_COMP1L     = 11,  /*!< COMP1L   */
    DCTRIPSEL_BIT_DCBHCOMPSEL_COMP2H     = 12,  /*!< COMP2H   */
    DCTRIPSEL_BIT_DCBHCOMPSEL_COMP2L     = 13,  /*!< COMP2L   */
} DCTRIPSEL_BIT_DCBHCOMPSEL;

#define DCTRIPSEL_ALL_DCBHCOMPSEL_TZ1        ((0x00UL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_TZ2        ((0x01UL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_TZ3        ((0x02UL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_TZ4        ((0x03UL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_TZ5        ((0x04UL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_COMP0H     ((0x08UL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_COMP0L     ((0x09UL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_COMP1H     ((0x0AUL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_COMP1L     ((0x0BUL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_COMP2H     ((0x0CUL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBHCOMPSEL_COMP2L     ((0x0DUL) << DCTRIPSEL_ALL_DCBHCOMPSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCTRIPSEL       DCBLCOMPSEL
 *  @access     PWM->DCTRIPSEL.bit.DCBLCOMPSEL
 *  @brief      Digital compare B low input select
 */
#define DCTRIPSEL_ALL_DCBLCOMPSEL_Pos (12)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_Msk (0xFUL << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)

typedef enum
{
    DCTRIPSEL_BIT_DCBLCOMPSEL_TZ1        = 0,  /*!< TZ1      */
    DCTRIPSEL_BIT_DCBLCOMPSEL_TZ2        = 1,  /*!< TZ2      */
    DCTRIPSEL_BIT_DCBLCOMPSEL_TZ3        = 2,  /*!< TZ3      */
    DCTRIPSEL_BIT_DCBLCOMPSEL_TZ4        = 3,  /*!< TZ4      */
    DCTRIPSEL_BIT_DCBLCOMPSEL_TZ5        = 4,  /*!< TZ5      */
    DCTRIPSEL_BIT_DCBLCOMPSEL_COMP0H     = 8,  /*!< COMP0H   */
    DCTRIPSEL_BIT_DCBLCOMPSEL_COMP0L     = 9,  /*!< COMP0L   */
    DCTRIPSEL_BIT_DCBLCOMPSEL_COMP1H     = 10,  /*!< COMP1H   */
    DCTRIPSEL_BIT_DCBLCOMPSEL_COMP1L     = 11,  /*!< COMP1L   */
    DCTRIPSEL_BIT_DCBLCOMPSEL_COMP2H     = 12,  /*!< COMP2H   */
    DCTRIPSEL_BIT_DCBLCOMPSEL_COMP2L     = 13,  /*!< COMP2L   */
} DCTRIPSEL_BIT_DCBLCOMPSEL;

#define DCTRIPSEL_ALL_DCBLCOMPSEL_TZ1        ((0x00UL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_TZ2        ((0x01UL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_TZ3        ((0x02UL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_TZ4        ((0x03UL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_TZ5        ((0x04UL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_COMP0H     ((0x08UL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_COMP0L     ((0x09UL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_COMP1H     ((0x0AUL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_COMP1L     ((0x0BUL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_COMP2H     ((0x0CUL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)
#define DCTRIPSEL_ALL_DCBLCOMPSEL_COMP2L     ((0x0DUL) << DCTRIPSEL_ALL_DCBLCOMPSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCACTL          EVT1SRCSEL
 *  @access     PWM->DCACTL.bit.EVT1SRCSEL
 *  @brief      DCAEVT1 source signal select
 */
#define DCACTL_ALL_EVT1SRCSEL_Pos (0)
#define DCACTL_ALL_EVT1SRCSEL_Msk (0x1UL << DCACTL_ALL_EVT1SRCSEL_Pos)

typedef enum
{
    DCACTL_BIT_EVT1SRCSEL_DCAEVT1       = 0,  /*!< Source signal is DCAEVT1     */
    DCACTL_BIT_EVT1SRCSEL_DCEVTFILT     = 1,  /*!< Source signal is DCEVTFILT   */
} DCACTL_BIT_EVT1SRCSEL;

#define DCACTL_ALL_EVT1SRCSEL_DCAEVT1       ((0x0UL) << DCACTL_ALL_EVT1SRCSEL_Pos)
#define DCACTL_ALL_EVT1SRCSEL_DCEVTFILT     ((0x1UL) << DCACTL_ALL_EVT1SRCSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCACTL          EVT1SRCASYNC
 *  @access     PWM->DCACTL.bit.EVT1SRCASYNC
 *  @brief      DCAEVT1 source signal is asynchronous/synchronous (1/0)
 */
#define DCACTL_ALL_EVT1SRCASYNC_Pos (1)
#define DCACTL_ALL_EVT1SRCASYNC_Msk (0x1UL << DCACTL_ALL_EVT1SRCASYNC_Pos)

typedef enum
{
    DCACTL_BIT_EVT1SRCASYNC_DCAEVT1_SYNC      = 0,  /*!< Synchronous    */
    DCACTL_BIT_EVT1SRCASYNC_DCAEVT1_ASYNC     = 1,  /*!< Asynchronous   */
} DCACTL_BIT_EVT1SRCASYNC;

#define DCACTL_ALL_EVT1SRCASYNC_DCAEVT1_SYNC      ((0x0UL) << DCACTL_ALL_EVT1SRCASYNC_Pos)
#define DCACTL_ALL_EVT1SRCASYNC_DCAEVT1_ASYNC     ((0x1UL) << DCACTL_ALL_EVT1SRCASYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCACTL          EVT1SOCE
 *  @access     PWM->DCACTL.bit.EVT1SOCE
 *  @brief      DCAEVT1 SOC generation
 */
#define DCACTL_ALL_EVT1SOCE_Pos (2)
#define DCACTL_ALL_EVT1SOCE_Msk (0x1UL << DCACTL_ALL_EVT1SOCE_Pos)

typedef enum
{
    DCACTL_BIT_EVT1SOCE_DISABLE     = 0,  /*!< Disable   */
    DCACTL_BIT_EVT1SOCE_ENABLE      = 1,  /*!< Enable    */
} DCACTL_BIT_EVT1SOCE;

#define DCACTL_ALL_EVT1SOCE_DISABLE     ((0x0UL) << DCACTL_ALL_EVT1SOCE_Pos)
#define DCACTL_ALL_EVT1SOCE_ENABLE      ((0x1UL) << DCACTL_ALL_EVT1SOCE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCACTL          EVT1SYNCE
 *  @access     PWM->DCACTL.bit.EVT1SYNCE
 *  @brief      DCAEVT1 SYNC generation
 */
#define DCACTL_ALL_EVT1SYNCE_Pos (3)
#define DCACTL_ALL_EVT1SYNCE_Msk (0x1UL << DCACTL_ALL_EVT1SYNCE_Pos)

typedef enum
{
    DCACTL_BIT_EVT1SYNCE_DISABLE     = 0,  /*!< Disable   */
    DCACTL_BIT_EVT1SYNCE_ENABLE      = 1,  /*!< Enable    */
} DCACTL_BIT_EVT1SYNCE;

#define DCACTL_ALL_EVT1SYNCE_DISABLE     ((0x0UL) << DCACTL_ALL_EVT1SYNCE_Pos)
#define DCACTL_ALL_EVT1SYNCE_ENABLE      ((0x1UL) << DCACTL_ALL_EVT1SYNCE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCACTL          EVT2SRCSEL
 *  @access     PWM->DCACTL.bit.EVT2SRCSEL
 *  @brief      DCAEVT2 source signal select
 */
#define DCACTL_ALL_EVT2SRCSEL_Pos (8)
#define DCACTL_ALL_EVT2SRCSEL_Msk (0x1UL << DCACTL_ALL_EVT2SRCSEL_Pos)

typedef enum
{
    DCACTL_BIT_EVT2SRCSEL_DCAEVT2       = 0,  /*!< Source signal is DCAEVT2     */
    DCACTL_BIT_EVT2SRCSEL_DCEVTFILT     = 1,  /*!< Source signal is DCEVTFILT   */
} DCACTL_BIT_EVT2SRCSEL;

#define DCACTL_ALL_EVT2SRCSEL_DCAEVT2       ((0x0UL) << DCACTL_ALL_EVT2SRCSEL_Pos)
#define DCACTL_ALL_EVT2SRCSEL_DCEVTFILT     ((0x1UL) << DCACTL_ALL_EVT2SRCSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCACTL          EVT2SRCASYNC
 *  @access     PWM->DCACTL.bit.EVT2SRCASYNC
 *  @brief      DCAEVT2 source signal is asynchronous/synchronous
 */
#define DCACTL_ALL_EVT2SRCASYNC_Pos (9)
#define DCACTL_ALL_EVT2SRCASYNC_Msk (0x1UL << DCACTL_ALL_EVT2SRCASYNC_Pos)

typedef enum
{
    DCACTL_BIT_EVT2SRCASYNC_DCAEVT2_SYNC      = 0,  /*!< Synchronous    */
    DCACTL_BIT_EVT2SRCASYNC_DCAEVT2_ASYNC     = 1,  /*!< Asynchronous   */
} DCACTL_BIT_EVT2SRCASYNC;

#define DCACTL_ALL_EVT2SRCASYNC_DCAEVT2_SYNC      ((0x0UL) << DCACTL_ALL_EVT2SRCASYNC_Pos)
#define DCACTL_ALL_EVT2SRCASYNC_DCAEVT2_ASYNC     ((0x1UL) << DCACTL_ALL_EVT2SRCASYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCBCTL          EVT1SRCSEL
 *  @access     PWM->DCBCTL.bit.EVT1SRCSEL
 *  @brief      DCBEVT1 source signal select
 */
#define DCBCTL_ALL_EVT1SRCSEL_Pos (0)
#define DCBCTL_ALL_EVT1SRCSEL_Msk (0x1UL << DCBCTL_ALL_EVT1SRCSEL_Pos)

typedef enum
{
    DCBCTL_BIT_EVT1SRCSEL_DCBEVT1       = 0,  /*!< Source signal is DCBEVT1     */
    DCBCTL_BIT_EVT1SRCSEL_DCEVTFILT     = 1,  /*!< Source signal is DCEVTFILT   */
} DCBCTL_BIT_EVT1SRCSEL;

#define DCBCTL_ALL_EVT1SRCSEL_DCBEVT1       ((0x0UL) << DCBCTL_ALL_EVT1SRCSEL_Pos)
#define DCBCTL_ALL_EVT1SRCSEL_DCEVTFILT     ((0x1UL) << DCBCTL_ALL_EVT1SRCSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCBCTL          EVT1SRCASYNC
 *  @access     PWM->DCBCTL.bit.EVT1SRCASYNC
 *  @brief      DCBEVT1 source signal is asynchronous/synchronous
 */
#define DCBCTL_ALL_EVT1SRCASYNC_Pos (1)
#define DCBCTL_ALL_EVT1SRCASYNC_Msk (0x1UL << DCBCTL_ALL_EVT1SRCASYNC_Pos)

typedef enum
{
    DCBCTL_BIT_EVT1SRCASYNC_DCBEVT1_SYNC      = 0,  /*!< Synchronous    */
    DCBCTL_BIT_EVT1SRCASYNC_DCBEVT1_ASYNC     = 1,  /*!< Asynchronous   */
} DCBCTL_BIT_EVT1SRCASYNC;

#define DCBCTL_ALL_EVT1SRCASYNC_DCBEVT1_SYNC      ((0x0UL) << DCBCTL_ALL_EVT1SRCASYNC_Pos)
#define DCBCTL_ALL_EVT1SRCASYNC_DCBEVT1_ASYNC     ((0x1UL) << DCBCTL_ALL_EVT1SRCASYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCBCTL          EVT1SOCE
 *  @access     PWM->DCBCTL.bit.EVT1SOCE
 *  @brief      DCBEVT1 SOC generation
 */
#define DCBCTL_ALL_EVT1SOCE_Pos (2)
#define DCBCTL_ALL_EVT1SOCE_Msk (0x1UL << DCBCTL_ALL_EVT1SOCE_Pos)

typedef enum
{
    DCBCTL_BIT_EVT1SOCE_DISABLE     = 0,  /*!< Disable   */
    DCBCTL_BIT_EVT1SOCE_ENABLE      = 1,  /*!< Enable    */
} DCBCTL_BIT_EVT1SOCE;

#define DCBCTL_ALL_EVT1SOCE_DISABLE     ((0x0UL) << DCBCTL_ALL_EVT1SOCE_Pos)
#define DCBCTL_ALL_EVT1SOCE_ENABLE      ((0x1UL) << DCBCTL_ALL_EVT1SOCE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCBCTL          EVT1SYNCE
 *  @access     PWM->DCBCTL.bit.EVT1SYNCE
 *  @brief      DCBEVT1 SYNC generation
 */
#define DCBCTL_ALL_EVT1SYNCE_Pos (3)
#define DCBCTL_ALL_EVT1SYNCE_Msk (0x1UL << DCBCTL_ALL_EVT1SYNCE_Pos)

typedef enum
{
    DCBCTL_BIT_EVT1SYNCE_DISABLE     = 0,  /*!< Disable   */
    DCBCTL_BIT_EVT1SYNCE_ENABLE      = 1,  /*!< Enable    */
} DCBCTL_BIT_EVT1SYNCE;

#define DCBCTL_ALL_EVT1SYNCE_DISABLE     ((0x0UL) << DCBCTL_ALL_EVT1SYNCE_Pos)
#define DCBCTL_ALL_EVT1SYNCE_ENABLE      ((0x1UL) << DCBCTL_ALL_EVT1SYNCE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCBCTL          EVT2SRCSEL
 *  @access     PWM->DCBCTL.bit.EVT2SRCSEL
 *  @brief      DCBEVT2 source signal select
 */
#define DCBCTL_ALL_EVT2SRCSEL_Pos (8)
#define DCBCTL_ALL_EVT2SRCSEL_Msk (0x1UL << DCBCTL_ALL_EVT2SRCSEL_Pos)

typedef enum
{
    DCBCTL_BIT_EVT2SRCSEL_DCBEVT2       = 0,  /*!< Source signal is DCBEVT2     */
    DCBCTL_BIT_EVT2SRCSEL_DCEVTFILT     = 1,  /*!< Source signal is DCEVTFILT   */
} DCBCTL_BIT_EVT2SRCSEL;

#define DCBCTL_ALL_EVT2SRCSEL_DCBEVT2       ((0x0UL) << DCBCTL_ALL_EVT2SRCSEL_Pos)
#define DCBCTL_ALL_EVT2SRCSEL_DCEVTFILT     ((0x1UL) << DCBCTL_ALL_EVT2SRCSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCBCTL          EVT2SRCASYNC
 *  @access     PWM->DCBCTL.bit.EVT2SRCASYNC
 *  @brief      DCBEVT2 source signal is asynchronous/synchronous (1/0)
 */
#define DCBCTL_ALL_EVT2SRCASYNC_Pos (9)
#define DCBCTL_ALL_EVT2SRCASYNC_Msk (0x1UL << DCBCTL_ALL_EVT2SRCASYNC_Pos)

typedef enum
{
    DCBCTL_BIT_EVT2SRCASYNC_DCBEVT2_SYNC      = 0,  /*!<    */
    DCBCTL_BIT_EVT2SRCASYNC_DCBEVT2_ASYNC     = 1,  /*!<    */
} DCBCTL_BIT_EVT2SRCASYNC;

#define DCBCTL_ALL_EVT2SRCASYNC_DCBEVT2_SYNC      ((0x0UL) << DCBCTL_ALL_EVT2SRCASYNC_Pos)
#define DCBCTL_ALL_EVT2SRCASYNC_DCBEVT2_ASYNC     ((0x1UL) << DCBCTL_ALL_EVT2SRCASYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCFCTL          SRCSEL
 *  @access     PWM->DCFCTL.bit.SRCSEL
 *  @brief      DCEVTFILT signal source select
 */
#define DCFCTL_ALL_SRCSEL_Pos (0)
#define DCFCTL_ALL_SRCSEL_Msk (0x3UL << DCFCTL_ALL_SRCSEL_Pos)

typedef enum
{
    DCFCTL_BIT_SRCSEL_DCAEVT1     = 0,  /*!< Source is DCAEVT1   */
    DCFCTL_BIT_SRCSEL_DCAEVT2     = 1,  /*!< Source is DCAEVT2   */
    DCFCTL_BIT_SRCSEL_DCBEVT1     = 2,  /*!< Source is DCBEVT1   */
    DCFCTL_BIT_SRCSEL_DCBEVT2     = 3,  /*!< Source is DCBEVT2   */
} DCFCTL_BIT_SRCSEL;

#define DCFCTL_ALL_SRCSEL_DCAEVT1     ((0x0UL) << DCFCTL_ALL_SRCSEL_Pos)
#define DCFCTL_ALL_SRCSEL_DCAEVT2     ((0x1UL) << DCFCTL_ALL_SRCSEL_Pos)
#define DCFCTL_ALL_SRCSEL_DCBEVT1     ((0x2UL) << DCFCTL_ALL_SRCSEL_Pos)
#define DCFCTL_ALL_SRCSEL_DCBEVT2     ((0x3UL) << DCFCTL_ALL_SRCSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCFCTL          BLANKEN
 *  @access     PWM->DCFCTL.bit.BLANKEN
 *  @brief      Blanking window
 */
#define DCFCTL_ALL_BLANKEN_Pos (2)
#define DCFCTL_ALL_BLANKEN_Msk (0x1UL << DCFCTL_ALL_BLANKEN_Pos)

typedef enum
{
    DCFCTL_BIT_BLANKEN_DISABLE     = 0,  /*!< Disable   */
    DCFCTL_BIT_BLANKEN_ENABLE      = 1,  /*!< Enable    */
} DCFCTL_BIT_BLANKEN;

#define DCFCTL_ALL_BLANKEN_DISABLE     ((0x0UL) << DCFCTL_ALL_BLANKEN_Pos)
#define DCFCTL_ALL_BLANKEN_ENABLE      ((0x1UL) << DCFCTL_ALL_BLANKEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCFCTL          BLANKINV
 *  @access     PWM->DCFCTL.bit.BLANKINV
 *  @brief      Blanking window inversion
 */
#define DCFCTL_ALL_BLANKINV_Pos (3)
#define DCFCTL_ALL_BLANKINV_Msk (0x1UL << DCFCTL_ALL_BLANKINV_Pos)

typedef enum
{
    DCFCTL_BIT_BLANKINV_DISABLE     = 0,  /*!< Disable   */
    DCFCTL_BIT_BLANKINV_ENABLE      = 1,  /*!< Enable    */
} DCFCTL_BIT_BLANKINV;

#define DCFCTL_ALL_BLANKINV_DISABLE     ((0x0UL) << DCFCTL_ALL_BLANKINV_Pos)
#define DCFCTL_ALL_BLANKINV_ENABLE      ((0x1UL) << DCFCTL_ALL_BLANKINV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCFCTL          PULSESEL
 *  @access     PWM->DCFCTL.bit.PULSESEL
 *  @brief      Pulse select for blanking and capture alignment
 */
#define DCFCTL_ALL_PULSESEL_Pos (4)
#define DCFCTL_ALL_PULSESEL_Msk (0x3UL << DCFCTL_ALL_PULSESEL_Pos)

typedef enum
{
    DCFCTL_BIT_PULSESEL_ALIGN_FROM_PERIOD     = 0,  /*!< TBCNT=TBPRD   */
    DCFCTL_BIT_PULSESEL_ALIGN_FROM_ZERO       = 1,  /*!< TBCNT=Zero    */
} DCFCTL_BIT_PULSESEL;

#define DCFCTL_ALL_PULSESEL_ALIGN_FROM_PERIOD     ((0x0UL) << DCFCTL_ALL_PULSESEL_Pos)
#define DCFCTL_ALL_PULSESEL_ALIGN_FROM_ZERO       ((0x1UL) << DCFCTL_ALL_PULSESEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCCAPCTL        CAPEN
 *  @access     PWM->DCCAPCTL.bit.CAPEN
 *  @brief      TBCNT counter capture
 */
#define DCCAPCTL_ALL_CAPEN_Pos (0)
#define DCCAPCTL_ALL_CAPEN_Msk (0x1UL << DCCAPCTL_ALL_CAPEN_Pos)

typedef enum
{
    DCCAPCTL_BIT_CAPEN_ENABLE      = 0,  /*!< Disable   */
    DCCAPCTL_BIT_CAPEN_DISABLE     = 1,  /*!< Enable    */
} DCCAPCTL_BIT_CAPEN;

#define DCCAPCTL_ALL_CAPEN_ENABLE      ((0x0UL) << DCCAPCTL_ALL_CAPEN_Pos)
#define DCCAPCTL_ALL_CAPEN_DISABLE     ((0x1UL) << DCCAPCTL_ALL_CAPEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCCAPCTL        SHDWMODE
 *  @access     PWM->DCCAPCTL.bit.SHDWMODE
 *  @brief      TBCNT capture mode select
 */
#define DCCAPCTL_ALL_SHDWMODE_Pos (1)
#define DCCAPCTL_ALL_SHDWMODE_Msk (0x1UL << DCCAPCTL_ALL_SHDWMODE_Pos)

typedef enum
{
    DCCAPCTL_BIT_SHDWMODE_ENABLE      = 0,  /*!< Shadow mode. The DCCAP active value is copied to shadow register on a TBCNT=TBPRD or TBCNT=zero event as defined by DCFCTL.PULSESEL. Reads of the DCCAP register always returns the shadow register contents.   */
    DCCAPCTL_BIT_SHDWMODE_DISABLE     = 1,  /*!< Direct mode. Reads of the DCCAP register always returns the active value.                                                                                                                                       */
} DCCAPCTL_BIT_SHDWMODE;

#define DCCAPCTL_ALL_SHDWMODE_ENABLE      ((0x0UL) << DCCAPCTL_ALL_SHDWMODE_Pos)
#define DCCAPCTL_ALL_SHDWMODE_DISABLE     ((0x1UL) << DCCAPCTL_ALL_SHDWMODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCCAP           VAL
 *  @access     PWM->DCCAP.bit.VAL
 *  @brief      Captured TBCNT value upon a rising-edge of DCEVTFLT
 *              In shadow mode, the captured value is copied to the shadow register on a TBCNT=TBPRD or TBCNT=zero event as defined by DCFCTL.PULSESEL. Reads of the DCCAP register always returns the shadow register contents.
 *              In direct mode, reads of the DCCAP register always returns the active value.
 */
#define DCCAP_ALL_VAL_Pos (0)
#define DCCAP_ALL_VAL_Msk (0xFFFFUL << DCCAP_ALL_VAL_Pos)

#define DCCAP_BIT_VAL

#define DCCAP_ALL_VAL_(x) ((x) << DCCAP_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCFOFFSET       VAL
 *  @access     PWM->DCFOFFSET.bit.VAL
 *  @brief      Blanking window offset
 *              It defines the number of TBCLK cycles from the blanking window reference specified by DCFCTL.PULSESEL to the point when the blanking window is applied.
 */
#define DCFOFFSET_ALL_VAL_Pos (0)
#define DCFOFFSET_ALL_VAL_Msk (0xFFFFUL << DCFOFFSET_ALL_VAL_Pos)

#define DCFOFFSET_BIT_VAL

#define DCFOFFSET_ALL_VAL_(x) ((x) << DCFOFFSET_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCFOFFSETCNT    VAL
 *  @access     PWM->DCFOFFSETCNT.bit.VAL
 *  @brief      Blanking offset counter
 *              It is read only and indicates the current value of the offset counter. The counter counts down to zero and then stops until it is re-loaded on the next event defined by DCFCTL.PULSESEL.
 */
#define DCFOFFSETCNT_ALL_VAL_Pos (0)
#define DCFOFFSETCNT_ALL_VAL_Msk (0xFFFFUL << DCFOFFSETCNT_ALL_VAL_Pos)

#define DCFOFFSETCNT_BIT_VAL

#define DCFOFFSETCNT_ALL_VAL_(x) ((x) << DCFOFFSETCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCFWINDOW       VAL
 *  @access     PWM->DCFWINDOW.bit.VAL
 *  @brief      Blanking window width in TBCLK cycles
 *              The blanking window begins when the offset counter expires. When this occurs, the window counter is loaded and begins to count down. If the blanking window is currently active and the offset counter expires, the blanking window counter is restarted.
 *              The blanking window can cross a PWM period boundary.
 *              No blanking window is generated when it is set to zero.
 */
#define DCFWINDOW_ALL_VAL_Pos (0)
#define DCFWINDOW_ALL_VAL_Msk (0xFFFFUL << DCFWINDOW_ALL_VAL_Pos)

#define DCFWINDOW_BIT_VAL

#define DCFWINDOW_ALL_VAL_(x) ((x) << DCFWINDOW_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             DCFWINDOWCNT    VAL
 *  @access     PWM->DCFWINDOWCNT.bit.VAL
 *  @brief      Blanking window counter
 *              It is read only and indicates the current value of the window counter. The counter counts down to zero and then stops until it is re-loaded when the offset counter reaches zero again.
 */
#define DCFWINDOWCNT_ALL_VAL_Pos (0)
#define DCFWINDOWCNT_ALL_VAL_Msk (0xFFUL << DCFWINDOWCNT_ALL_VAL_Pos)

#define DCFWINDOWCNT_BIT_VAL

#define DCFWINDOWCNT_ALL_VAL_(x) ((x) << DCFWINDOWCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETSEL           INTSEL
 *  @access     PWM->ETSEL.bit.INTSEL
 *  @brief      PWM interrupt selection
 */
#define ETSEL_ALL_INTSEL_Pos (0)
#define ETSEL_ALL_INTSEL_Msk (0x7UL << ETSEL_ALL_INTSEL_Pos)

typedef enum
{
    ETSEL_BIT_INTSEL_TBCNT_EQU_ZERO            = 1,  /*!< Enable event TBCNT=0                                   */
    ETSEL_BIT_INTSEL_TBCNT_EQU_PERIOD          = 2,  /*!< Enable event TBCNT=TBPRD                               */
    ETSEL_BIT_INTSEL_TBCNT_EQU_ZERO_PERIOD     = 3,  /*!< Enable event TBCNT=0 or TBCNT=TBPRD                    */
    ETSEL_BIT_INTSEL_CMPA_UP_COUNTING          = 4,  /*!< Enable event TBCNT=CMPA when counter is incrementing   */
    ETSEL_BIT_INTSEL_CMPA_DOWN_COUNTING        = 5,  /*!< Enable event TBCNT=CMPA when counter is decrementing   */
    ETSEL_BIT_INTSEL_CMPB_UP_COUNTING          = 6,  /*!< Enable event TBCNT=CMPB when counter is incrementing   */
    ETSEL_BIT_INTSEL_CMPB_DOWN_COUNTING        = 7,  /*!< Enable event TBCNT=CMPB when counter is decrementing   */
} ETSEL_BIT_INTSEL;

#define ETSEL_ALL_INTSEL_TBCNT_EQU_ZERO            ((0x1UL) << ETSEL_ALL_INTSEL_Pos)
#define ETSEL_ALL_INTSEL_TBCNT_EQU_PERIOD          ((0x2UL) << ETSEL_ALL_INTSEL_Pos)
#define ETSEL_ALL_INTSEL_TBCNT_EQU_ZERO_PERIOD     ((0x3UL) << ETSEL_ALL_INTSEL_Pos)
#define ETSEL_ALL_INTSEL_CMPA_UP_COUNTING          ((0x4UL) << ETSEL_ALL_INTSEL_Pos)
#define ETSEL_ALL_INTSEL_CMPA_DOWN_COUNTING        ((0x5UL) << ETSEL_ALL_INTSEL_Pos)
#define ETSEL_ALL_INTSEL_CMPB_UP_COUNTING          ((0x6UL) << ETSEL_ALL_INTSEL_Pos)
#define ETSEL_ALL_INTSEL_CMPB_DOWN_COUNTING        ((0x7UL) << ETSEL_ALL_INTSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETSEL           INTEN
 *  @access     PWM->ETSEL.bit.INTEN
 *  @brief      PWM interrupt
 */
#define ETSEL_ALL_INTEN_Pos (3)
#define ETSEL_ALL_INTEN_Msk (0x1UL << ETSEL_ALL_INTEN_Pos)

typedef enum
{
    ETSEL_BIT_INTEN_DISABLE     = 0,  /*!< Disable   */
    ETSEL_BIT_INTEN_ENABLE      = 1,  /*!< Enable    */
} ETSEL_BIT_INTEN;

#define ETSEL_ALL_INTEN_DISABLE     ((0x0UL) << ETSEL_ALL_INTEN_Pos)
#define ETSEL_ALL_INTEN_ENABLE      ((0x1UL) << ETSEL_ALL_INTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETSEL           SOCASEL
 *  @access     PWM->ETSEL.bit.SOCASEL
 *  @brief      PWM SOCA options
 */
#define ETSEL_ALL_SOCASEL_Pos (8)
#define ETSEL_ALL_SOCASEL_Msk (0x7UL << ETSEL_ALL_SOCASEL_Pos)

typedef enum
{
    ETSEL_BIT_SOCASEL_DVAEVT1_SOC               = 0,  /*!< Enable DCAEVT1.SOC event                               */
    ETSEL_BIT_SOCASEL_TBCNT_EQU_ZERO            = 1,  /*!< Enable event TBCNT=0                                   */
    ETSEL_BIT_SOCASEL_TBCNT_EQU_PERIOD          = 2,  /*!< Enable event TBCNT=TBPRD                               */
    ETSEL_BIT_SOCASEL_TBCNT_EQU_ZERO_PERIOD     = 3,  /*!< Enable event TBCNT=0 or TBCNT=TBPRD                    */
    ETSEL_BIT_SOCASEL_CMPA_UP_COUNTING          = 4,  /*!< Enable event TBCNT=CMPA when counter is incrementing   */
    ETSEL_BIT_SOCASEL_CMPA_DOWN_COUNTING        = 5,  /*!< Enable event TBCNT=CMPA when counter is decrementing   */
    ETSEL_BIT_SOCASEL_CMPB_UP_COUNTING          = 6,  /*!< Enable event TBCNT=CMPB when counter is incrementing   */
    ETSEL_BIT_SOCASEL_CMPB_DOWN_COUNTING        = 7,  /*!< Enable event TBCNT=CMPB when counter is decrementing   */
} ETSEL_BIT_SOCASEL;

#define ETSEL_ALL_SOCASEL_DVAEVT1_SOC               ((0x0UL) << ETSEL_ALL_SOCASEL_Pos)
#define ETSEL_ALL_SOCASEL_TBCNT_EQU_ZERO            ((0x1UL) << ETSEL_ALL_SOCASEL_Pos)
#define ETSEL_ALL_SOCASEL_TBCNT_EQU_PERIOD          ((0x2UL) << ETSEL_ALL_SOCASEL_Pos)
#define ETSEL_ALL_SOCASEL_TBCNT_EQU_ZERO_PERIOD     ((0x3UL) << ETSEL_ALL_SOCASEL_Pos)
#define ETSEL_ALL_SOCASEL_CMPA_UP_COUNTING          ((0x4UL) << ETSEL_ALL_SOCASEL_Pos)
#define ETSEL_ALL_SOCASEL_CMPA_DOWN_COUNTING        ((0x5UL) << ETSEL_ALL_SOCASEL_Pos)
#define ETSEL_ALL_SOCASEL_CMPB_UP_COUNTING          ((0x6UL) << ETSEL_ALL_SOCASEL_Pos)
#define ETSEL_ALL_SOCASEL_CMPB_DOWN_COUNTING        ((0x7UL) << ETSEL_ALL_SOCASEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETSEL           SOCAEN
 *  @access     PWM->ETSEL.bit.SOCAEN
 *  @brief      Enable/disable ADC start of conversion A (SOCA) pulse
 */
#define ETSEL_ALL_SOCAEN_Pos (11)
#define ETSEL_ALL_SOCAEN_Msk (0x1UL << ETSEL_ALL_SOCAEN_Pos)

typedef enum
{
    ETSEL_BIT_SOCAEN_DISABLE     = 0,  /*!< Disable   */
    ETSEL_BIT_SOCAEN_ENABLE      = 1,  /*!< Enable    */
} ETSEL_BIT_SOCAEN;

#define ETSEL_ALL_SOCAEN_DISABLE     ((0x0UL) << ETSEL_ALL_SOCAEN_Pos)
#define ETSEL_ALL_SOCAEN_ENABLE      ((0x1UL) << ETSEL_ALL_SOCAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETSEL           SOCBSEL
 *  @access     PWM->ETSEL.bit.SOCBSEL
 *  @brief      PWM SOCB options
 */
#define ETSEL_ALL_SOCBSEL_Pos (12)
#define ETSEL_ALL_SOCBSEL_Msk (0x7UL << ETSEL_ALL_SOCBSEL_Pos)

typedef enum
{
    ETSEL_BIT_SOCBSEL_DVBEVT1_SOC               = 0,  /*!< Enable DCBEVT1.SOC event                               */
    ETSEL_BIT_SOCBSEL_TBCNT_EQU_ZERO            = 1,  /*!< Enable event TBCNT=0                                   */
    ETSEL_BIT_SOCBSEL_TBCNT_EQU_PERIOD          = 2,  /*!< Enable event TBCNT=TBPRD                               */
    ETSEL_BIT_SOCBSEL_TBCNT_EQU_ZERO_PERIOD     = 3,  /*!< Enable event TBCNT=0 or TBCNT=TBPRD                    */
    ETSEL_BIT_SOCBSEL_CMPA_UP_COUNTING          = 4,  /*!< Enable event TBCNT=CMPA when counter is incrementing   */
    ETSEL_BIT_SOCBSEL_CMPA_DOWN_COUNTING        = 5,  /*!< Enable event TBCNT=CMPA when counter is decrementing   */
    ETSEL_BIT_SOCBSEL_CMPB_UP_COUNTING          = 6,  /*!< Enable event TBCNT=CMPB when counter is incrementing   */
    ETSEL_BIT_SOCBSEL_CMPB_DOWN_COUNTING        = 7,  /*!< Enable event TBCNT=CMPB when counter is decrementing   */
} ETSEL_BIT_SOCBSEL;

#define ETSEL_ALL_SOCBSEL_DVBEVT1_SOC               ((0x0UL) << ETSEL_ALL_SOCBSEL_Pos)
#define ETSEL_ALL_SOCBSEL_TBCNT_EQU_ZERO            ((0x1UL) << ETSEL_ALL_SOCBSEL_Pos)
#define ETSEL_ALL_SOCBSEL_TBCNT_EQU_PERIOD          ((0x2UL) << ETSEL_ALL_SOCBSEL_Pos)
#define ETSEL_ALL_SOCBSEL_TBCNT_EQU_ZERO_PERIOD     ((0x3UL) << ETSEL_ALL_SOCBSEL_Pos)
#define ETSEL_ALL_SOCBSEL_CMPA_UP_COUNTING          ((0x4UL) << ETSEL_ALL_SOCBSEL_Pos)
#define ETSEL_ALL_SOCBSEL_CMPA_DOWN_COUNTING        ((0x5UL) << ETSEL_ALL_SOCBSEL_Pos)
#define ETSEL_ALL_SOCBSEL_CMPB_UP_COUNTING          ((0x6UL) << ETSEL_ALL_SOCBSEL_Pos)
#define ETSEL_ALL_SOCBSEL_CMPB_DOWN_COUNTING        ((0x7UL) << ETSEL_ALL_SOCBSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETSEL           SOCBEN
 *  @access     PWM->ETSEL.bit.SOCBEN
 *  @brief      ADC start of conversion B (SOCB) pulse
 */
#define ETSEL_ALL_SOCBEN_Pos (15)
#define ETSEL_ALL_SOCBEN_Msk (0x1UL << ETSEL_ALL_SOCBEN_Pos)

typedef enum
{
    ETSEL_BIT_SOCBEN_DISABLE     = 0,  /*!< Disable   */
    ETSEL_BIT_SOCBEN_ENABLE      = 1,  /*!< Enable    */
} ETSEL_BIT_SOCBEN;

#define ETSEL_ALL_SOCBEN_DISABLE     ((0x0UL) << ETSEL_ALL_SOCBEN_Pos)
#define ETSEL_ALL_SOCBEN_ENABLE      ((0x1UL) << ETSEL_ALL_SOCBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETPS            INTPRD
 *  @access     PWM->ETPS.bit.INTPRD
 *  @brief      PWM interrupt period select
 *              It determines how many selected ETSEL.INTSEL events need to occur before an interrupt is generated. To be generated, the interrupt must be enabled by setting ETSEL.INTEN=1. If the interrupt status flag is set from a previous interrupt (ETFLG.INT=1), no interrupt will be generated until the flag is cleared by writing a 0 to ETCLR.INT. This allows for one interrupt to be pending while another is still being serviced. Once the interrupt is generated, the ETPS.INTCNT will automatically be cleared.
 *              Write an INTPRD value that is the same as the current INTCNT value will trigger an interrupt if it is enabled and the status flag is clear.
 *              Write an INTPRD value that is less than current INTCNT value will result in an undefined state.
 */
#define ETPS_ALL_INTPRD_Pos (0)
#define ETPS_ALL_INTPRD_Msk (0x3UL << ETPS_ALL_INTPRD_Pos)

typedef enum
{
    ETPS_BIT_INTPRD_DISABLE                  = 0,  /*!< Disable the interrupt event counter. No interrupt will be generated and ETFRC.INT is ignored.   */
    ETPS_BIT_INTPRD_GEN_INT_ON_1ST_EVENT     = 1,  /*!< Generate an interrupt on the first event INTCNT=01 (first event)                                */
    ETPS_BIT_INTPRD_GEN_INT_ON_2ND_EVENT     = 2,  /*!< Generate interrupt on ETPS.INTCNT=10 (second event)                                             */
    ETPS_BIT_INTPRD_GEN_INT_ON_3RD_EVENT     = 3,  /*!< Generate interrupt on ETPS.INTCNT=11 (third event)                                              */
} ETPS_BIT_INTPRD;

#define ETPS_ALL_INTPRD_DISABLE                  ((0x0UL) << ETPS_ALL_INTPRD_Pos)
#define ETPS_ALL_INTPRD_GEN_INT_ON_1ST_EVENT     ((0x1UL) << ETPS_ALL_INTPRD_Pos)
#define ETPS_ALL_INTPRD_GEN_INT_ON_2ND_EVENT     ((0x2UL) << ETPS_ALL_INTPRD_Pos)
#define ETPS_ALL_INTPRD_GEN_INT_ON_3RD_EVENT     ((0x3UL) << ETPS_ALL_INTPRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETPS            INTCNT
 *  @access     PWM->ETPS.bit.INTCNT
 *  @brief      PWM interrupt counter
 *              It indicates how many selected ETSEL.INTSEL events have occurred. It is automatically cleared when an interrupt pulse is generated.
 */
#define ETPS_ALL_INTCNT_Pos (2)
#define ETPS_ALL_INTCNT_Msk (0x3UL << ETPS_ALL_INTCNT_Pos)

typedef enum
{
    ETPS_BIT_INTCNT_NO_EVENT_OCCUR     = 0,  /*!< No events have occurred   */
    ETPS_BIT_INTCNT_1_EVENT_OCCUR      = 1,  /*!< 1 event has occurred      */
    ETPS_BIT_INTCNT_2_EVENT_OCCUR      = 2,  /*!< 2 events have occurred    */
    ETPS_BIT_INTCNT_3_EVENT_OCCUR      = 3,  /*!< 3 events have occurred    */
} ETPS_BIT_INTCNT;

#define ETPS_ALL_INTCNT_NO_EVENT_OCCUR     ((0x0UL) << ETPS_ALL_INTCNT_Pos)
#define ETPS_ALL_INTCNT_1_EVENT_OCCUR      ((0x1UL) << ETPS_ALL_INTCNT_Pos)
#define ETPS_ALL_INTCNT_2_EVENT_OCCUR      ((0x2UL) << ETPS_ALL_INTCNT_Pos)
#define ETPS_ALL_INTCNT_3_EVENT_OCCUR      ((0x3UL) << ETPS_ALL_INTCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETPS            SOCAPRD
 *  @access     PWM->ETPS.bit.SOCAPRD
 *  @brief      PWM ADC start-of-conversion A event (SOCA) period select
 *              It determines how many selected ETSEL.SOCASEL events need to occur before an SOCA pulse is generated. To be generated, it must be enabled by setting ETSEL.SOCAEN=1. The pulse will be generated even if the status flag is set from a previous start of conversion (ETFLG.SOCA=1). Once the SOCA pulse is generated, the ETPS.SOCACNT will automatically be cleared.
 */
#define ETPS_ALL_SOCAPRD_Pos (8)
#define ETPS_ALL_SOCAPRD_Msk (0x3UL << ETPS_ALL_SOCAPRD_Pos)

typedef enum
{
    ETPS_BIT_SOCAPRD_GEN_SOCA_DISABLE          = 0,  /*!< Disable SOCA event counter. No SOCA pulse will be generated.   */
    ETPS_BIT_SOCAPRD_GEN_SOCA_ON_1ST_EVENT     = 1,  /*!< Generate SOCA pulse when ETPS.SOCACNT=01 (first event)         */
    ETPS_BIT_SOCAPRD_GEN_SOCA_ON_2ND_EVENT     = 2,  /*!< Generate SOCA pulse when ETPS.SOCACNT=10 (second event)        */
    ETPS_BIT_SOCAPRD_GEN_SOCA_ON_3RD_EVENT     = 3,  /*!< Generate SOCA pulse when ETPS.SOCACNT=11 (third event)         */
} ETPS_BIT_SOCAPRD;

#define ETPS_ALL_SOCAPRD_GEN_SOCA_DISABLE          ((0x0UL) << ETPS_ALL_SOCAPRD_Pos)
#define ETPS_ALL_SOCAPRD_GEN_SOCA_ON_1ST_EVENT     ((0x1UL) << ETPS_ALL_SOCAPRD_Pos)
#define ETPS_ALL_SOCAPRD_GEN_SOCA_ON_2ND_EVENT     ((0x2UL) << ETPS_ALL_SOCAPRD_Pos)
#define ETPS_ALL_SOCAPRD_GEN_SOCA_ON_3RD_EVENT     ((0x3UL) << ETPS_ALL_SOCAPRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETPS            SOCACNT
 *  @access     PWM->ETPS.bit.SOCACNT
 *  @brief      PWM ADC start-of-conversion A event (SOCA) counter
 *              It indicates how many selected ETSEL.SOCASEL events have occurred
 */
#define ETPS_ALL_SOCACNT_Pos (10)
#define ETPS_ALL_SOCACNT_Msk (0x3UL << ETPS_ALL_SOCACNT_Pos)

typedef enum
{
    ETPS_BIT_SOCACNT_NO_EVENT_OCCUR     = 0,  /*!< No events have occurred   */
    ETPS_BIT_SOCACNT_1_EVENT_OCCUR      = 1,  /*!< 1 event has occurred      */
    ETPS_BIT_SOCACNT_2_EVENT_OCCUR      = 2,  /*!< 2 events have occurred    */
    ETPS_BIT_SOCACNT_3_EVENT_OCCUR      = 3,  /*!< 3 events have occurred    */
} ETPS_BIT_SOCACNT;

#define ETPS_ALL_SOCACNT_NO_EVENT_OCCUR     ((0x0UL) << ETPS_ALL_SOCACNT_Pos)
#define ETPS_ALL_SOCACNT_1_EVENT_OCCUR      ((0x1UL) << ETPS_ALL_SOCACNT_Pos)
#define ETPS_ALL_SOCACNT_2_EVENT_OCCUR      ((0x2UL) << ETPS_ALL_SOCACNT_Pos)
#define ETPS_ALL_SOCACNT_3_EVENT_OCCUR      ((0x3UL) << ETPS_ALL_SOCACNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETPS            SOCBPRD
 *  @access     PWM->ETPS.bit.SOCBPRD
 *  @brief      PWM ADC start-of-conversion B event (SOCB) period select
 *              It determines how many selected ETSEL.SOCBSEL events need to occur before an SOCB pulse is generated. To be generated, it must be enabled by setting ETSEL.SOCBEN=1. The pulse will be generated even if the status flag is set from a previous start of conversion (ETFLG.SOCB=1). Once the SOCB pulse is generated, the ETPS.SOCBCNT will automatically be cleared.
 */
#define ETPS_ALL_SOCBPRD_Pos (12)
#define ETPS_ALL_SOCBPRD_Msk (0x3UL << ETPS_ALL_SOCBPRD_Pos)

typedef enum
{
    ETPS_BIT_SOCBPRD_GEN_SOCB_DISABLE          = 0,  /*!< Disable SOCB event counter. No SOCB pulse will be generated.   */
    ETPS_BIT_SOCBPRD_GEN_SOCB_ON_1ST_EVENT     = 1,  /*!< Generate SOCB pulse when ETPS.SOCBCNT=01 (first event)         */
    ETPS_BIT_SOCBPRD_GEN_SOCB_ON_2ND_EVENT     = 2,  /*!< Generate SOCB pulse when ETPS.SOCBCNT=10 (second event)        */
    ETPS_BIT_SOCBPRD_GEN_SOCB_ON_3RD_EVENT     = 3,  /*!< Generate SOCB pulse when ETPS.SOCBCNT=11 (third event)         */
} ETPS_BIT_SOCBPRD;

#define ETPS_ALL_SOCBPRD_GEN_SOCB_DISABLE          ((0x0UL) << ETPS_ALL_SOCBPRD_Pos)
#define ETPS_ALL_SOCBPRD_GEN_SOCB_ON_1ST_EVENT     ((0x1UL) << ETPS_ALL_SOCBPRD_Pos)
#define ETPS_ALL_SOCBPRD_GEN_SOCB_ON_2ND_EVENT     ((0x2UL) << ETPS_ALL_SOCBPRD_Pos)
#define ETPS_ALL_SOCBPRD_GEN_SOCB_ON_3RD_EVENT     ((0x3UL) << ETPS_ALL_SOCBPRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETPS            SOCBCNT
 *  @access     PWM->ETPS.bit.SOCBCNT
 *  @brief      PWM ADC start-of-conversion B event (SOCB) counter
 *              It indicates how many selected ETSEL.SOCBSEL events have occurred
 */
#define ETPS_ALL_SOCBCNT_Pos (14)
#define ETPS_ALL_SOCBCNT_Msk (0x3UL << ETPS_ALL_SOCBCNT_Pos)

typedef enum
{
    ETPS_BIT_SOCBCNT_NO_EVENT_OCCUR     = 0,  /*!< No events have occurred   */
    ETPS_BIT_SOCBCNT_1_EVENT_OCCUR      = 1,  /*!< 1 event has occurred      */
    ETPS_BIT_SOCBCNT_2_EVENT_OCCUR      = 2,  /*!< 2 events have occurred    */
    ETPS_BIT_SOCBCNT_3_EVENT_OCCUR      = 3,  /*!< 3 events have occurred    */
} ETPS_BIT_SOCBCNT;

#define ETPS_ALL_SOCBCNT_NO_EVENT_OCCUR     ((0x0UL) << ETPS_ALL_SOCBCNT_Pos)
#define ETPS_ALL_SOCBCNT_1_EVENT_OCCUR      ((0x1UL) << ETPS_ALL_SOCBCNT_Pos)
#define ETPS_ALL_SOCBCNT_2_EVENT_OCCUR      ((0x2UL) << ETPS_ALL_SOCBCNT_Pos)
#define ETPS_ALL_SOCBCNT_3_EVENT_OCCUR      ((0x3UL) << ETPS_ALL_SOCBCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETFLG           INT
 *  @access     PWM->ETFLG.bit.INT
 *  @brief      Latched PWM interrupt status flag
 */
#define ETFLG_ALL_INT_Pos (0)
#define ETFLG_ALL_INT_Msk (0x1UL << ETFLG_ALL_INT_Pos)

typedef enum
{
    ETFLG_BIT_INT_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                                                                                       */
    ETFLG_BIT_INT_OCCUR         = 1,  /*!< Indicates a PWM interrupt was generated. No further interrupts will be generated until the flag bit is cleared.   */
} ETFLG_BIT_INT;

#define ETFLG_ALL_INT_NOT_OCCUR     ((0x0UL) << ETFLG_ALL_INT_Pos)
#define ETFLG_ALL_INT_OCCUR         ((0x1UL) << ETFLG_ALL_INT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETFLG           SOCA
 *  @access     PWM->ETFLG.bit.SOCA
 *  @brief      Latched PWM ADC start-of-conversion A status flag
 */
#define ETFLG_ALL_SOCA_Pos (2)
#define ETFLG_ALL_SOCA_Msk (0x1UL << ETFLG_ALL_SOCA_Pos)

typedef enum
{
    ETFLG_BIT_SOCA_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                                                                              */
    ETFLG_BIT_SOCA_OCCUR         = 1,  /*!< Indicates a SOCA pulse was generated. The pulse will continue to be generated even if the flag is set.   */
} ETFLG_BIT_SOCA;

#define ETFLG_ALL_SOCA_NOT_OCCUR     ((0x0UL) << ETFLG_ALL_SOCA_Pos)
#define ETFLG_ALL_SOCA_OCCUR         ((0x1UL) << ETFLG_ALL_SOCA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETFLG           SOCB
 *  @access     PWM->ETFLG.bit.SOCB
 *  @brief      Latched PWM ADC start-of-conversion B status flag
 */
#define ETFLG_ALL_SOCB_Pos (3)
#define ETFLG_ALL_SOCB_Msk (0x1UL << ETFLG_ALL_SOCB_Pos)

typedef enum
{
    ETFLG_BIT_SOCB_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                                                                              */
    ETFLG_BIT_SOCB_OCCUR         = 1,  /*!< Indicates a SOCB pulse was generated. The pulse will continue to be generated even if the flag is set.   */
} ETFLG_BIT_SOCB;

#define ETFLG_ALL_SOCB_NOT_OCCUR     ((0x0UL) << ETFLG_ALL_SOCB_Pos)
#define ETFLG_ALL_SOCB_OCCUR         ((0x1UL) << ETFLG_ALL_SOCB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETCLR           INT
 *  @access     PWM->ETCLR.bit.INT
 *  @brief      Clear PWM interrupt status flag
 */
#define ETCLR_ALL_INT_Pos (0)
#define ETCLR_ALL_INT_Msk (0x1UL << ETCLR_ALL_INT_Pos)

typedef enum
{
    ETCLR_BIT_INT_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    ETCLR_BIT_INT_CLEAR_FLAG     = 1,  /*!< Write a 1 clears ETFLG.INT                          */
} ETCLR_BIT_INT;

#define ETCLR_ALL_INT_NO_EFFECT      ((0x0UL) << ETCLR_ALL_INT_Pos)
#define ETCLR_ALL_INT_CLEAR_FLAG     ((0x1UL) << ETCLR_ALL_INT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETCLR           SOCA
 *  @access     PWM->ETCLR.bit.SOCA
 *  @brief      Clear ADC start-of-conversion A status flag
 */
#define ETCLR_ALL_SOCA_Pos (2)
#define ETCLR_ALL_SOCA_Msk (0x1UL << ETCLR_ALL_SOCA_Pos)

typedef enum
{
    ETCLR_BIT_SOCA_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    ETCLR_BIT_SOCA_CLEAR_FLAG     = 1,  /*!< Write a 1 clears ETFLG.INT                          */
} ETCLR_BIT_SOCA;

#define ETCLR_ALL_SOCA_NO_EFFECT      ((0x0UL) << ETCLR_ALL_SOCA_Pos)
#define ETCLR_ALL_SOCA_CLEAR_FLAG     ((0x1UL) << ETCLR_ALL_SOCA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETCLR           SOCB
 *  @access     PWM->ETCLR.bit.SOCB
 *  @brief      Clear ADC start-of-conversion B status flag
 */
#define ETCLR_ALL_SOCB_Pos (3)
#define ETCLR_ALL_SOCB_Msk (0x1UL << ETCLR_ALL_SOCB_Pos)

typedef enum
{
    ETCLR_BIT_SOCB_NO_EFFECT      = 0,  /*!< Write a 0 has no effect and always reads back a 0   */
    ETCLR_BIT_SOCB_CLEAR_FLAG     = 1,  /*!< Write a 1 clears ETFLG.INT                          */
} ETCLR_BIT_SOCB;

#define ETCLR_ALL_SOCB_NO_EFFECT      ((0x0UL) << ETCLR_ALL_SOCB_Pos)
#define ETCLR_ALL_SOCB_CLEAR_FLAG     ((0x1UL) << ETCLR_ALL_SOCB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETFRC           INT
 *  @access     PWM->ETFRC.bit.INT
 *  @brief      Software force a PWM interrupt
 *              This bit is ignored if ETSEL.INTEN=0 or ETPS.INTPRD=00
 */
#define ETFRC_ALL_INT_Pos (0)
#define ETFRC_ALL_INT_Msk (0x1UL << ETFRC_ALL_INT_Pos)

typedef enum
{
    ETFRC_BIT_INT_NO_EFFECT     = 0,  /*!< Write a 0 has no effect and always reads back a 0              */
    ETFRC_BIT_INT_FORCE         = 1,  /*!< Write a 1 generates an interrupt and sets the ETFLG.INT flag   */
} ETFRC_BIT_INT;

#define ETFRC_ALL_INT_NO_EFFECT     ((0x0UL) << ETFRC_ALL_INT_Pos)
#define ETFRC_ALL_INT_FORCE         ((0x1UL) << ETFRC_ALL_INT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETFRC           SOCA
 *  @access     PWM->ETFRC.bit.SOCA
 *  @brief      Software force a start-of-conversion A pulse
 *              This bit is ignored if ETSEL.SOCAEN=0
 */
#define ETFRC_ALL_SOCA_Pos (2)
#define ETFRC_ALL_SOCA_Msk (0x1UL << ETFRC_ALL_SOCA_Pos)

typedef enum
{
    ETFRC_BIT_SOCA_NO_EFFECT     = 0,  /*!< Write a 0 has no effect and always reads back a 0               */
    ETFRC_BIT_SOCA_FORCE         = 1,  /*!< Write a 1 generates an interrupt and sets the ETFLG.SOCA flag   */
} ETFRC_BIT_SOCA;

#define ETFRC_ALL_SOCA_NO_EFFECT     ((0x0UL) << ETFRC_ALL_SOCA_Pos)
#define ETFRC_ALL_SOCA_FORCE         ((0x1UL) << ETFRC_ALL_SOCA_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PWM             ETFRC           SOCB
 *  @access     PWM->ETFRC.bit.SOCB
 *  @brief      Software force a start-of-conversion B pulse
 *              This bit is ignored if ETSEL.SOCBEN=0
 */
#define ETFRC_ALL_SOCB_Pos (3)
#define ETFRC_ALL_SOCB_Msk (0x1UL << ETFRC_ALL_SOCB_Pos)

typedef enum
{
    ETFRC_BIT_SOCB_NO_EFFECT     = 0,  /*!< Write a 0 has no effect and always reads back a 0               */
    ETFRC_BIT_SOCB_FORCE         = 1,  /*!< Write a 1 generates an interrupt and sets the ETFLG.SOCB flag   */
} ETFRC_BIT_SOCB;

#define ETFRC_ALL_SOCB_NO_EFFECT     ((0x0UL) << ETFRC_ALL_SOCB_Pos)
#define ETFRC_ALL_SOCB_FORCE         ((0x1UL) << ETFRC_ALL_SOCB_Pos)





/********************************************************************************
*
* Module Name     QSPI
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        EN
 *  @access     QSPI->QSPICTL0.bit.EN
 *  @brief      Serial Select Enable
 */
#define QSPICTL0_ALL_EN_Pos (0)
#define QSPICTL0_ALL_EN_Msk (0x1UL << QSPICTL0_ALL_EN_Pos)

typedef enum
{
    QSPICTL0_BIT_EN_DISABLE     = 0,  /*!< Serial select is de-activated   */
    QSPICTL0_BIT_EN_ENABLE      = 1,  /*!< Serial select is activated      */
} QSPICTL0_BIT_EN;

#define QSPICTL0_ALL_EN_DISABLE     ((0x0UL) << QSPICTL0_ALL_EN_Pos)
#define QSPICTL0_ALL_EN_ENABLE      ((0x1UL) << QSPICTL0_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        RDY
 *  @access     QSPI->QSPICTL0.bit.RDY
 *  @brief      Serial Interface Transfer Ready
 */
#define QSPICTL0_ALL_RDY_Pos (1)
#define QSPICTL0_ALL_RDY_Msk (0x1UL << QSPICTL0_ALL_RDY_Pos)

typedef enum
{
    QSPICTL0_BIT_RDY_TRANSFER_BUSY      = 0,  /*!< Serial Interface is currently transferring data   */
    QSPICTL0_BIT_RDY_TRANSFER_READY     = 1,  /*!< Serial Interface is ready for a new transfer      */
} QSPICTL0_BIT_RDY;

#define QSPICTL0_ALL_RDY_TRANSFER_BUSY      ((0x0UL) << QSPICTL0_ALL_RDY_Pos)
#define QSPICTL0_ALL_RDY_TRANSFER_READY     ((0x1UL) << QSPICTL0_ALL_RDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        RFIFOEMPTY
 *  @access     QSPI->QSPICTL0.bit.RFIFOEMPTY
 *  @brief      Read FIFO Empty
 */
#define QSPICTL0_ALL_RFIFOEMPTY_Pos (4)
#define QSPICTL0_ALL_RFIFOEMPTY_Msk (0x1UL << QSPICTL0_ALL_RFIFOEMPTY_Pos)

typedef enum
{
    QSPICTL0_BIT_RFIFOEMPTY_NOT_OCCUR     = 0,  /*!< Read FIFO is not emptied   */
    QSPICTL0_BIT_RFIFOEMPTY_OCCUR         = 1,  /*!< Read FIFO is emptied       */
} QSPICTL0_BIT_RFIFOEMPTY;

#define QSPICTL0_ALL_RFIFOEMPTY_NOT_OCCUR     ((0x0UL) << QSPICTL0_ALL_RFIFOEMPTY_Pos)
#define QSPICTL0_ALL_RFIFOEMPTY_OCCUR         ((0x1UL) << QSPICTL0_ALL_RFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        RFIFOFULL
 *  @access     QSPI->QSPICTL0.bit.RFIFOFULL
 *  @brief      Read FIFO Full
 */
#define QSPICTL0_ALL_RFIFOFULL_Pos (5)
#define QSPICTL0_ALL_RFIFOFULL_Msk (0x1UL << QSPICTL0_ALL_RFIFOFULL_Pos)

typedef enum
{
    QSPICTL0_BIT_RFIFOFULL_NOT_OCCUR     = 0,  /*!< Read FIFO is not filled   */
    QSPICTL0_BIT_RFIFOFULL_OCCUR         = 1,  /*!< Read FIFO is filled       */
} QSPICTL0_BIT_RFIFOFULL;

#define QSPICTL0_ALL_RFIFOFULL_NOT_OCCUR     ((0x0UL) << QSPICTL0_ALL_RFIFOFULL_Pos)
#define QSPICTL0_ALL_RFIFOFULL_OCCUR         ((0x1UL) << QSPICTL0_ALL_RFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        WFIFOEMPTY
 *  @access     QSPI->QSPICTL0.bit.WFIFOEMPTY
 *  @brief      Write FIFO Empty
 */
#define QSPICTL0_ALL_WFIFOEMPTY_Pos (6)
#define QSPICTL0_ALL_WFIFOEMPTY_Msk (0x1UL << QSPICTL0_ALL_WFIFOEMPTY_Pos)

typedef enum
{
    QSPICTL0_BIT_WFIFOEMPTY_NOT_OCCUR     = 0,  /*!< Write FIFO is not emptied   */
    QSPICTL0_BIT_WFIFOEMPTY_OCCUR         = 1,  /*!< Write FIFO is emptied       */
} QSPICTL0_BIT_WFIFOEMPTY;

#define QSPICTL0_ALL_WFIFOEMPTY_NOT_OCCUR     ((0x0UL) << QSPICTL0_ALL_WFIFOEMPTY_Pos)
#define QSPICTL0_ALL_WFIFOEMPTY_OCCUR         ((0x1UL) << QSPICTL0_ALL_WFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        WFIFOFULL
 *  @access     QSPI->QSPICTL0.bit.WFIFOFULL
 *  @brief      Write FIFO Full
 */
#define QSPICTL0_ALL_WFIFOFULL_Pos (7)
#define QSPICTL0_ALL_WFIFOFULL_Msk (0x1UL << QSPICTL0_ALL_WFIFOFULL_Pos)

typedef enum
{
    QSPICTL0_BIT_WFIFOFULL_NOT_OCCUR     = 0,  /*!< Write FIFO is not filled   */
    QSPICTL0_BIT_WFIFOFULL_OCCUR         = 1,  /*!< Write FIFO is filled       */
} QSPICTL0_BIT_WFIFOFULL;

#define QSPICTL0_ALL_WFIFOFULL_NOT_OCCUR     ((0x0UL) << QSPICTL0_ALL_WFIFOFULL_Pos)
#define QSPICTL0_ALL_WFIFOFULL_OCCUR         ((0x1UL) << QSPICTL0_ALL_WFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        RFIFOUDF
 *  @access     QSPI->QSPICTL0.bit.RFIFOUDF
 *  @brief      Read FIFO Underflow
 */
#define QSPICTL0_ALL_RFIFOUDF_Pos (8)
#define QSPICTL0_ALL_RFIFOUDF_Msk (0x1UL << QSPICTL0_ALL_RFIFOUDF_Pos)

typedef enum
{
    QSPICTL0_BIT_RFIFOUDF_NOT_OCCUR     = 0,  /*!< Read FIFO is not underflowed   */
    QSPICTL0_BIT_RFIFOUDF_OCCUR         = 1,  /*!< Read FIFO is underflowed       */
} QSPICTL0_BIT_RFIFOUDF;

#define QSPICTL0_ALL_RFIFOUDF_NOT_OCCUR     ((0x0UL) << QSPICTL0_ALL_RFIFOUDF_Pos)
#define QSPICTL0_ALL_RFIFOUDF_OCCUR         ((0x1UL) << QSPICTL0_ALL_RFIFOUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        RFIFOOVF
 *  @access     QSPI->QSPICTL0.bit.RFIFOOVF
 *  @brief      Read FIFO Overflow
 */
#define QSPICTL0_ALL_RFIFOOVF_Pos (9)
#define QSPICTL0_ALL_RFIFOOVF_Msk (0x1UL << QSPICTL0_ALL_RFIFOOVF_Pos)

typedef enum
{
    QSPICTL0_BIT_RFIFOOVF_NOT_OCCUR     = 0,  /*!< Read FIFO is not overflowed   */
    QSPICTL0_BIT_RFIFOOVF_OCCUR         = 1,  /*!< Read FIFO is overflowed       */
} QSPICTL0_BIT_RFIFOOVF;

#define QSPICTL0_ALL_RFIFOOVF_NOT_OCCUR     ((0x0UL) << QSPICTL0_ALL_RFIFOOVF_Pos)
#define QSPICTL0_ALL_RFIFOOVF_OCCUR         ((0x1UL) << QSPICTL0_ALL_RFIFOOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        WFIFOUDF
 *  @access     QSPI->QSPICTL0.bit.WFIFOUDF
 *  @brief      Write FIFO Underflow
 */
#define QSPICTL0_ALL_WFIFOUDF_Pos (10)
#define QSPICTL0_ALL_WFIFOUDF_Msk (0x1UL << QSPICTL0_ALL_WFIFOUDF_Pos)

typedef enum
{
    QSPICTL0_BIT_WFIFOUDF_NOT_OCCUR     = 0,  /*!< Write FIFO is not underflowed   */
    QSPICTL0_BIT_WFIFOUDF_OCCUR         = 1,  /*!< Write FIFO is underflowed       */
} QSPICTL0_BIT_WFIFOUDF;

#define QSPICTL0_ALL_WFIFOUDF_NOT_OCCUR     ((0x0UL) << QSPICTL0_ALL_WFIFOUDF_Pos)
#define QSPICTL0_ALL_WFIFOUDF_OCCUR         ((0x1UL) << QSPICTL0_ALL_WFIFOUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL0        WFIFOOVF
 *  @access     QSPI->QSPICTL0.bit.WFIFOOVF
 *  @brief      Write FIFO Overflow
 */
#define QSPICTL0_ALL_WFIFOOVF_Pos (11)
#define QSPICTL0_ALL_WFIFOOVF_Msk (0x1UL << QSPICTL0_ALL_WFIFOOVF_Pos)

typedef enum
{
    QSPICTL0_BIT_WFIFOOVF_NOT_OCCUR     = 0,  /*!< Write FIFO is not overflowed   */
    QSPICTL0_BIT_WFIFOOVF_OCCUR         = 1,  /*!< Write FIFO is overflowed       */
} QSPICTL0_BIT_WFIFOOVF;

#define QSPICTL0_ALL_WFIFOOVF_NOT_OCCUR     ((0x0UL) << QSPICTL0_ALL_WFIFOOVF_Pos)
#define QSPICTL0_ALL_WFIFOOVF_OCCUR         ((0x1UL) << QSPICTL0_ALL_WFIFOOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        CLKDIV
 *  @access     QSPI->QSPICTL1.bit.CLKDIV
 *  @brief      Serial Interface Clock Prescaler (from SPI clock)
 */
#define QSPICTL1_ALL_CLKDIV_Pos (0)
#define QSPICTL1_ALL_CLKDIV_Msk (0x1FUL << QSPICTL1_ALL_CLKDIV_Pos)

typedef enum
{
    QSPICTL1_BIT_CLKDIV_1      = 0,  /*!< SPI clock/1    */
    QSPICTL1_BIT_CLKDIV_2      = 2,  /*!< SPI clock/2    */
    QSPICTL1_BIT_CLKDIV_3      = 3,  /*!< SPI clock/3    */
    QSPICTL1_BIT_CLKDIV_4      = 4,  /*!< SPI clock/4    */
    QSPICTL1_BIT_CLKDIV_5      = 5,  /*!< SPI clock/5    */
    QSPICTL1_BIT_CLKDIV_6      = 6,  /*!< SPI clock/6    */
    QSPICTL1_BIT_CLKDIV_7      = 7,  /*!< SPI clock/7    */
    QSPICTL1_BIT_CLKDIV_8      = 8,  /*!< SPI clock/8    */
    QSPICTL1_BIT_CLKDIV_9      = 9,  /*!< SPI clock/9    */
    QSPICTL1_BIT_CLKDIV_10     = 10,  /*!< SPI clock/10   */
    QSPICTL1_BIT_CLKDIV_11     = 11,  /*!< SPI clock/11   */
    QSPICTL1_BIT_CLKDIV_12     = 12,  /*!< SPI clock/12   */
    QSPICTL1_BIT_CLKDIV_13     = 13,  /*!< SPI clock/13   */
    QSPICTL1_BIT_CLKDIV_14     = 14,  /*!< SPI clock/14   */
    QSPICTL1_BIT_CLKDIV_15     = 15,  /*!< SPI clock/15   */
    QSPICTL1_BIT_CLKDIV_16     = 24,  /*!< SPI clock/16   */
    QSPICTL1_BIT_CLKDIV_18     = 25,  /*!< SPI clock/18   */
    QSPICTL1_BIT_CLKDIV_20     = 26,  /*!< SPI clock/20   */
    QSPICTL1_BIT_CLKDIV_22     = 27,  /*!< SPI clock/22   */
    QSPICTL1_BIT_CLKDIV_24     = 28,  /*!< SPI clock/24   */
    QSPICTL1_BIT_CLKDIV_26     = 29,  /*!< SPI clock/26   */
    QSPICTL1_BIT_CLKDIV_28     = 30,  /*!< SPI clock/28   */
    QSPICTL1_BIT_CLKDIV_30     = 31,  /*!< SPI clock/30   */
} QSPICTL1_BIT_CLKDIV;

#define QSPICTL1_ALL_CLKDIV_1      ((0x00UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_2      ((0x02UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_3      ((0x03UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_4      ((0x04UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_5      ((0x05UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_6      ((0x06UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_7      ((0x07UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_8      ((0x08UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_9      ((0x09UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_10     ((0x0AUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_11     ((0x0BUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_12     ((0x0CUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_13     ((0x0DUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_14     ((0x0EUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_15     ((0x0FUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_16     ((0x18UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_18     ((0x19UL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_20     ((0x1AUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_22     ((0x1BUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_24     ((0x1CUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_26     ((0x1DUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_28     ((0x1EUL) << QSPICTL1_ALL_CLKDIV_Pos)
#define QSPICTL1_ALL_CLKDIV_30     ((0x1FUL) << QSPICTL1_ALL_CLKDIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        BYTELEN
 *  @access     QSPI->QSPICTL1.bit.BYTELEN
 *  @brief      Byte Length
 *              The number of bytes in each serial interface I/O transfer.
 */
#define QSPICTL1_ALL_BYTELEN_Pos (5)
#define QSPICTL1_ALL_BYTELEN_Msk (0x1UL << QSPICTL1_ALL_BYTELEN_Pos)

typedef enum
{
    QSPICTL1_BIT_BYTELEN_1_BYTE     = 0,  /*!< 1 byte    */
    QSPICTL1_BIT_BYTELEN_4_BYTE     = 1,  /*!< 4 bytes   */
} QSPICTL1_BIT_BYTELEN;

#define QSPICTL1_ALL_BYTELEN_1_BYTE     ((0x0UL) << QSPICTL1_ALL_BYTELEN_Pos)
#define QSPICTL1_ALL_BYTELEN_4_BYTE     ((0x1UL) << QSPICTL1_ALL_BYTELEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        CLKPHS
 *  @access     QSPI->QSPICTL1.bit.CLKPHS
 *  @brief      Serial Interface Clock Phase
 */
#define QSPICTL1_ALL_CLKPHS_Pos (7)
#define QSPICTL1_ALL_CLKPHS_Msk (0x1UL << QSPICTL1_ALL_CLKPHS_Pos)

typedef enum
{
    QSPICTL1_BIT_CLKPHS_MODE_0     = 0,  /*!< Data is latched at the rising edge of the serial interface clock when CLKPOL (R04h [8]) = 0, and at the falling edge of the serial interface clock when CLKPOL = 1   */
    QSPICTL1_BIT_CLKPHS_MODE_1     = 1,  /*!< Data is latched at the falling edge of the serial interface clock when CLK_POL = 0, and at the rising edge of the serial interface clock when CLK_POL = 1            */
} QSPICTL1_BIT_CLKPHS;

#define QSPICTL1_ALL_CLKPHS_MODE_0     ((0x0UL) << QSPICTL1_ALL_CLKPHS_Pos)
#define QSPICTL1_ALL_CLKPHS_MODE_1     ((0x1UL) << QSPICTL1_ALL_CLKPHS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        CLKPOL
 *  @access     QSPI->QSPICTL1.bit.CLKPOL
 *  @brief      Serial Interface Clock Polarity
 */
#define QSPICTL1_ALL_CLKPOL_Pos (8)
#define QSPICTL1_ALL_CLKPOL_Msk (0x1UL << QSPICTL1_ALL_CLKPOL_Pos)

typedef enum
{
    QSPICTL1_BIT_CLKPOL_INACTIVE_LOW      = 0,  /*!< Serial interface clock is low when inactive    */
    QSPICTL1_BIT_CLKPOL_INACTIVE_HIGH     = 1,  /*!< Serial interface clock is high when inactive   */
} QSPICTL1_BIT_CLKPOL;

#define QSPICTL1_ALL_CLKPOL_INACTIVE_LOW      ((0x0UL) << QSPICTL1_ALL_CLKPOL_Pos)
#define QSPICTL1_ALL_CLKPOL_INACTIVE_HIGH     ((0x1UL) << QSPICTL1_ALL_CLKPOL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        FIFOFLUSH
 *  @access     QSPI->QSPICTL1.bit.FIFOFLUSH
 *  @brief      Flush Read and Write FIFOs
 *              This bit flushes the Read and Write FIFOs. The FIFOs are emptied after being flushed. Hardware resets this bit to 0 after flushing.
 */
#define QSPICTL1_ALL_FIFOFLUSH_Pos (9)
#define QSPICTL1_ALL_FIFOFLUSH_Msk (0x1UL << QSPICTL1_ALL_FIFOFLUSH_Pos)

typedef enum
{
    QSPICTL1_BIT_FIFOFLUSH_NOT_FLUSH     = 0,  /*!< Read and Write FIFOs are not flushed   */
    QSPICTL1_BIT_FIFOFLUSH_FLUSH         = 1,  /*!< Read and Write FIFOs are flushed       */
} QSPICTL1_BIT_FIFOFLUSH;

#define QSPICTL1_ALL_FIFOFLUSH_NOT_FLUSH     ((0x0UL) << QSPICTL1_ALL_FIFOFLUSH_Pos)
#define QSPICTL1_ALL_FIFOFLUSH_FLUSH         ((0x1UL) << QSPICTL1_ALL_FIFOFLUSH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        DATAPIN
 *  @access     QSPI->QSPICTL1.bit.DATAPIN
 *  @brief      Data Transfer Pin
 *              Number of pins used for transferring the non-command and nonaddress portions of each serial interface I/O transfer.
 */
#define QSPICTL1_ALL_DATAPIN_Pos (10)
#define QSPICTL1_ALL_DATAPIN_Msk (0x3UL << QSPICTL1_ALL_DATAPIN_Pos)

typedef enum
{
    QSPICTL1_BIT_DATAPIN_1_PIN     = 0,  /*!< Use 1 serial interface pin (use in single mode)   */
    QSPICTL1_BIT_DATAPIN_2_PIN     = 1,  /*!< Use 2 serial interface pins (use in dual mode)    */
    QSPICTL1_BIT_DATAPIN_3_PIN     = 2,  /*!< Use 4 serial interface pins (use in quad mode)    */
} QSPICTL1_BIT_DATAPIN;

#define QSPICTL1_ALL_DATAPIN_1_PIN     ((0x0UL) << QSPICTL1_ALL_DATAPIN_Pos)
#define QSPICTL1_ALL_DATAPIN_2_PIN     ((0x1UL) << QSPICTL1_ALL_DATAPIN_Pos)
#define QSPICTL1_ALL_DATAPIN_3_PIN     ((0x2UL) << QSPICTL1_ALL_DATAPIN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        ADDRPIN
 *  @access     QSPI->QSPICTL1.bit.ADDRPIN
 *  @brief      Address Transfer Pin
 *              Number of pins used for transferring the content of the Addr (R14h) register.
 */
#define QSPICTL1_ALL_ADDRPIN_Pos (12)
#define QSPICTL1_ALL_ADDRPIN_Msk (0x1UL << QSPICTL1_ALL_ADDRPIN_Pos)

typedef enum
{
    QSPICTL1_BIT_ADDRPIN_1_PIN            = 0,  /*!< Use one serial interface pin                                    */
    QSPICTL1_BIT_ADDRPIN_NUM_DATA_PIN     = 1,  /*!< Use the number of pins as indicated in DATAPIN (R04h [11:10])   */
} QSPICTL1_BIT_ADDRPIN;

#define QSPICTL1_ALL_ADDRPIN_1_PIN            ((0x0UL) << QSPICTL1_ALL_ADDRPIN_Pos)
#define QSPICTL1_ALL_ADDRPIN_NUM_DATA_PIN     ((0x1UL) << QSPICTL1_ALL_ADDRPIN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        WEN
 *  @access     QSPI->QSPICTL1.bit.WEN
 *  @brief      Write Enable
 */
#define QSPICTL1_ALL_WEN_Pos (13)
#define QSPICTL1_ALL_WEN_Msk (0x1UL << QSPICTL1_ALL_WEN_Pos)

typedef enum
{
    QSPICTL1_BIT_WEN_READ      = 0,  /*!< Read data from the serial interface   */
    QSPICTL1_BIT_WEN_WRITE     = 1,  /*!< Write data to the serial interface    */
} QSPICTL1_BIT_WEN;

#define QSPICTL1_ALL_WEN_READ      ((0x0UL) << QSPICTL1_ALL_WEN_Pos)
#define QSPICTL1_ALL_WEN_WRITE     ((0x1UL) << QSPICTL1_ALL_WEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        STOP
 *  @access     QSPI->QSPICTL1.bit.STOP
 *  @brief      Transfer Stop
 *              This bit stops the serial interface I/O transfer.
 *              The transfer stops at either a 1-byte or 4-byte boundary,
 *              depending on the setting of BYTELEN (R04h [5]). Once
 *              the byte boundary is reached, the hardware resets START (R04h [15]) to 0. Hardware resets this bit to 0 after START has been reset.
 */
#define QSPICTL1_ALL_STOP_Pos (14)
#define QSPICTL1_ALL_STOP_Msk (0x1UL << QSPICTL1_ALL_STOP_Pos)

typedef enum
{
    QSPICTL1_BIT_STOP_TRANSFER_CONTINUE     = 0,  /*!< Continue current transfer   */
    QSPICTL1_BIT_STOP_TRANSFER_STOP         = 1,  /*!< Stop current transfer       */
} QSPICTL1_BIT_STOP;

#define QSPICTL1_ALL_STOP_TRANSFER_CONTINUE     ((0x0UL) << QSPICTL1_ALL_STOP_Pos)
#define QSPICTL1_ALL_STOP_TRANSFER_STOP         ((0x1UL) << QSPICTL1_ALL_STOP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL1        START
 *  @access     QSPI->QSPICTL1.bit.START
 *  @brief      Transfer Start
 *              This bit starts the serial interface I/O transfer.
 *              For read transfers, WEN (R04[13]) = 0, the hardware
 *              resets this bit to 0 when the number of bytes indicated in QSPIDINCNT(R20h) register have been read in from the interface.
 *              For write transfers, WEN (R04[13]) = 1, firmware sets
 *              STOP (R04h [14]) = 1 when all data have been written to the WFIFO and WFIFOEMPTY (R00h [6]) = 1. Hardware resets this bit to 0 when all data have been written out the interface.
 */
#define QSPICTL1_ALL_START_Pos (15)
#define QSPICTL1_ALL_START_Msk (0x1UL << QSPICTL1_ALL_START_Pos)

typedef enum
{
    QSPICTL1_BIT_START_TRANSFER_COMPLETED     = 0,  /*!< Transfer has completed   */
    QSPICTL1_BIT_START_TRANSFER_START         = 1,  /*!< Transfer has started     */
} QSPICTL1_BIT_START;

#define QSPICTL1_ALL_START_TRANSFER_COMPLETED     ((0x0UL) << QSPICTL1_ALL_START_Pos)
#define QSPICTL1_ALL_START_TRANSFER_START         ((0x1UL) << QSPICTL1_ALL_START_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIDOUT        VAL
 *  @access     QSPI->QSPIDOUT.bit.VAL
 *  @brief      Serial Interface Data Out
 *              Writing to this register stores the data in a 8X32 bit Write
 *              FIFO. After the contents of the Instruction register (R10h), the Address register (R14h), the Read Mode register (R18h) and Dummy value are transferred out to the serial interface, the data in the Write FIFO is shifted out. The serial interface clock stops when a Write FIFO empty condition occurs, WFIFOEMPTY (R00h [6]) = 1. The clock restarts when Write FIFO is not empty, WFIFOEMPTY (R00h [6]) = 0.
 *              When BYTELEN (R04h [5]) = 0, bits [7:0] are shifted out
 *              with bit 7 shifted out first and bit 0 shifted out last. When BYTELEN (R04h [5]) = 1, bits [7:0] are shifted out (bit 7 shifted out first and bit 0 shifted out last), followed by bits [15:8] (bit 15 shifted out first and bit 8 shifted out last), then bits [23:16] (bit 23 shifted out first and bit 16 shifted out last) and finally bits [31:24] (bit 31 shifted out first and bit 24 shifted out last).
 *              Note: To avoid a Write FIFO overflow condition (WFIFOOVFW (R00h [11]) = 1), check WFIFOFULL (R00h [7]) is equal to 0 before writing to this register.
 */
#define QSPIDOUT_ALL_VAL_Pos (0)
#define QSPIDOUT_ALL_VAL_Msk (0xFFFFFFFFUL << QSPIDOUT_ALL_VAL_Pos)

#define QSPIDOUT_BIT_VAL

#define QSPIDOUT_ALL_VAL_(x) ((x) << QSPIDOUT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIDIN         VAL
 *  @access     QSPI->QSPIDIN.bit.VAL
 *  @brief      Serial Interface Data In
 *              For read transfers, WEN (R04h [13]) = 0, data from the
 *              serial interface input pins are shifted in and stores in a 8X32 bit Read FIFO. The contents of the Read FIFO is read from this register. The serial interface clock stops when a Read FIFO full condition occurs, RFIFOFULL (R00h [5]) = 1. The clock restarts when Read FIFO is not full, RFIFOFULL (R00h [5]) = 0. When BYTELEN (R04h [5]) = 0, data is shifted into bits [7:0]. When BYTELEN (R04h [5]) = 1, data is shifted into bits [7:0] first, followed by bits [15:8], then bits [23:16] and finally bits [31:24].
 *              Note: To avoid a Read FIFO underflow condition,
 *              RFIFOUDF (R00h [8]) = 1, check RFIFOEMPTY (R00h [4]) is equal to 0 before reading this register.
 */
#define QSPIDIN_ALL_VAL_Pos (0)
#define QSPIDIN_ALL_VAL_Msk (0xFFFFFFFFUL << QSPIDIN_ALL_VAL_Pos)

#define QSPIDIN_BIT_VAL

#define QSPIDIN_ALL_VAL_(x) ((x) << QSPIDIN_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICMD         VAL
 *  @access     QSPI->QSPICMD.bit.VAL
 *  @brief      Serial Interface Instruction
 *              After START (R04h [15]) is set to 1, the content of this register is shifted out to the serial interface. When CMDCNT (R1Ch [1:0]) = 0, the content of this register is not shifted out to the serial interface. When CMDCNT (R1Ch [1:0]) = 1, bits [7:0] are shifted out. When CMDCNT (R1Ch [1:0]) = 2, bits [15:8] are shifted out first, followed by bits [7:0].
 */
#define QSPICMD_ALL_VAL_Pos (0)
#define QSPICMD_ALL_VAL_Msk (0xFFFFUL << QSPICMD_ALL_VAL_Pos)

#define QSPICMD_BIT_VAL

#define QSPICMD_ALL_VAL_(x) ((x) << QSPICMD_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIADDR        VAL
 *  @access     QSPI->QSPIADDR.bit.VAL
 *  @brief      Serial Interface Address
 *              After QSPICMD (R10h) is shifted out, the content of this register is shifted out to the serial interface.
 *              When ADDRCNT (R1Ch [6:4]) = 0, the content of this register is not shifted out to the serial interface.
 *              When ADDRCNT (R1Ch [6:4]) = 1, bits [7:0] are shifted out.
 *              When ADDRCNT (R1Ch [6:4]) = 2, bits [15:8] are shifted
 *              out first, followed by bits [7:0].
 *              When ADDRCNT (R1Ch [6:4]) = 3, bits [23:16] are shifted
 *              out first, followed by bits [15:8], then bits [7:0].
 *              When ADDRCNT (R1Ch [6:4]) = 4, bits [31:24] are shifted
 *              out first, followed by bits [23:16], then bits [15:8] and finally bits [7:0].
 */
#define QSPIADDR_ALL_VAL_Pos (0)
#define QSPIADDR_ALL_VAL_Msk (0xFFFFFFFFUL << QSPIADDR_ALL_VAL_Pos)

#define QSPIADDR_BIT_VAL

#define QSPIADDR_ALL_VAL_(x) ((x) << QSPIADDR_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRMODE       VAL
 *  @access     QSPI->QSPIRMODE.bit.VAL
 *  @brief      Serial Interface Read Mode
 *              After QSPIADDR(R14h) is shifted out, the content of this register is shifted out to the serial interface.
 *              When RMODECNT (R1Ch [9:8]) = 0, the content of this register is not shifted out to the serial interface.
 *              When RMODECNT (R1Ch [9:8]) = 1, bits [7:0] are shifted out.
 *              When RMODECNT (R1Ch [9:8]) = 2, bits [15:8] are shifted out first, followed by bits [7:0].
 */
#define QSPIRMODE_ALL_VAL_Pos (0)
#define QSPIRMODE_ALL_VAL_Msk (0xFFFFUL << QSPIRMODE_ALL_VAL_Pos)

#define QSPIRMODE_BIT_VAL

#define QSPIRMODE_ALL_VAL_(x) ((x) << QSPIRMODE_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIHEADER      CMDCNT
 *  @access     QSPI->QSPIHEADER.bit.CMDCNT
 *  @brief      Instruction Count
 *              Number of bytes in QSPICMD (R10h) register to shift out to the serial interface.
 */
#define QSPIHEADER_ALL_CMDCNT_Pos (0)
#define QSPIHEADER_ALL_CMDCNT_Msk (0x3UL << QSPIHEADER_ALL_CMDCNT_Pos)

typedef enum
{
    QSPIHEADER_BIT_CMDCNT_0_BYTE     = 0,  /*!< 0 byte    */
    QSPIHEADER_BIT_CMDCNT_1_BYTE     = 1,  /*!< 1 byte    */
    QSPIHEADER_BIT_CMDCNT_2_BYTE     = 2,  /*!< 2 bytes   */
} QSPIHEADER_BIT_CMDCNT;

#define QSPIHEADER_ALL_CMDCNT_0_BYTE     ((0x0UL) << QSPIHEADER_ALL_CMDCNT_Pos)
#define QSPIHEADER_ALL_CMDCNT_1_BYTE     ((0x1UL) << QSPIHEADER_ALL_CMDCNT_Pos)
#define QSPIHEADER_ALL_CMDCNT_2_BYTE     ((0x2UL) << QSPIHEADER_ALL_CMDCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIHEADER      ADDRCNT
 *  @access     QSPI->QSPIHEADER.bit.ADDRCNT
 *  @brief      Address Count
 *              Number of bytes in QSPIADDR (R14h) register to shift out to the serial interface.
 */
#define QSPIHEADER_ALL_ADDRCNT_Pos (4)
#define QSPIHEADER_ALL_ADDRCNT_Msk (0x7UL << QSPIHEADER_ALL_ADDRCNT_Pos)

typedef enum
{
    QSPIHEADER_BIT_ADDRCNT_0_BYTE     = 0,  /*!< 0 byte    */
    QSPIHEADER_BIT_ADDRCNT_1_BYTE     = 1,  /*!< 1 byte    */
    QSPIHEADER_BIT_ADDRCNT_2_BYTE     = 2,  /*!< 2 bytes   */
    QSPIHEADER_BIT_ADDRCNT_3_BYTE     = 3,  /*!< 3 bytes   */
    QSPIHEADER_BIT_ADDRCNT_4_BYTE     = 4,  /*!< 4 bytes   */
} QSPIHEADER_BIT_ADDRCNT;

#define QSPIHEADER_ALL_ADDRCNT_0_BYTE     ((0x0UL) << QSPIHEADER_ALL_ADDRCNT_Pos)
#define QSPIHEADER_ALL_ADDRCNT_1_BYTE     ((0x1UL) << QSPIHEADER_ALL_ADDRCNT_Pos)
#define QSPIHEADER_ALL_ADDRCNT_2_BYTE     ((0x2UL) << QSPIHEADER_ALL_ADDRCNT_Pos)
#define QSPIHEADER_ALL_ADDRCNT_3_BYTE     ((0x3UL) << QSPIHEADER_ALL_ADDRCNT_Pos)
#define QSPIHEADER_ALL_ADDRCNT_4_BYTE     ((0x4UL) << QSPIHEADER_ALL_ADDRCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIHEADER      RMODECNT
 *  @access     QSPI->QSPIHEADER.bit.RMODECNT
 *  @brief      Read Mode Count
 *              Number of bytes in QSPIRMODE (R18h) register to shift out to the serial interface.
 */
#define QSPIHEADER_ALL_RMODECNT_Pos (8)
#define QSPIHEADER_ALL_RMODECNT_Msk (0x3UL << QSPIHEADER_ALL_RMODECNT_Pos)

typedef enum
{
    QSPIHEADER_BIT_RMODECNT_0_BYTE     = 0,  /*!< 0 byte    */
    QSPIHEADER_BIT_RMODECNT_1_BYTE     = 1,  /*!< 1 byte    */
    QSPIHEADER_BIT_RMODECNT_2_BYTE     = 2,  /*!< 2 bytes   */
} QSPIHEADER_BIT_RMODECNT;

#define QSPIHEADER_ALL_RMODECNT_0_BYTE     ((0x0UL) << QSPIHEADER_ALL_RMODECNT_Pos)
#define QSPIHEADER_ALL_RMODECNT_1_BYTE     ((0x1UL) << QSPIHEADER_ALL_RMODECNT_Pos)
#define QSPIHEADER_ALL_RMODECNT_2_BYTE     ((0x2UL) << QSPIHEADER_ALL_RMODECNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIHEADER      DMYCNT
 *  @access     QSPI->QSPIHEADER.bit.DMYCNT
 *  @brief      Dummy Count
 *              Number of bytes to shift out to the serial interface after the content of QSPIRMODE (R18h) register is shifted out.
 *              Note: The value being shifted out is 0.
 */
#define QSPIHEADER_ALL_DMYCNT_Pos (12)
#define QSPIHEADER_ALL_DMYCNT_Msk (0x3UL << QSPIHEADER_ALL_DMYCNT_Pos)

typedef enum
{
    QSPIHEADER_BIT_DMYCNT_0_BYTE     = 0,  /*!< 0 byte    */
    QSPIHEADER_BIT_DMYCNT_1_BYTE     = 1,  /*!< 1 byte    */
    QSPIHEADER_BIT_DMYCNT_2_BYTE     = 2,  /*!< 2 bytes   */
    QSPIHEADER_BIT_DMYCNT_3_BYTE     = 3,  /*!< 3 bytes   */
} QSPIHEADER_BIT_DMYCNT;

#define QSPIHEADER_ALL_DMYCNT_0_BYTE     ((0x0UL) << QSPIHEADER_ALL_DMYCNT_Pos)
#define QSPIHEADER_ALL_DMYCNT_1_BYTE     ((0x1UL) << QSPIHEADER_ALL_DMYCNT_Pos)
#define QSPIHEADER_ALL_DMYCNT_2_BYTE     ((0x2UL) << QSPIHEADER_ALL_DMYCNT_Pos)
#define QSPIHEADER_ALL_DMYCNT_3_BYTE     ((0x3UL) << QSPIHEADER_ALL_DMYCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIDINCNT      VAL
 *  @access     QSPI->QSPIDINCNT.bit.VAL
 *  @brief      Serial Interface Data In Count
 *              For read transfers, WEN (R04h [13]) = 0, this register indicates the number of bytes of data to shift in from the
 *              serial interface and stores in the 8X32 bit Read FIFO. When this register is set to 0, data is shifted in continuously until STOP (R04h [14]) bit is set to 1 by firmware.
 */
#define QSPIDINCNT_ALL_VAL_Pos (0)
#define QSPIDINCNT_ALL_VAL_Msk (0xFFFFFUL << QSPIDINCNT_ALL_VAL_Pos)

#define QSPIDINCNT_BIT_VAL

#define QSPIDINCNT_ALL_VAL_(x) ((x) << QSPIDINCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPITIMING      DINDLY
 *  @access     QSPI->QSPITIMING.bit.DINDLY
 *  @brief      Serial Interface Data Input Delay
 *              Delay the transfer of captured serial input data to the read register.
 */
#define QSPITIMING_ALL_DINDLY_Pos (0)
#define QSPITIMING_ALL_DINDLY_Msk (0x3UL << QSPITIMING_ALL_DINDLY_Pos)

typedef enum
{
    QSPITIMING_BIT_DINDLY_NO_DELAY        = 0,  /*!< No delay                         */
    QSPITIMING_BIT_DINDLY_1_CLK_DELAY     = 1,  /*!< 1 serial interface clock delay   */
    QSPITIMING_BIT_DINDLY_2_CLK_DELAY     = 2,  /*!< 2 serial interface clock delay   */
} QSPITIMING_BIT_DINDLY;

#define QSPITIMING_ALL_DINDLY_NO_DELAY        ((0x0UL) << QSPITIMING_ALL_DINDLY_Pos)
#define QSPITIMING_ALL_DINDLY_1_CLK_DELAY     ((0x1UL) << QSPITIMING_ALL_DINDLY_Pos)
#define QSPITIMING_ALL_DINDLY_2_CLK_DELAY     ((0x2UL) << QSPITIMING_ALL_DINDLY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPITIMING      CLKINDLY
 *  @access     QSPI->QSPITIMING.bit.CLKINDLY
 *  @brief      Serial Interface Clock In Delay
 *              Programmable delay added to the serial interface input data capture clock.
 */
#define QSPITIMING_ALL_CLKINDLY_Pos (4)
#define QSPITIMING_ALL_CLKINDLY_Msk (0x3UL << QSPITIMING_ALL_CLKINDLY_Pos)

typedef enum
{
    QSPITIMING_BIT_CLKINDLY_NO_DELAY           = 0,  /*!< No delay           */
    QSPITIMING_BIT_CLKINDLY_0dot2_NS_DELAY     = 1,  /*!< Add 0.2 ns delay   */
    QSPITIMING_BIT_CLKINDLY_0dot4_NS_DELAY     = 2,  /*!< Add 0.4 ns delay   */
    QSPITIMING_BIT_CLKINDLY_0dot6_NS_DELAY     = 3,  /*!< Add 0.6 ns delay   */
} QSPITIMING_BIT_CLKINDLY;

#define QSPITIMING_ALL_CLKINDLY_NO_DELAY           ((0x0UL) << QSPITIMING_ALL_CLKINDLY_Pos)
#define QSPITIMING_ALL_CLKINDLY_0dot2_NS_DELAY     ((0x1UL) << QSPITIMING_ALL_CLKINDLY_Pos)
#define QSPITIMING_ALL_CLKINDLY_0dot4_NS_DELAY     ((0x2UL) << QSPITIMING_ALL_CLKINDLY_Pos)
#define QSPITIMING_ALL_CLKINDLY_0dot6_NS_DELAY     ((0x3UL) << QSPITIMING_ALL_CLKINDLY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPITIMING      CLKEDGE
 *  @access     QSPI->QSPITIMING.bit.CLKEDGE
 *  @brief      Serial Interface Capture Clock Edge
 *              Capture serial interface input data on either the rising or
 *              falling edge of the serial interface clock. This bit is used to allow more time to capture the input data.
 *              When CLKPOL (R04h [8]) = 0 and CLKPHA (R04h [7]) =
 *              1, capture input data on the falling edge of the serial
 *              interface clock.
 *              When CLKPOL (R04h [8]) = 1 and CLKPHA (R04h [7]) =
 *              0, capture input data on the falling edge of the serial
 *              interface clock.
 *              When CLKPOL (R04h [8]) = 1 and CLKPHA (R04h [7]) =
 *              1, capture input data on the rising edge of the serial
 *              interface clock.
 *              When CLKPOL (R04h [8]) = 1 and CLKPHA (R04h [7]) =
 *              0, capture input data on the rising edge of the serial
 *              interface clock.
 *              Note: When CLKPHA (R04h [7]) = 1, this bit must be set
 *              to 0.
 */
#define QSPITIMING_ALL_CLKEDGE_Pos (6)
#define QSPITIMING_ALL_CLKEDGE_Msk (0x1UL << QSPITIMING_ALL_CLKEDGE_Pos)

typedef enum
{
    QSPITIMING_BIT_CLKEDGE_MODE_0     = 0,  /*!< When CLKPOL (R04h [8]) = 0 and CLKPHA (R04h[7]) = 0, capture input data on rising edge of the serial interface clock.          */
    QSPITIMING_BIT_CLKEDGE_MODE_1     = 1,  /*!< When CLK_POL (R04h [8]) = 0 and CLK_PHA (R04h[7]) = 0, capture input data on the falling edge of the serial interface clock.   */
} QSPITIMING_BIT_CLKEDGE;

#define QSPITIMING_ALL_CLKEDGE_MODE_0     ((0x0UL) << QSPITIMING_ALL_CLKEDGE_Pos)
#define QSPITIMING_ALL_CLKEDGE_MODE_1     ((0x1UL) << QSPITIMING_ALL_CLKEDGE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPITIMING      CLKOUTDLY
 *  @access     QSPI->QSPITIMING.bit.CLKOUTDLY
 *  @brief      Serial Interface Clock Out Delay
 *              Programmable delay added to the serial interface output clock to adjust the timing.
 */
#define QSPITIMING_ALL_CLKOUTDLY_Pos (8)
#define QSPITIMING_ALL_CLKOUTDLY_Msk (0x3UL << QSPITIMING_ALL_CLKOUTDLY_Pos)

typedef enum
{
    QSPITIMING_BIT_CLKOUTDLY_NO_DELAY           = 0,  /*!< No delay           */
    QSPITIMING_BIT_CLKOUTDLY_0dot2_NS_DELAY     = 1,  /*!< Add 0.2 ns delay   */
    QSPITIMING_BIT_CLKOUTDLY_0dot4_NS_DELAY     = 2,  /*!< Add 0.4 ns delay   */
    QSPITIMING_BIT_CLKOUTDLY_0dot6_NS_DELAY     = 3,  /*!< Add 0.6 ns delay   */
} QSPITIMING_BIT_CLKOUTDLY;

#define QSPITIMING_ALL_CLKOUTDLY_NO_DELAY           ((0x0UL) << QSPITIMING_ALL_CLKOUTDLY_Pos)
#define QSPITIMING_ALL_CLKOUTDLY_0dot2_NS_DELAY     ((0x1UL) << QSPITIMING_ALL_CLKOUTDLY_Pos)
#define QSPITIMING_ALL_CLKOUTDLY_0dot4_NS_DELAY     ((0x2UL) << QSPITIMING_ALL_CLKOUTDLY_Pos)
#define QSPITIMING_ALL_CLKOUTDLY_0dot6_NS_DELAY     ((0x3UL) << QSPITIMING_ALL_CLKOUTDLY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPICTL2        SWRST
 *  @access     QSPI->QSPICTL2.bit.SWRST
 *  @brief      Soft Reset
 *              Allows firmware to reset the hardware.
 *              Note: After setting this bit to 1, firmware has to reset this bit to 0 before starting any transfer
 */
#define QSPICTL2_ALL_SWRST_Pos (0)
#define QSPICTL2_ALL_SWRST_Msk (0x1UL << QSPICTL2_ALL_SWRST_Pos)

typedef enum
{
    QSPICTL2_BIT_SWRST_NOT_RESET     = 0,  /*!< Hardware is not in reset                             */
    QSPICTL2_BIT_SWRST_RESET         = 1,  /*!< Hardware is in reset. Mannully set to 0 for reset.   */
} QSPICTL2_BIT_SWRST;

#define QSPICTL2_ALL_SWRST_NOT_RESET     ((0x0UL) << QSPICTL2_ALL_SWRST_Pos)
#define QSPICTL2_ALL_SWRST_RESET         ((0x1UL) << QSPICTL2_ALL_SWRST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          DONE
 *  @access     QSPI->QSPIIF.bit.DONE
 *  @brief      Transfer Done Interrupt Flag
 */
#define QSPIIF_ALL_DONE_Pos (0)
#define QSPIIF_ALL_DONE_Msk (0x1UL << QSPIIF_ALL_DONE_Pos)

typedef enum
{
    QSPIIF_BIT_DONE_NOT_OCCUR     = 0,  /*!< Transfer has not completed after masking   */
    QSPIIF_BIT_DONE_OCCUR         = 1,  /*!< Transfer has completed after masking       */
} QSPIIF_BIT_DONE;

#define QSPIIF_ALL_DONE_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_DONE_Pos)
#define QSPIIF_ALL_DONE_OCCUR         ((0x1UL) << QSPIIF_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          RDY
 *  @access     QSPI->QSPIIF.bit.RDY
 *  @brief      Serial Interface Transfer Ready Interrupt Flag
 */
#define QSPIIF_ALL_RDY_Pos (1)
#define QSPIIF_ALL_RDY_Msk (0x1UL << QSPIIF_ALL_RDY_Pos)

typedef enum
{
    QSPIIF_BIT_RDY_NOT_OCCUR     = 0,  /*!< Serial interface is currently transferring data after masking   */
    QSPIIF_BIT_RDY_OCCUR         = 1,  /*!< Serial interface is ready for a new transfer after masking      */
} QSPIIF_BIT_RDY;

#define QSPIIF_ALL_RDY_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_RDY_Pos)
#define QSPIIF_ALL_RDY_OCCUR         ((0x1UL) << QSPIIF_ALL_RDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          RFIFODMABURST
 *  @access     QSPI->QSPIIF.bit.RFIFODMABURST
 *  @brief      Read FIFO DMA Burst Interrupt Flag
 */
#define QSPIIF_ALL_RFIFODMABURST_Pos (2)
#define QSPIIF_ALL_RFIFODMABURST_Msk (0x1UL << QSPIIF_ALL_RFIFODMABURST_Pos)

typedef enum
{
    QSPIIF_BIT_RFIFODMABURST_NOT_OCCUR     = 0,  /*!< Number of available data in the Read FIFO is less than DMARBURST (R28h [9:8]) after masking                  */
    QSPIIF_BIT_RFIFODMABURST_OCCUR         = 1,  /*!< Number of available data in the Read FIFO is greater than or equal to DMARBURST (R28h [9:8]) after masking   */
} QSPIIF_BIT_RFIFODMABURST;

#define QSPIIF_ALL_RFIFODMABURST_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_RFIFODMABURST_Pos)
#define QSPIIF_ALL_RFIFODMABURST_OCCUR         ((0x1UL) << QSPIIF_ALL_RFIFODMABURST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          WFIFODMABURST
 *  @access     QSPI->QSPIIF.bit.WFIFODMABURST
 *  @brief      Write FIFO DMA burst Interrupt Flag
 */
#define QSPIIF_ALL_WFIFODMABURST_Pos (3)
#define QSPIIF_ALL_WFIFODMABURST_Msk (0x1UL << QSPIIF_ALL_WFIFODMABURST_Pos)

typedef enum
{
    QSPIIF_BIT_WFIFODMABURST_NOT_OCCUR     = 0,  /*!< Number of unused entries in the Write FIFO is less than DMAWBURST (R28h [13:12]) after masking                  */
    QSPIIF_BIT_WFIFODMABURST_OCCUR         = 1,  /*!< Number of unused entries in the Write FIFO is greater than or equal to DMAWBURST (R28h [13:12]) after masking   */
} QSPIIF_BIT_WFIFODMABURST;

#define QSPIIF_ALL_WFIFODMABURST_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_WFIFODMABURST_Pos)
#define QSPIIF_ALL_WFIFODMABURST_OCCUR         ((0x1UL) << QSPIIF_ALL_WFIFODMABURST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          RFIFOEMPTY
 *  @access     QSPI->QSPIIF.bit.RFIFOEMPTY
 *  @brief      Read FIFO Empty Interrupt Flag
 */
#define QSPIIF_ALL_RFIFOEMPTY_Pos (4)
#define QSPIIF_ALL_RFIFOEMPTY_Msk (0x1UL << QSPIIF_ALL_RFIFOEMPTY_Pos)

typedef enum
{
    QSPIIF_BIT_RFIFOEMPTY_NOT_OCCUR     = 0,  /*!< Read FIFO is not emptied after masking   */
    QSPIIF_BIT_RFIFOEMPTY_OCCUR         = 1,  /*!< Read FIFO is empty after masking         */
} QSPIIF_BIT_RFIFOEMPTY;

#define QSPIIF_ALL_RFIFOEMPTY_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_RFIFOEMPTY_Pos)
#define QSPIIF_ALL_RFIFOEMPTY_OCCUR         ((0x1UL) << QSPIIF_ALL_RFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          RFIFOFULL
 *  @access     QSPI->QSPIIF.bit.RFIFOFULL
 *  @brief      Read FIFO Full Interrupt Flag
 */
#define QSPIIF_ALL_RFIFOFULL_Pos (5)
#define QSPIIF_ALL_RFIFOFULL_Msk (0x1UL << QSPIIF_ALL_RFIFOFULL_Pos)

typedef enum
{
    QSPIIF_BIT_RFIFOFULL_NOT_OCCUR     = 0,  /*!< Read FIFO is not filled after masking   */
    QSPIIF_BIT_RFIFOFULL_OCCUR         = 1,  /*!< Read FIFO is filled after masking       */
} QSPIIF_BIT_RFIFOFULL;

#define QSPIIF_ALL_RFIFOFULL_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_RFIFOFULL_Pos)
#define QSPIIF_ALL_RFIFOFULL_OCCUR         ((0x1UL) << QSPIIF_ALL_RFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          WFIFOEMPTY
 *  @access     QSPI->QSPIIF.bit.WFIFOEMPTY
 *  @brief      Write FIFO Empty Interrupt Flag
 */
#define QSPIIF_ALL_WFIFOEMPTY_Pos (6)
#define QSPIIF_ALL_WFIFOEMPTY_Msk (0x1UL << QSPIIF_ALL_WFIFOEMPTY_Pos)

typedef enum
{
    QSPIIF_BIT_WFIFOEMPTY_NOT_OCCUR     = 0,  /*!< Write FIFO is not emptied after masking   */
    QSPIIF_BIT_WFIFOEMPTY_OCCUR         = 1,  /*!< Write FIFO is emptied after masking       */
} QSPIIF_BIT_WFIFOEMPTY;

#define QSPIIF_ALL_WFIFOEMPTY_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_WFIFOEMPTY_Pos)
#define QSPIIF_ALL_WFIFOEMPTY_OCCUR         ((0x1UL) << QSPIIF_ALL_WFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          WFIFOFULL
 *  @access     QSPI->QSPIIF.bit.WFIFOFULL
 *  @brief      Write FIFO Full Interrupt Flag
 */
#define QSPIIF_ALL_WFIFOFULL_Pos (7)
#define QSPIIF_ALL_WFIFOFULL_Msk (0x1UL << QSPIIF_ALL_WFIFOFULL_Pos)

typedef enum
{
    QSPIIF_BIT_WFIFOFULL_NOT_OCCUR     = 0,  /*!< Write FIFO is not filled after masking   */
    QSPIIF_BIT_WFIFOFULL_OCCUR         = 1,  /*!< Write FIFO is filled after masking       */
} QSPIIF_BIT_WFIFOFULL;

#define QSPIIF_ALL_WFIFOFULL_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_WFIFOFULL_Pos)
#define QSPIIF_ALL_WFIFOFULL_OCCUR         ((0x1UL) << QSPIIF_ALL_WFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          RFIFOUDF
 *  @access     QSPI->QSPIIF.bit.RFIFOUDF
 *  @brief      Read FIFO Underflow Interrupt Flag
 */
#define QSPIIF_ALL_RFIFOUDF_Pos (8)
#define QSPIIF_ALL_RFIFOUDF_Msk (0x1UL << QSPIIF_ALL_RFIFOUDF_Pos)

typedef enum
{
    QSPIIF_BIT_RFIFOUDF_NOT_OCCUR     = 0,  /*!< Read FIFO is not underflowed after masking   */
    QSPIIF_BIT_RFIFOUDF_OCCUR         = 1,  /*!< Read FIFO is underflowed after masking       */
} QSPIIF_BIT_RFIFOUDF;

#define QSPIIF_ALL_RFIFOUDF_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_RFIFOUDF_Pos)
#define QSPIIF_ALL_RFIFOUDF_OCCUR         ((0x1UL) << QSPIIF_ALL_RFIFOUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          RFIFOOVF
 *  @access     QSPI->QSPIIF.bit.RFIFOOVF
 *  @brief      Read FIFO Overflow Interrupt Flag
 */
#define QSPIIF_ALL_RFIFOOVF_Pos (9)
#define QSPIIF_ALL_RFIFOOVF_Msk (0x1UL << QSPIIF_ALL_RFIFOOVF_Pos)

typedef enum
{
    QSPIIF_BIT_RFIFOOVF_NOT_OCCUR     = 0,  /*!< Read FIFO is not overflowed after masking   */
    QSPIIF_BIT_RFIFOOVF_OCCUR         = 1,  /*!< Read FIFO is overflowed after masking       */
} QSPIIF_BIT_RFIFOOVF;

#define QSPIIF_ALL_RFIFOOVF_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_RFIFOOVF_Pos)
#define QSPIIF_ALL_RFIFOOVF_OCCUR         ((0x1UL) << QSPIIF_ALL_RFIFOOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          WFIFOUDF
 *  @access     QSPI->QSPIIF.bit.WFIFOUDF
 *  @brief      Write FIFO Underflow Interrupt Flag
 */
#define QSPIIF_ALL_WFIFOUDF_Pos (10)
#define QSPIIF_ALL_WFIFOUDF_Msk (0x1UL << QSPIIF_ALL_WFIFOUDF_Pos)

typedef enum
{
    QSPIIF_BIT_WFIFOUDF_NOT_OCCUR     = 0,  /*!< Write FIFO is not underflowed after masking   */
    QSPIIF_BIT_WFIFOUDF_OCCUR         = 1,  /*!< Write FIFO is underflowed after masking       */
} QSPIIF_BIT_WFIFOUDF;

#define QSPIIF_ALL_WFIFOUDF_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_WFIFOUDF_Pos)
#define QSPIIF_ALL_WFIFOUDF_OCCUR         ((0x1UL) << QSPIIF_ALL_WFIFOUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIF          WFIFOOVF
 *  @access     QSPI->QSPIIF.bit.WFIFOOVF
 *  @brief      Write FIFO Overflow Interrupt Flag
 */
#define QSPIIF_ALL_WFIFOOVF_Pos (11)
#define QSPIIF_ALL_WFIFOOVF_Msk (0x1UL << QSPIIF_ALL_WFIFOOVF_Pos)

typedef enum
{
    QSPIIF_BIT_WFIFOOVF_NOT_OCCUR     = 0,  /*!< Write FIFO is not overflowed after masking   */
    QSPIIF_BIT_WFIFOOVF_OCCUR         = 1,  /*!< Write FIFO is overflowed after masking       */
} QSPIIF_BIT_WFIFOOVF;

#define QSPIIF_ALL_WFIFOOVF_NOT_OCCUR     ((0x0UL) << QSPIIF_ALL_WFIFOOVF_Pos)
#define QSPIIF_ALL_WFIFOOVF_OCCUR         ((0x1UL) << QSPIIF_ALL_WFIFOOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      DONE
 *  @access     QSPI->QSPIINTMSK.bit.DONE
 *  @brief      Transfer Done Interrupt Mask
 */
#define QSPIINTMSK_ALL_DONE_Pos (0)
#define QSPIINTMSK_ALL_DONE_Msk (0x1UL << QSPIINTMSK_ALL_DONE_Pos)

typedef enum
{
    QSPIINTMSK_BIT_DONE_UNMASK     = 0,  /*!< Transfer done interrupt is not masked   */
    QSPIINTMSK_BIT_DONE_MASK       = 1,  /*!< Transfer done interrupt is masked       */
} QSPIINTMSK_BIT_DONE;

#define QSPIINTMSK_ALL_DONE_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_DONE_Pos)
#define QSPIINTMSK_ALL_DONE_MASK       ((0x1UL) << QSPIINTMSK_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      RDY
 *  @access     QSPI->QSPIINTMSK.bit.RDY
 *  @brief      Serial Interface Transfer Ready Mask
 */
#define QSPIINTMSK_ALL_RDY_Pos (1)
#define QSPIINTMSK_ALL_RDY_Msk (0x1UL << QSPIINTMSK_ALL_RDY_Pos)

typedef enum
{
    QSPIINTMSK_BIT_RDY_UNMASK     = 0,  /*!< Transfer ready interrupt is not masked   */
    QSPIINTMSK_BIT_RDY_MASK       = 1,  /*!< Transfer ready interrupt is masked       */
} QSPIINTMSK_BIT_RDY;

#define QSPIINTMSK_ALL_RDY_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_RDY_Pos)
#define QSPIINTMSK_ALL_RDY_MASK       ((0x1UL) << QSPIINTMSK_ALL_RDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      RFIFODMABURST
 *  @access     QSPI->QSPIINTMSK.bit.RFIFODMABURST
 *  @brief      Read FIFO DMA Burst Interrupt Mask
 */
#define QSPIINTMSK_ALL_RFIFODMABURST_Pos (2)
#define QSPIINTMSK_ALL_RFIFODMABURST_Msk (0x1UL << QSPIINTMSK_ALL_RFIFODMABURST_Pos)

typedef enum
{
    QSPIINTMSK_BIT_RFIFODMABURST_UNMASK     = 0,  /*!< Read FIFO DMA burst interrupt is not masked   */
    QSPIINTMSK_BIT_RFIFODMABURST_MASK       = 1,  /*!< Read FIFO DMA burst interrupt is masked       */
} QSPIINTMSK_BIT_RFIFODMABURST;

#define QSPIINTMSK_ALL_RFIFODMABURST_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_RFIFODMABURST_Pos)
#define QSPIINTMSK_ALL_RFIFODMABURST_MASK       ((0x1UL) << QSPIINTMSK_ALL_RFIFODMABURST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      WFIFODMABURST
 *  @access     QSPI->QSPIINTMSK.bit.WFIFODMABURST
 *  @brief      Write FIFO DMA Burst Interrupt Mask
 */
#define QSPIINTMSK_ALL_WFIFODMABURST_Pos (3)
#define QSPIINTMSK_ALL_WFIFODMABURST_Msk (0x1UL << QSPIINTMSK_ALL_WFIFODMABURST_Pos)

typedef enum
{
    QSPIINTMSK_BIT_WFIFODMABURST_UNMASK     = 0,  /*!< Write FIFO DMA burst interrupt is not masked   */
    QSPIINTMSK_BIT_WFIFODMABURST_MASK       = 1,  /*!< Write FIFO DMA burst interrupt is masked       */
} QSPIINTMSK_BIT_WFIFODMABURST;

#define QSPIINTMSK_ALL_WFIFODMABURST_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_WFIFODMABURST_Pos)
#define QSPIINTMSK_ALL_WFIFODMABURST_MASK       ((0x1UL) << QSPIINTMSK_ALL_WFIFODMABURST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      RFIFOEMPTY
 *  @access     QSPI->QSPIINTMSK.bit.RFIFOEMPTY
 *  @brief      Read FIFO Empty Interrupt Mask
 */
#define QSPIINTMSK_ALL_RFIFOEMPTY_Pos (4)
#define QSPIINTMSK_ALL_RFIFOEMPTY_Msk (0x1UL << QSPIINTMSK_ALL_RFIFOEMPTY_Pos)

typedef enum
{
    QSPIINTMSK_BIT_RFIFOEMPTY_UNMASK     = 0,  /*!< Read FIFO empty interrupt is not masked   */
    QSPIINTMSK_BIT_RFIFOEMPTY_MASK       = 1,  /*!< Read FIFO empty interrupt is masked       */
} QSPIINTMSK_BIT_RFIFOEMPTY;

#define QSPIINTMSK_ALL_RFIFOEMPTY_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_RFIFOEMPTY_Pos)
#define QSPIINTMSK_ALL_RFIFOEMPTY_MASK       ((0x1UL) << QSPIINTMSK_ALL_RFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      RFIFOFULL
 *  @access     QSPI->QSPIINTMSK.bit.RFIFOFULL
 *  @brief      Read FIFO Full Interrupt Mask
 */
#define QSPIINTMSK_ALL_RFIFOFULL_Pos (5)
#define QSPIINTMSK_ALL_RFIFOFULL_Msk (0x1UL << QSPIINTMSK_ALL_RFIFOFULL_Pos)

typedef enum
{
    QSPIINTMSK_BIT_RFIFOFULL_UNMASK     = 0,  /*!< Read FIFO full interrupt is not masked   */
    QSPIINTMSK_BIT_RFIFOFULL_MASK       = 1,  /*!< Read FIFO full interrupt is masked       */
} QSPIINTMSK_BIT_RFIFOFULL;

#define QSPIINTMSK_ALL_RFIFOFULL_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_RFIFOFULL_Pos)
#define QSPIINTMSK_ALL_RFIFOFULL_MASK       ((0x1UL) << QSPIINTMSK_ALL_RFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      WFIFOEMPTY
 *  @access     QSPI->QSPIINTMSK.bit.WFIFOEMPTY
 *  @brief      Write FIFO Empty Interrupt Mask
 */
#define QSPIINTMSK_ALL_WFIFOEMPTY_Pos (6)
#define QSPIINTMSK_ALL_WFIFOEMPTY_Msk (0x1UL << QSPIINTMSK_ALL_WFIFOEMPTY_Pos)

typedef enum
{
    QSPIINTMSK_BIT_WFIFOEMPTY_UNMASK     = 0,  /*!< Write FIFO empty interrupt is not masked   */
    QSPIINTMSK_BIT_WFIFOEMPTY_MASK       = 1,  /*!< Write FIFO empty interrupt is masked       */
} QSPIINTMSK_BIT_WFIFOEMPTY;

#define QSPIINTMSK_ALL_WFIFOEMPTY_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_WFIFOEMPTY_Pos)
#define QSPIINTMSK_ALL_WFIFOEMPTY_MASK       ((0x1UL) << QSPIINTMSK_ALL_WFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      WFIFOFULL
 *  @access     QSPI->QSPIINTMSK.bit.WFIFOFULL
 *  @brief      Write FIFO Full Interrupt Mask
 */
#define QSPIINTMSK_ALL_WFIFOFULL_Pos (7)
#define QSPIINTMSK_ALL_WFIFOFULL_Msk (0x1UL << QSPIINTMSK_ALL_WFIFOFULL_Pos)

typedef enum
{
    QSPIINTMSK_BIT_WFIFOFULL_UNMASK     = 0,  /*!< Write FIFO full interrupt is not masked   */
    QSPIINTMSK_BIT_WFIFOFULL_MASK       = 1,  /*!< Write FIFO full interrupt is masked       */
} QSPIINTMSK_BIT_WFIFOFULL;

#define QSPIINTMSK_ALL_WFIFOFULL_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_WFIFOFULL_Pos)
#define QSPIINTMSK_ALL_WFIFOFULL_MASK       ((0x1UL) << QSPIINTMSK_ALL_WFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      RFIFOUDF
 *  @access     QSPI->QSPIINTMSK.bit.RFIFOUDF
 *  @brief      Read FIFO Underflow Interrupt Mask
 */
#define QSPIINTMSK_ALL_RFIFOUDF_Pos (8)
#define QSPIINTMSK_ALL_RFIFOUDF_Msk (0x1UL << QSPIINTMSK_ALL_RFIFOUDF_Pos)

typedef enum
{
    QSPIINTMSK_BIT_RFIFOUDF_UNMASK     = 0,  /*!< Read FIFO underflow interrupt is not masked   */
    QSPIINTMSK_BIT_RFIFOUDF_MASK       = 1,  /*!< Read FIFO underflow interrupt is masked       */
} QSPIINTMSK_BIT_RFIFOUDF;

#define QSPIINTMSK_ALL_RFIFOUDF_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_RFIFOUDF_Pos)
#define QSPIINTMSK_ALL_RFIFOUDF_MASK       ((0x1UL) << QSPIINTMSK_ALL_RFIFOUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      RFIFOOVF
 *  @access     QSPI->QSPIINTMSK.bit.RFIFOOVF
 *  @brief      Read FIFO Overflow Interrupt Mask
 */
#define QSPIINTMSK_ALL_RFIFOOVF_Pos (9)
#define QSPIINTMSK_ALL_RFIFOOVF_Msk (0x1UL << QSPIINTMSK_ALL_RFIFOOVF_Pos)

typedef enum
{
    QSPIINTMSK_BIT_RFIFOOVF_UNMASK     = 0,  /*!< Read FIFO overflow interrupt is not masked   */
    QSPIINTMSK_BIT_RFIFOOVF_MASK       = 1,  /*!< Read FIFO overflow interrupt is masked       */
} QSPIINTMSK_BIT_RFIFOOVF;

#define QSPIINTMSK_ALL_RFIFOOVF_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_RFIFOOVF_Pos)
#define QSPIINTMSK_ALL_RFIFOOVF_MASK       ((0x1UL) << QSPIINTMSK_ALL_RFIFOOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      WFIFOUDF
 *  @access     QSPI->QSPIINTMSK.bit.WFIFOUDF
 *  @brief      Write FIFO Underflow Interrupt Mask
 */
#define QSPIINTMSK_ALL_WFIFOUDF_Pos (10)
#define QSPIINTMSK_ALL_WFIFOUDF_Msk (0x1UL << QSPIINTMSK_ALL_WFIFOUDF_Pos)

typedef enum
{
    QSPIINTMSK_BIT_WFIFOUDF_UNMASK     = 0,  /*!< Write FIFO underflow interrupt is not masked   */
    QSPIINTMSK_BIT_WFIFOUDF_MASK       = 1,  /*!< Write FIFO underflow interrupt is masked       */
} QSPIINTMSK_BIT_WFIFOUDF;

#define QSPIINTMSK_ALL_WFIFOUDF_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_WFIFOUDF_Pos)
#define QSPIINTMSK_ALL_WFIFOUDF_MASK       ((0x1UL) << QSPIINTMSK_ALL_WFIFOUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      WFIFOOVF
 *  @access     QSPI->QSPIINTMSK.bit.WFIFOOVF
 *  @brief      Write FIFO Overflow Interrupt Mask
 */
#define QSPIINTMSK_ALL_WFIFOOVF_Pos (11)
#define QSPIINTMSK_ALL_WFIFOOVF_Msk (0x1UL << QSPIINTMSK_ALL_WFIFOOVF_Pos)

typedef enum
{
    QSPIINTMSK_BIT_WFIFOOVF_UNMASK     = 0,  /*!< Write FIFO overflow interrupt is not masked   */
    QSPIINTMSK_BIT_WFIFOOVF_MASK       = 1,  /*!< Write FIFO overflow interrupt is masked       */
} QSPIINTMSK_BIT_WFIFOOVF;

#define QSPIINTMSK_ALL_WFIFOOVF_UNMASK     ((0x0UL) << QSPIINTMSK_ALL_WFIFOOVF_Pos)
#define QSPIINTMSK_ALL_WFIFOOVF_MASK       ((0x1UL) << QSPIINTMSK_ALL_WFIFOOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIINTMSK      RESERVED1
 *  @access     QSPI->QSPIINTMSK.bit.RESERVED1
 *  @brief      Reserved
 */
#define QSPIINTMSK_ALL_RESERVED1_Pos (12)
#define QSPIINTMSK_ALL_RESERVED1_Msk (0xFFFFFUL << QSPIINTMSK_ALL_RESERVED1_Pos)

#define QSPIINTMSK_BIT_RESERVED1

#define QSPIINTMSK_ALL_RESERVED1_(x) ((x) << QSPIINTMSK_ALL_RESERVED1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       DONE
 *  @access     QSPI->QSPIRAWIF.bit.DONE
 *  @brief      Transfer Done Interrupt Raw
 */
#define QSPIRAWIF_ALL_DONE_Pos (0)
#define QSPIRAWIF_ALL_DONE_Msk (0x1UL << QSPIRAWIF_ALL_DONE_Pos)

typedef enum
{
    QSPIRAWIF_BIT_DONE_NOT_OCCUR     = 0,  /*!< Transfer has not completed before masking   */
    QSPIRAWIF_BIT_DONE_OCCUR         = 1,  /*!< Transfer has completed before masking       */
} QSPIRAWIF_BIT_DONE;

#define QSPIRAWIF_ALL_DONE_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_DONE_Pos)
#define QSPIRAWIF_ALL_DONE_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       RDY
 *  @access     QSPI->QSPIRAWIF.bit.RDY
 *  @brief      Serial Interface Transfer Ready Raw
 */
#define QSPIRAWIF_ALL_RDY_Pos (1)
#define QSPIRAWIF_ALL_RDY_Msk (0x1UL << QSPIRAWIF_ALL_RDY_Pos)

typedef enum
{
    QSPIRAWIF_BIT_RDY_NOT_OCCUR     = 0,  /*!< Serial interface is currently transferring data before masking   */
    QSPIRAWIF_BIT_RDY_OCCUR         = 1,  /*!< Serial interface is ready for a new transfer before masking      */
} QSPIRAWIF_BIT_RDY;

#define QSPIRAWIF_ALL_RDY_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_RDY_Pos)
#define QSPIRAWIF_ALL_RDY_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_RDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       RFIFODMABURST
 *  @access     QSPI->QSPIRAWIF.bit.RFIFODMABURST
 *  @brief      Read FIFO DMA Burst Interrupt Raw
 */
#define QSPIRAWIF_ALL_RFIFODMABURST_Pos (2)
#define QSPIRAWIF_ALL_RFIFODMABURST_Msk (0x1UL << QSPIRAWIF_ALL_RFIFODMABURST_Pos)

typedef enum
{
    QSPIRAWIF_BIT_RFIFODMABURST_NOT_OCCUR     = 0,  /*!< Number of available data in the Read FIFO is less than DMARBURST (R28h [9:8]) before masking                  */
    QSPIRAWIF_BIT_RFIFODMABURST_OCCUR         = 1,  /*!< Number of available data in the Read FIFO is greater than or equal to DMARBURST (R28h [9:8]) before masking   */
} QSPIRAWIF_BIT_RFIFODMABURST;

#define QSPIRAWIF_ALL_RFIFODMABURST_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_RFIFODMABURST_Pos)
#define QSPIRAWIF_ALL_RFIFODMABURST_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_RFIFODMABURST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       WFIFODMABURST
 *  @access     QSPI->QSPIRAWIF.bit.WFIFODMABURST
 *  @brief      Write FIFO DMA Burst Interrupt Raw
 */
#define QSPIRAWIF_ALL_WFIFODMABURST_Pos (3)
#define QSPIRAWIF_ALL_WFIFODMABURST_Msk (0x1UL << QSPIRAWIF_ALL_WFIFODMABURST_Pos)

typedef enum
{
    QSPIRAWIF_BIT_WFIFODMABURST_NOT_OCCUR     = 0,  /*!< Number of unused entries in the Write FIFO is less than DMAWBURST (R28h [13:12]) before masking                  */
    QSPIRAWIF_BIT_WFIFODMABURST_OCCUR         = 1,  /*!< Number of unused entries in the Write FIFO is greater than or equal to DMAWBURST (R28h [13:12]) before masking   */
} QSPIRAWIF_BIT_WFIFODMABURST;

#define QSPIRAWIF_ALL_WFIFODMABURST_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_WFIFODMABURST_Pos)
#define QSPIRAWIF_ALL_WFIFODMABURST_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_WFIFODMABURST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       RFIFOEMPTY
 *  @access     QSPI->QSPIRAWIF.bit.RFIFOEMPTY
 *  @brief      Read FIFO Empty Interrupt Raw
 */
#define QSPIRAWIF_ALL_RFIFOEMPTY_Pos (4)
#define QSPIRAWIF_ALL_RFIFOEMPTY_Msk (0x1UL << QSPIRAWIF_ALL_RFIFOEMPTY_Pos)

typedef enum
{
    QSPIRAWIF_BIT_RFIFOEMPTY_NOT_OCCUR     = 0,  /*!< Read FIFO is not emptied before masking   */
    QSPIRAWIF_BIT_RFIFOEMPTY_OCCUR         = 1,  /*!< Read FIFO is empty before masking         */
} QSPIRAWIF_BIT_RFIFOEMPTY;

#define QSPIRAWIF_ALL_RFIFOEMPTY_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_RFIFOEMPTY_Pos)
#define QSPIRAWIF_ALL_RFIFOEMPTY_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_RFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       RFIFOFULL
 *  @access     QSPI->QSPIRAWIF.bit.RFIFOFULL
 *  @brief      Read FIFO Full Interrupt Raw
 */
#define QSPIRAWIF_ALL_RFIFOFULL_Pos (5)
#define QSPIRAWIF_ALL_RFIFOFULL_Msk (0x1UL << QSPIRAWIF_ALL_RFIFOFULL_Pos)

typedef enum
{
    QSPIRAWIF_BIT_RFIFOFULL_NOT_OCCUR     = 0,  /*!< Read FIFO is not filled before masking   */
    QSPIRAWIF_BIT_RFIFOFULL_OCCUR         = 1,  /*!< Read FIFO is filled before masking       */
} QSPIRAWIF_BIT_RFIFOFULL;

#define QSPIRAWIF_ALL_RFIFOFULL_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_RFIFOFULL_Pos)
#define QSPIRAWIF_ALL_RFIFOFULL_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_RFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       WFIFOEMPTY
 *  @access     QSPI->QSPIRAWIF.bit.WFIFOEMPTY
 *  @brief      Write FIFO Empty Interrupt Raw
 */
#define QSPIRAWIF_ALL_WFIFOEMPTY_Pos (6)
#define QSPIRAWIF_ALL_WFIFOEMPTY_Msk (0x1UL << QSPIRAWIF_ALL_WFIFOEMPTY_Pos)

typedef enum
{
    QSPIRAWIF_BIT_WFIFOEMPTY_NOT_OCCUR     = 0,  /*!< Write FIFO is not emptied before masking   */
    QSPIRAWIF_BIT_WFIFOEMPTY_OCCUR         = 1,  /*!< Write FIFO is emptied before masking       */
} QSPIRAWIF_BIT_WFIFOEMPTY;

#define QSPIRAWIF_ALL_WFIFOEMPTY_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_WFIFOEMPTY_Pos)
#define QSPIRAWIF_ALL_WFIFOEMPTY_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_WFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       WFIFOFULL
 *  @access     QSPI->QSPIRAWIF.bit.WFIFOFULL
 *  @brief      Write FIFO Full Interrupt Raw
 */
#define QSPIRAWIF_ALL_WFIFOFULL_Pos (7)
#define QSPIRAWIF_ALL_WFIFOFULL_Msk (0x1UL << QSPIRAWIF_ALL_WFIFOFULL_Pos)

typedef enum
{
    QSPIRAWIF_BIT_WFIFOFULL_NOT_OCCUR     = 0,  /*!< Write FIFO is not filled before masking   */
    QSPIRAWIF_BIT_WFIFOFULL_OCCUR         = 1,  /*!< Write FIFO is filled before masking       */
} QSPIRAWIF_BIT_WFIFOFULL;

#define QSPIRAWIF_ALL_WFIFOFULL_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_WFIFOFULL_Pos)
#define QSPIRAWIF_ALL_WFIFOFULL_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_WFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       RFIFOUDF
 *  @access     QSPI->QSPIRAWIF.bit.RFIFOUDF
 *  @brief      Read FIFO Underflow Interrupt Raw
 */
#define QSPIRAWIF_ALL_RFIFOUDF_Pos (8)
#define QSPIRAWIF_ALL_RFIFOUDF_Msk (0x1UL << QSPIRAWIF_ALL_RFIFOUDF_Pos)

typedef enum
{
    QSPIRAWIF_BIT_RFIFOUDF_NOT_OCCUR     = 0,  /*!< Read FIFO is not underflowed before masking   */
    QSPIRAWIF_BIT_RFIFOUDF_OCCUR         = 1,  /*!< Read FIFO is underflowed before masking       */
} QSPIRAWIF_BIT_RFIFOUDF;

#define QSPIRAWIF_ALL_RFIFOUDF_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_RFIFOUDF_Pos)
#define QSPIRAWIF_ALL_RFIFOUDF_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_RFIFOUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       RFIFOOVF
 *  @access     QSPI->QSPIRAWIF.bit.RFIFOOVF
 *  @brief      Read FIFO Overflow Interrupt Raw
 */
#define QSPIRAWIF_ALL_RFIFOOVF_Pos (9)
#define QSPIRAWIF_ALL_RFIFOOVF_Msk (0x1UL << QSPIRAWIF_ALL_RFIFOOVF_Pos)

typedef enum
{
    QSPIRAWIF_BIT_RFIFOOVF_NOT_OCCUR     = 0,  /*!< Read FIFO is not overflowed before masking   */
    QSPIRAWIF_BIT_RFIFOOVF_OCCUR         = 1,  /*!< Read FIFO is overflowed before masking       */
} QSPIRAWIF_BIT_RFIFOOVF;

#define QSPIRAWIF_ALL_RFIFOOVF_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_RFIFOOVF_Pos)
#define QSPIRAWIF_ALL_RFIFOOVF_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_RFIFOOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       WFIFOUDF
 *  @access     QSPI->QSPIRAWIF.bit.WFIFOUDF
 *  @brief      Write FIFO Underflow Interrupt Raw
 */
#define QSPIRAWIF_ALL_WFIFOUDF_Pos (10)
#define QSPIRAWIF_ALL_WFIFOUDF_Msk (0x1UL << QSPIRAWIF_ALL_WFIFOUDF_Pos)

typedef enum
{
    QSPIRAWIF_BIT_WFIFOUDF_NOT_OCCUR     = 0,  /*!< Write FIFO is not underflowed before masking   */
    QSPIRAWIF_BIT_WFIFOUDF_OCCUR         = 1,  /*!< Write FIFO is underflowed before masking       */
} QSPIRAWIF_BIT_WFIFOUDF;

#define QSPIRAWIF_ALL_WFIFOUDF_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_WFIFOUDF_Pos)
#define QSPIRAWIF_ALL_WFIFOUDF_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_WFIFOUDF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIRAWIF       WFIFOOVF
 *  @access     QSPI->QSPIRAWIF.bit.WFIFOOVF
 *  @brief      Write FIFO Overflow Interrupt Raw
 */
#define QSPIRAWIF_ALL_WFIFOOVF_Pos (11)
#define QSPIRAWIF_ALL_WFIFOOVF_Msk (0x1UL << QSPIRAWIF_ALL_WFIFOOVF_Pos)

typedef enum
{
    QSPIRAWIF_BIT_WFIFOOVF_NOT_OCCUR     = 0,  /*!< Write FIFO is not overflowed before masking   */
    QSPIRAWIF_BIT_WFIFOOVF_OCCUR         = 1,  /*!< Write FIFO is overflowed before masking       */
} QSPIRAWIF_BIT_WFIFOOVF;

#define QSPIRAWIF_ALL_WFIFOOVF_NOT_OCCUR     ((0x0UL) << QSPIRAWIF_ALL_WFIFOOVF_Pos)
#define QSPIRAWIF_ALL_WFIFOOVF_OCCUR         ((0x1UL) << QSPIRAWIF_ALL_WFIFOOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   QSPI            QSPIIC          DONE
 *  @access     QSPI->QSPIIC.bit.DONE
 *  @brief      Transfer Done Interrupt Clear
 */
#define QSPIIC_ALL_DONE_Pos (0)
#define QSPIIC_ALL_DONE_Msk (0x1UL << QSPIIC_ALL_DONE_Pos)

typedef enum
{
    QSPIIC_BIT_DONE_NO_EFFECT      = 0,  /*!< Transfer done interrupt is not cleared   */
    QSPIIC_BIT_DONE_CLEAR_FLAG     = 1,  /*!< Transfer done interrupt is cleared       */
} QSPIIC_BIT_DONE;

#define QSPIIC_ALL_DONE_NO_EFFECT      ((0x0UL) << QSPIIC_ALL_DONE_Pos)
#define QSPIIC_ALL_DONE_CLEAR_FLAG     ((0x1UL) << QSPIIC_ALL_DONE_Pos)





/********************************************************************************
*
* Module Name     PGA
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL0       CHSEL0P
 *  @access     PGA->PGACHCTL0.bit.CHSEL0P
 *  @brief      Input channel selection for positive input of PGA 0
 */
#define PGACHCTL0_ALL_CHSEL0P_Pos (0)
#define PGACHCTL0_ALL_CHSEL0P_Msk (0x7UL << PGACHCTL0_ALL_CHSEL0P_Pos)

typedef enum
{
    PGACHCTL0_BIT_CHSEL0P_VSSA           = 0,  /*!< VSSA (GND)    */
    PGACHCTL0_BIT_CHSEL0P_VDDR12_ANA     = 1,  /*!< VDDR12_ANA    */
    PGACHCTL0_BIT_CHSEL0P_ADC5           = 2,  /*!< GPIO6         */
    PGACHCTL0_BIT_CHSEL0P_ADC9           = 3,  /*!< GPIO10        */
    PGACHCTL0_BIT_CHSEL0P_ADC2           = 4,  /*!< GPIO3         */
    PGACHCTL0_BIT_CHSEL0P_ADC7           = 5,  /*!< GPIO8         */
    PGACHCTL0_BIT_CHSEL0P_ADC14          = 6,  /*!< GPIO15        */
    PGACHCTL0_BIT_CHSEL0P_RESDIV0        = 7,  /*!< RESDIV 0      */
} PGACHCTL0_BIT_CHSEL0P;

#define PGACHCTL0_ALL_CHSEL0P_VSSA           ((0x0UL) << PGACHCTL0_ALL_CHSEL0P_Pos)
#define PGACHCTL0_ALL_CHSEL0P_VDDR12_ANA     ((0x1UL) << PGACHCTL0_ALL_CHSEL0P_Pos)
#define PGACHCTL0_ALL_CHSEL0P_ADC5           ((0x2UL) << PGACHCTL0_ALL_CHSEL0P_Pos)
#define PGACHCTL0_ALL_CHSEL0P_ADC9           ((0x3UL) << PGACHCTL0_ALL_CHSEL0P_Pos)
#define PGACHCTL0_ALL_CHSEL0P_ADC2           ((0x4UL) << PGACHCTL0_ALL_CHSEL0P_Pos)
#define PGACHCTL0_ALL_CHSEL0P_ADC7           ((0x5UL) << PGACHCTL0_ALL_CHSEL0P_Pos)
#define PGACHCTL0_ALL_CHSEL0P_ADC14          ((0x6UL) << PGACHCTL0_ALL_CHSEL0P_Pos)
#define PGACHCTL0_ALL_CHSEL0P_RESDIV0        ((0x7UL) << PGACHCTL0_ALL_CHSEL0P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL0       CHSEL1P
 *  @access     PGA->PGACHCTL0.bit.CHSEL1P
 *  @brief      Input channel selection for positive input of PGA 1
 */
#define PGACHCTL0_ALL_CHSEL1P_Pos (3)
#define PGACHCTL0_ALL_CHSEL1P_Msk (0x7UL << PGACHCTL0_ALL_CHSEL1P_Pos)

typedef enum
{
    PGACHCTL0_BIT_CHSEL1P_VSSA        = 0,  /*!< VSSA (GND)   */
    PGACHCTL0_BIT_CHSEL1P_VDAC_HI     = 1,  /*!< VDAC_HI      */
    PGACHCTL0_BIT_CHSEL1P_ADC1        = 2,  /*!< GPIO2        */
    PGACHCTL0_BIT_CHSEL1P_ADC11       = 3,  /*!< GPIO12       */
    PGACHCTL0_BIT_CHSEL1P_ADC4        = 4,  /*!< GPIO5        */
    PGACHCTL0_BIT_CHSEL1P_ADC7        = 5,  /*!< GPIO8        */
    PGACHCTL0_BIT_CHSEL1P_ADC14       = 6,  /*!< GPIO15       */
    PGACHCTL0_BIT_CHSEL1P_RESDIV1     = 7,  /*!< RESDIV 1     */
} PGACHCTL0_BIT_CHSEL1P;

#define PGACHCTL0_ALL_CHSEL1P_VSSA        ((0x0UL) << PGACHCTL0_ALL_CHSEL1P_Pos)
#define PGACHCTL0_ALL_CHSEL1P_VDAC_HI     ((0x1UL) << PGACHCTL0_ALL_CHSEL1P_Pos)
#define PGACHCTL0_ALL_CHSEL1P_ADC1        ((0x2UL) << PGACHCTL0_ALL_CHSEL1P_Pos)
#define PGACHCTL0_ALL_CHSEL1P_ADC11       ((0x3UL) << PGACHCTL0_ALL_CHSEL1P_Pos)
#define PGACHCTL0_ALL_CHSEL1P_ADC4        ((0x4UL) << PGACHCTL0_ALL_CHSEL1P_Pos)
#define PGACHCTL0_ALL_CHSEL1P_ADC7        ((0x5UL) << PGACHCTL0_ALL_CHSEL1P_Pos)
#define PGACHCTL0_ALL_CHSEL1P_ADC14       ((0x6UL) << PGACHCTL0_ALL_CHSEL1P_Pos)
#define PGACHCTL0_ALL_CHSEL1P_RESDIV1     ((0x7UL) << PGACHCTL0_ALL_CHSEL1P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL0       CHSEL2P
 *  @access     PGA->PGACHCTL0.bit.CHSEL2P
 *  @brief      Input channel selection for positive input of PGA 2
 */
#define PGACHCTL0_ALL_CHSEL2P_Pos (6)
#define PGACHCTL0_ALL_CHSEL2P_Msk (0x7UL << PGACHCTL0_ALL_CHSEL2P_Pos)

typedef enum
{
    PGACHCTL0_BIT_CHSEL2P_VSSA         = 0,  /*!< VSSA (GND)        */
    PGACHCTL0_BIT_CHSEL2P_TSENSOR1     = 1,  /*!< T-sensor out 1    */
    PGACHCTL0_BIT_CHSEL2P_ADC3         = 2,  /*!< GPIO4             */
    PGACHCTL0_BIT_CHSEL2P_ADC13        = 3,  /*!< GPIO14            */
    PGACHCTL0_BIT_CHSEL2P_ADC6         = 4,  /*!< GPIO7             */
    PGACHCTL0_BIT_CHSEL2P_ADC7         = 5,  /*!< GPIO8             */
    PGACHCTL0_BIT_CHSEL2P_ADC14        = 6,  /*!< GPIO15            */
    PGACHCTL0_BIT_CHSEL2P_RESDIV2      = 7,  /*!< RESDIV 2          */
} PGACHCTL0_BIT_CHSEL2P;

#define PGACHCTL0_ALL_CHSEL2P_VSSA         ((0x0UL) << PGACHCTL0_ALL_CHSEL2P_Pos)
#define PGACHCTL0_ALL_CHSEL2P_TSENSOR1     ((0x1UL) << PGACHCTL0_ALL_CHSEL2P_Pos)
#define PGACHCTL0_ALL_CHSEL2P_ADC3         ((0x2UL) << PGACHCTL0_ALL_CHSEL2P_Pos)
#define PGACHCTL0_ALL_CHSEL2P_ADC13        ((0x3UL) << PGACHCTL0_ALL_CHSEL2P_Pos)
#define PGACHCTL0_ALL_CHSEL2P_ADC6         ((0x4UL) << PGACHCTL0_ALL_CHSEL2P_Pos)
#define PGACHCTL0_ALL_CHSEL2P_ADC7         ((0x5UL) << PGACHCTL0_ALL_CHSEL2P_Pos)
#define PGACHCTL0_ALL_CHSEL2P_ADC14        ((0x6UL) << PGACHCTL0_ALL_CHSEL2P_Pos)
#define PGACHCTL0_ALL_CHSEL2P_RESDIV2      ((0x7UL) << PGACHCTL0_ALL_CHSEL2P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL0       GAIN0P
 *  @access     PGA->PGACHCTL0.bit.GAIN0P
 *  @brief      Select Gain for positive input of PGA 0
 */
#define PGACHCTL0_ALL_GAIN0P_Pos (9)
#define PGACHCTL0_ALL_GAIN0P_Msk (0x3UL << PGACHCTL0_ALL_GAIN0P_Pos)

typedef enum
{
    PGACHCTL0_BIT_GAIN0P_SINGLE_2X_DIFF_4X       = 0,  /*!< 2x single-ended mode / 4x coupled mode      */
    PGACHCTL0_BIT_GAIN0P_SINGLE_4X_DIFF_8X       = 1,  /*!< 4x single-ended mode / 8x coupled mode      */
    PGACHCTL0_BIT_GAIN0P_SINGLE_8X_DIFF_16X      = 2,  /*!< 8x single-ended mode / 16x coupled mode     */
    PGACHCTL0_BIT_GAIN0P_SINGLE_16X_DIFF_32X     = 3,  /*!< 16x single-ended mode / 32x coupled mode    */
} PGACHCTL0_BIT_GAIN0P;

#define PGACHCTL0_ALL_GAIN0P_SINGLE_2X_DIFF_4X       ((0x0UL) << PGACHCTL0_ALL_GAIN0P_Pos)
#define PGACHCTL0_ALL_GAIN0P_SINGLE_4X_DIFF_8X       ((0x1UL) << PGACHCTL0_ALL_GAIN0P_Pos)
#define PGACHCTL0_ALL_GAIN0P_SINGLE_8X_DIFF_16X      ((0x2UL) << PGACHCTL0_ALL_GAIN0P_Pos)
#define PGACHCTL0_ALL_GAIN0P_SINGLE_16X_DIFF_32X     ((0x3UL) << PGACHCTL0_ALL_GAIN0P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL0       GAIN1P
 *  @access     PGA->PGACHCTL0.bit.GAIN1P
 *  @brief      Select Gain for positive input of PGA 1
 */
#define PGACHCTL0_ALL_GAIN1P_Pos (11)
#define PGACHCTL0_ALL_GAIN1P_Msk (0x3UL << PGACHCTL0_ALL_GAIN1P_Pos)

typedef enum
{
    PGACHCTL0_BIT_GAIN1P_SINGLE_2X_DIFF_4X       = 0,  /*!< 2x single-ended mode / 4x coupled mode      */
    PGACHCTL0_BIT_GAIN1P_SINGLE_4X_DIFF_8X       = 1,  /*!< 4x single-ended mode / 8x coupled mode      */
    PGACHCTL0_BIT_GAIN1P_SINGLE_8X_DIFF_16X      = 2,  /*!< 8x single-ended mode / 16x coupled mode     */
    PGACHCTL0_BIT_GAIN1P_SINGLE_16X_DIFF_32X     = 3,  /*!< 16x single-ended mode / 32x coupled mode    */
} PGACHCTL0_BIT_GAIN1P;

#define PGACHCTL0_ALL_GAIN1P_SINGLE_2X_DIFF_4X       ((0x0UL) << PGACHCTL0_ALL_GAIN1P_Pos)
#define PGACHCTL0_ALL_GAIN1P_SINGLE_4X_DIFF_8X       ((0x1UL) << PGACHCTL0_ALL_GAIN1P_Pos)
#define PGACHCTL0_ALL_GAIN1P_SINGLE_8X_DIFF_16X      ((0x2UL) << PGACHCTL0_ALL_GAIN1P_Pos)
#define PGACHCTL0_ALL_GAIN1P_SINGLE_16X_DIFF_32X     ((0x3UL) << PGACHCTL0_ALL_GAIN1P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL0       GAIN2P
 *  @access     PGA->PGACHCTL0.bit.GAIN2P
 *  @brief      Select Gain for positive input of PGA 2
 */
#define PGACHCTL0_ALL_GAIN2P_Pos (13)
#define PGACHCTL0_ALL_GAIN2P_Msk (0x3UL << PGACHCTL0_ALL_GAIN2P_Pos)

typedef enum
{
    PGACHCTL0_BIT_GAIN2P_SINGLE_2X_DIFF_4X       = 0,  /*!< 2x single-ended mode / 4x coupled mode      */
    PGACHCTL0_BIT_GAIN2P_SINGLE_4X_DIFF_8X       = 1,  /*!< 4x single-ended mode / 8x coupled mode      */
    PGACHCTL0_BIT_GAIN2P_SINGLE_8X_DIFF_16X      = 2,  /*!< 8x single-ended mode / 16x coupled mode     */
    PGACHCTL0_BIT_GAIN2P_SINGLE_16X_DIFF_32X     = 3,  /*!< 16x single-ended mode / 32x coupled mode    */
} PGACHCTL0_BIT_GAIN2P;

#define PGACHCTL0_ALL_GAIN2P_SINGLE_2X_DIFF_4X       ((0x0UL) << PGACHCTL0_ALL_GAIN2P_Pos)
#define PGACHCTL0_ALL_GAIN2P_SINGLE_4X_DIFF_8X       ((0x1UL) << PGACHCTL0_ALL_GAIN2P_Pos)
#define PGACHCTL0_ALL_GAIN2P_SINGLE_8X_DIFF_16X      ((0x2UL) << PGACHCTL0_ALL_GAIN2P_Pos)
#define PGACHCTL0_ALL_GAIN2P_SINGLE_16X_DIFF_32X     ((0x3UL) << PGACHCTL0_ALL_GAIN2P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       CHSEL0N
 *  @access     PGA->PGACHCTL1.bit.CHSEL0N
 *  @brief      Input channel selection for negative input of PGA 0
 */
#define PGACHCTL1_ALL_CHSEL0N_Pos (0)
#define PGACHCTL1_ALL_CHSEL0N_Msk (0x7UL << PGACHCTL1_ALL_CHSEL0N_Pos)

typedef enum
{
    PGACHCTL1_BIT_CHSEL0N_VSSA        = 0,  /*!< VSSA        */
    PGACHCTL1_BIT_CHSEL0N_TEST        = 1,  /*!< GPIO25      */
    PGACHCTL1_BIT_CHSEL0N_ADC9        = 2,  /*!< GPIO10      */
    PGACHCTL1_BIT_CHSEL0N_ADC8        = 3,  /*!< GPIO9       */
    PGACHCTL1_BIT_CHSEL0N_ADC1        = 4,  /*!< GPIO2       */
    PGACHCTL1_BIT_CHSEL0N_ADC0        = 5,  /*!< GPIO1       */
    PGACHCTL1_BIT_CHSEL0N_ADC15       = 6,  /*!< GPIO16      */
    PGACHCTL1_BIT_CHSEL0N_RESDIV0     = 7,  /*!< RESDIV 0    */
} PGACHCTL1_BIT_CHSEL0N;

#define PGACHCTL1_ALL_CHSEL0N_VSSA        ((0x0UL) << PGACHCTL1_ALL_CHSEL0N_Pos)
#define PGACHCTL1_ALL_CHSEL0N_TEST        ((0x1UL) << PGACHCTL1_ALL_CHSEL0N_Pos)
#define PGACHCTL1_ALL_CHSEL0N_ADC9        ((0x2UL) << PGACHCTL1_ALL_CHSEL0N_Pos)
#define PGACHCTL1_ALL_CHSEL0N_ADC8        ((0x3UL) << PGACHCTL1_ALL_CHSEL0N_Pos)
#define PGACHCTL1_ALL_CHSEL0N_ADC1        ((0x4UL) << PGACHCTL1_ALL_CHSEL0N_Pos)
#define PGACHCTL1_ALL_CHSEL0N_ADC0        ((0x5UL) << PGACHCTL1_ALL_CHSEL0N_Pos)
#define PGACHCTL1_ALL_CHSEL0N_ADC15       ((0x6UL) << PGACHCTL1_ALL_CHSEL0N_Pos)
#define PGACHCTL1_ALL_CHSEL0N_RESDIV0     ((0x7UL) << PGACHCTL1_ALL_CHSEL0N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       CHSEL1N
 *  @access     PGA->PGACHCTL1.bit.CHSEL1N
 *  @brief      Input channel selection for negative input of PGA 1
 */
#define PGACHCTL1_ALL_CHSEL1N_Pos (3)
#define PGACHCTL1_ALL_CHSEL1N_Msk (0x7UL << PGACHCTL1_ALL_CHSEL1N_Pos)

typedef enum
{
    PGACHCTL1_BIT_CHSEL1N_VSSA          = 0,  /*!< VSSA                  */
    PGACHCTL1_BIT_CHSEL1N_ADC_1dot2     = 1,  /*!< ADC 1.2V Reference    */
    PGACHCTL1_BIT_CHSEL1N_ADC8          = 2,  /*!< GPIO9                 */
    PGACHCTL1_BIT_CHSEL1N_ADC10         = 3,  /*!< GPIO11                */
    PGACHCTL1_BIT_CHSEL1N_ADC3          = 4,  /*!< GPIO4                 */
    PGACHCTL1_BIT_CHSEL1N_ADC0          = 5,  /*!< GPIO1                 */
    PGACHCTL1_BIT_CHSEL1N_ADC15         = 6,  /*!< GPIO16                */
    PGACHCTL1_BIT_CHSEL1N_RESDIV1       = 7,  /*!< RESDIV 1              */
} PGACHCTL1_BIT_CHSEL1N;

#define PGACHCTL1_ALL_CHSEL1N_VSSA          ((0x0UL) << PGACHCTL1_ALL_CHSEL1N_Pos)
#define PGACHCTL1_ALL_CHSEL1N_ADC_1dot2     ((0x1UL) << PGACHCTL1_ALL_CHSEL1N_Pos)
#define PGACHCTL1_ALL_CHSEL1N_ADC8          ((0x2UL) << PGACHCTL1_ALL_CHSEL1N_Pos)
#define PGACHCTL1_ALL_CHSEL1N_ADC10         ((0x3UL) << PGACHCTL1_ALL_CHSEL1N_Pos)
#define PGACHCTL1_ALL_CHSEL1N_ADC3          ((0x4UL) << PGACHCTL1_ALL_CHSEL1N_Pos)
#define PGACHCTL1_ALL_CHSEL1N_ADC0          ((0x5UL) << PGACHCTL1_ALL_CHSEL1N_Pos)
#define PGACHCTL1_ALL_CHSEL1N_ADC15         ((0x6UL) << PGACHCTL1_ALL_CHSEL1N_Pos)
#define PGACHCTL1_ALL_CHSEL1N_RESDIV1       ((0x7UL) << PGACHCTL1_ALL_CHSEL1N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       CHSEL2N
 *  @access     PGA->PGACHCTL1.bit.CHSEL2N
 *  @brief      Input channel selection for negative input of PGA 2
 */
#define PGACHCTL1_ALL_CHSEL2N_Pos (6)
#define PGACHCTL1_ALL_CHSEL2N_Msk (0x7UL << PGACHCTL1_ALL_CHSEL2N_Pos)

typedef enum
{
    PGACHCTL1_BIT_CHSEL2N_VSSA         = 0,  /*!< VSSA (GND)        */
    PGACHCTL1_BIT_CHSEL2N_TSENSOR0     = 1,  /*!< T-sensor out 0    */
    PGACHCTL1_BIT_CHSEL2N_ADC10        = 2,  /*!< GPIO11            */
    PGACHCTL1_BIT_CHSEL2N_ADC12        = 3,  /*!< GPIO13            */
    PGACHCTL1_BIT_CHSEL2N_ADC5         = 4,  /*!< GPIO6             */
    PGACHCTL1_BIT_CHSEL2N_ADC0         = 5,  /*!< GPIO1             */
    PGACHCTL1_BIT_CHSEL2N_ADC15        = 6,  /*!< GPIO16            */
    PGACHCTL1_BIT_CHSEL2N_RESDIV2      = 7,  /*!< RESDIV 2          */
} PGACHCTL1_BIT_CHSEL2N;

#define PGACHCTL1_ALL_CHSEL2N_VSSA         ((0x0UL) << PGACHCTL1_ALL_CHSEL2N_Pos)
#define PGACHCTL1_ALL_CHSEL2N_TSENSOR0     ((0x1UL) << PGACHCTL1_ALL_CHSEL2N_Pos)
#define PGACHCTL1_ALL_CHSEL2N_ADC10        ((0x2UL) << PGACHCTL1_ALL_CHSEL2N_Pos)
#define PGACHCTL1_ALL_CHSEL2N_ADC12        ((0x3UL) << PGACHCTL1_ALL_CHSEL2N_Pos)
#define PGACHCTL1_ALL_CHSEL2N_ADC5         ((0x4UL) << PGACHCTL1_ALL_CHSEL2N_Pos)
#define PGACHCTL1_ALL_CHSEL2N_ADC0         ((0x5UL) << PGACHCTL1_ALL_CHSEL2N_Pos)
#define PGACHCTL1_ALL_CHSEL2N_ADC15        ((0x6UL) << PGACHCTL1_ALL_CHSEL2N_Pos)
#define PGACHCTL1_ALL_CHSEL2N_RESDIV2      ((0x7UL) << PGACHCTL1_ALL_CHSEL2N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       GAIN0N
 *  @access     PGA->PGACHCTL1.bit.GAIN0N
 *  @brief      Select Gain for negative input of PGA 0
 */
#define PGACHCTL1_ALL_GAIN0N_Pos (9)
#define PGACHCTL1_ALL_GAIN0N_Msk (0x3UL << PGACHCTL1_ALL_GAIN0N_Pos)

typedef enum
{
    PGACHCTL1_BIT_GAIN0N_SINGLE_2X_DIFF_4X       = 0,  /*!< 2x single-ended mode / 4x coupled mode      */
    PGACHCTL1_BIT_GAIN0N_SINGLE_4X_DIFF_8X       = 1,  /*!< 4x single-ended mode / 8x coupled mode      */
    PGACHCTL1_BIT_GAIN0N_SINGLE_8X_DIFF_16X      = 2,  /*!< 8x single-ended mode / 16x coupled mode     */
    PGACHCTL1_BIT_GAIN0N_SINGLE_16X_DIFF_32X     = 3,  /*!< 16x single-ended mode / 32x coupled mode    */
} PGACHCTL1_BIT_GAIN0N;

#define PGACHCTL1_ALL_GAIN0N_SINGLE_2X_DIFF_4X       ((0x0UL) << PGACHCTL1_ALL_GAIN0N_Pos)
#define PGACHCTL1_ALL_GAIN0N_SINGLE_4X_DIFF_8X       ((0x1UL) << PGACHCTL1_ALL_GAIN0N_Pos)
#define PGACHCTL1_ALL_GAIN0N_SINGLE_8X_DIFF_16X      ((0x2UL) << PGACHCTL1_ALL_GAIN0N_Pos)
#define PGACHCTL1_ALL_GAIN0N_SINGLE_16X_DIFF_32X     ((0x3UL) << PGACHCTL1_ALL_GAIN0N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       GAIN1N
 *  @access     PGA->PGACHCTL1.bit.GAIN1N
 *  @brief      Select Gain for negative input of PGA 1
 */
#define PGACHCTL1_ALL_GAIN1N_Pos (11)
#define PGACHCTL1_ALL_GAIN1N_Msk (0x3UL << PGACHCTL1_ALL_GAIN1N_Pos)

typedef enum
{
    PGACHCTL1_BIT_GAIN1N_SINGLE_2X_DIFF_4X       = 0,  /*!< 2x single-ended mode / 4x coupled mode      */
    PGACHCTL1_BIT_GAIN1N_SINGLE_4X_DIFF_8X       = 1,  /*!< 4x single-ended mode / 8x coupled mode      */
    PGACHCTL1_BIT_GAIN1N_SINGLE_8X_DIFF_16X      = 2,  /*!< 8x single-ended mode / 16x coupled mode     */
    PGACHCTL1_BIT_GAIN1N_SINGLE_16X_DIFF_32X     = 3,  /*!< 16x single-ended mode / 32x coupled mode    */
} PGACHCTL1_BIT_GAIN1N;

#define PGACHCTL1_ALL_GAIN1N_SINGLE_2X_DIFF_4X       ((0x0UL) << PGACHCTL1_ALL_GAIN1N_Pos)
#define PGACHCTL1_ALL_GAIN1N_SINGLE_4X_DIFF_8X       ((0x1UL) << PGACHCTL1_ALL_GAIN1N_Pos)
#define PGACHCTL1_ALL_GAIN1N_SINGLE_8X_DIFF_16X      ((0x2UL) << PGACHCTL1_ALL_GAIN1N_Pos)
#define PGACHCTL1_ALL_GAIN1N_SINGLE_16X_DIFF_32X     ((0x3UL) << PGACHCTL1_ALL_GAIN1N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       GAIN2N
 *  @access     PGA->PGACHCTL1.bit.GAIN2N
 *  @brief      Select Gain for negative input of PGA 2
 */
#define PGACHCTL1_ALL_GAIN2N_Pos (13)
#define PGACHCTL1_ALL_GAIN2N_Msk (0x3UL << PGACHCTL1_ALL_GAIN2N_Pos)

typedef enum
{
    PGACHCTL1_BIT_GAIN2N_SINGLE_2X_DIFF_4X       = 0,  /*!< 2x single-ended mode / 4x coupled mode      */
    PGACHCTL1_BIT_GAIN2N_SINGLE_4X_DIFF_8X       = 1,  /*!< 4x single-ended mode / 8x coupled mode      */
    PGACHCTL1_BIT_GAIN2N_SINGLE_8X_DIFF_16X      = 2,  /*!< 8x single-ended mode / 16x coupled mode     */
    PGACHCTL1_BIT_GAIN2N_SINGLE_16X_DIFF_32X     = 3,  /*!< 16x single-ended mode / 32x coupled mode    */
} PGACHCTL1_BIT_GAIN2N;

#define PGACHCTL1_ALL_GAIN2N_SINGLE_2X_DIFF_4X       ((0x0UL) << PGACHCTL1_ALL_GAIN2N_Pos)
#define PGACHCTL1_ALL_GAIN2N_SINGLE_4X_DIFF_8X       ((0x1UL) << PGACHCTL1_ALL_GAIN2N_Pos)
#define PGACHCTL1_ALL_GAIN2N_SINGLE_8X_DIFF_16X      ((0x2UL) << PGACHCTL1_ALL_GAIN2N_Pos)
#define PGACHCTL1_ALL_GAIN2N_SINGLE_16X_DIFF_32X     ((0x3UL) << PGACHCTL1_ALL_GAIN2N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       RDIVSEL0
 *  @access     PGA->PGACHCTL1.bit.RDIVSEL0
 *  @brief      Select output voltage of Resistor-Divider for PGA 0
 *              RESDIV 0 OUTPUT = RDIVSEL0*VDDA/32
 */
#define PGACHCTL1_ALL_RDIVSEL0_Pos (15)
#define PGACHCTL1_ALL_RDIVSEL0_Msk (0x1FUL << PGACHCTL1_ALL_RDIVSEL0_Pos)

#define PGACHCTL1_BIT_RDIVSEL0

#define PGACHCTL1_ALL_RDIVSEL0_(x) ((x) << PGACHCTL1_ALL_RDIVSEL0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       RDIVSEL1
 *  @access     PGA->PGACHCTL1.bit.RDIVSEL1
 *  @brief      Select output voltage of Resistor-Divider for PGA 1
 *              RESDIV 1 OUTPUT = RDIVSEL1*VDDA/32
 */
#define PGACHCTL1_ALL_RDIVSEL1_Pos (20)
#define PGACHCTL1_ALL_RDIVSEL1_Msk (0x1FUL << PGACHCTL1_ALL_RDIVSEL1_Pos)

#define PGACHCTL1_BIT_RDIVSEL1

#define PGACHCTL1_ALL_RDIVSEL1_(x) ((x) << PGACHCTL1_ALL_RDIVSEL1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACHCTL1       RDIVSEL2
 *  @access     PGA->PGACHCTL1.bit.RDIVSEL2
 *  @brief      Select output voltage of Resistor-Divider for PGA 2
 *              RESDIV 2 OUTPUT = RDIVSEL2*VDDA/32
 */
#define PGACHCTL1_ALL_RDIVSEL2_Pos (25)
#define PGACHCTL1_ALL_RDIVSEL2_Msk (0x1FUL << PGACHCTL1_ALL_RDIVSEL2_Pos)

#define PGACHCTL1_BIT_RDIVSEL2

#define PGACHCTL1_ALL_RDIVSEL2_(x) ((x) << PGACHCTL1_ALL_RDIVSEL2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         BYP0P
 *  @access     PGA->PGACTL0.bit.BYP0P
 *  @brief      Bypass the positive OP of PGA 0. Input from the positive OP of PGA 0 will be sent to ADC directly.
 */
#define PGACTL0_ALL_BYP0P_Pos (3)
#define PGACTL0_ALL_BYP0P_Msk (0x1UL << PGACTL0_ALL_BYP0P_Pos)

typedef enum
{
    PGACTL0_BIT_BYP0P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_BYP0P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_BYP0P;

#define PGACTL0_ALL_BYP0P_DISABLE     ((0x0UL) << PGACTL0_ALL_BYP0P_Pos)
#define PGACTL0_ALL_BYP0P_ENABLE      ((0x1UL) << PGACTL0_ALL_BYP0P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         BYP1P
 *  @access     PGA->PGACTL0.bit.BYP1P
 *  @brief      Bypass the positive OP of PGA 1. Input from the positive OP of PGA 1 will be sent to ADC directly.
 */
#define PGACTL0_ALL_BYP1P_Pos (4)
#define PGACTL0_ALL_BYP1P_Msk (0x1UL << PGACTL0_ALL_BYP1P_Pos)

typedef enum
{
    PGACTL0_BIT_BYP1P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_BYP1P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_BYP1P;

#define PGACTL0_ALL_BYP1P_DISABLE     ((0x0UL) << PGACTL0_ALL_BYP1P_Pos)
#define PGACTL0_ALL_BYP1P_ENABLE      ((0x1UL) << PGACTL0_ALL_BYP1P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         BYP2P
 *  @access     PGA->PGACTL0.bit.BYP2P
 *  @brief      Bypass the positive OP of PGA 2. Input from the positive OP of PGA 2 will be sent to ADC directly.
 */
#define PGACTL0_ALL_BYP2P_Pos (5)
#define PGACTL0_ALL_BYP2P_Msk (0x1UL << PGACTL0_ALL_BYP2P_Pos)

typedef enum
{
    PGACTL0_BIT_BYP2P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_BYP2P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_BYP2P;

#define PGACTL0_ALL_BYP2P_DISABLE     ((0x0UL) << PGACTL0_ALL_BYP2P_Pos)
#define PGACTL0_ALL_BYP2P_ENABLE      ((0x1UL) << PGACTL0_ALL_BYP2P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         SINGLE0P
 *  @access     PGA->PGACTL0.bit.SINGLE0P
 *  @brief      Single-ended mode enable for the positive OP of PGA 0
 */
#define PGACTL0_ALL_SINGLE0P_Pos (6)
#define PGACTL0_ALL_SINGLE0P_Msk (0x1UL << PGACTL0_ALL_SINGLE0P_Pos)

typedef enum
{
    PGACTL0_BIT_SINGLE0P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_SINGLE0P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_SINGLE0P;

#define PGACTL0_ALL_SINGLE0P_DISABLE     ((0x0UL) << PGACTL0_ALL_SINGLE0P_Pos)
#define PGACTL0_ALL_SINGLE0P_ENABLE      ((0x1UL) << PGACTL0_ALL_SINGLE0P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         SINGLE1P
 *  @access     PGA->PGACTL0.bit.SINGLE1P
 *  @brief      Single-ended mode enable for the positive OP of PGA 1
 */
#define PGACTL0_ALL_SINGLE1P_Pos (7)
#define PGACTL0_ALL_SINGLE1P_Msk (0x1UL << PGACTL0_ALL_SINGLE1P_Pos)

typedef enum
{
    PGACTL0_BIT_SINGLE1P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_SINGLE1P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_SINGLE1P;

#define PGACTL0_ALL_SINGLE1P_DISABLE     ((0x0UL) << PGACTL0_ALL_SINGLE1P_Pos)
#define PGACTL0_ALL_SINGLE1P_ENABLE      ((0x1UL) << PGACTL0_ALL_SINGLE1P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         SINGLE2P
 *  @access     PGA->PGACTL0.bit.SINGLE2P
 *  @brief      Single-ended mode enable for the positive OP of PGA 2
 */
#define PGACTL0_ALL_SINGLE2P_Pos (8)
#define PGACTL0_ALL_SINGLE2P_Msk (0x1UL << PGACTL0_ALL_SINGLE2P_Pos)

typedef enum
{
    PGACTL0_BIT_SINGLE2P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_SINGLE2P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_SINGLE2P;

#define PGACTL0_ALL_SINGLE2P_DISABLE     ((0x0UL) << PGACTL0_ALL_SINGLE2P_Pos)
#define PGACTL0_ALL_SINGLE2P_ENABLE      ((0x1UL) << PGACTL0_ALL_SINGLE2P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         CMEN0P
 *  @access     PGA->PGACTL0.bit.CMEN0P
 *  @brief      Enable using the input from the positive OP of PGA 0 as a common voltage for the differential output
 */
#define PGACTL0_ALL_CMEN0P_Pos (9)
#define PGACTL0_ALL_CMEN0P_Msk (0x1UL << PGACTL0_ALL_CMEN0P_Pos)

typedef enum
{
    PGACTL0_BIT_CMEN0P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_CMEN0P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_CMEN0P;

#define PGACTL0_ALL_CMEN0P_DISABLE     ((0x0UL) << PGACTL0_ALL_CMEN0P_Pos)
#define PGACTL0_ALL_CMEN0P_ENABLE      ((0x1UL) << PGACTL0_ALL_CMEN0P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         CMEN1P
 *  @access     PGA->PGACTL0.bit.CMEN1P
 *  @brief      Enable using the input from the positive OP of PGA 1 as a common voltage for the differential output
 */
#define PGACTL0_ALL_CMEN1P_Pos (10)
#define PGACTL0_ALL_CMEN1P_Msk (0x1UL << PGACTL0_ALL_CMEN1P_Pos)

typedef enum
{
    PGACTL0_BIT_CMEN1P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_CMEN1P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_CMEN1P;

#define PGACTL0_ALL_CMEN1P_DISABLE     ((0x0UL) << PGACTL0_ALL_CMEN1P_Pos)
#define PGACTL0_ALL_CMEN1P_ENABLE      ((0x1UL) << PGACTL0_ALL_CMEN1P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         CMEN2P
 *  @access     PGA->PGACTL0.bit.CMEN2P
 *  @brief      Enable using the input from the positive OP of PGA 2 as a common voltage for the differential output
 */
#define PGACTL0_ALL_CMEN2P_Pos (11)
#define PGACTL0_ALL_CMEN2P_Msk (0x1UL << PGACTL0_ALL_CMEN2P_Pos)

typedef enum
{
    PGACTL0_BIT_CMEN2P_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL0_BIT_CMEN2P_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL0_BIT_CMEN2P;

#define PGACTL0_ALL_CMEN2P_DISABLE     ((0x0UL) << PGACTL0_ALL_CMEN2P_Pos)
#define PGACTL0_ALL_CMEN2P_ENABLE      ((0x1UL) << PGACTL0_ALL_CMEN2P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         EN0P
 *  @access     PGA->PGACTL0.bit.EN0P
 *  @brief      Enable the positive OP of PGA 0
 */
#define PGACTL0_ALL_EN0P_Pos (15)
#define PGACTL0_ALL_EN0P_Msk (0x1UL << PGACTL0_ALL_EN0P_Pos)

typedef enum
{
    PGACTL0_BIT_EN0P_DISABLE     = 0,  /*!< Disable the positive OP of PGA 0   */
    PGACTL0_BIT_EN0P_ENABLE      = 1,  /*!< Enable the positive OP of PGA 0    */
} PGACTL0_BIT_EN0P;

#define PGACTL0_ALL_EN0P_DISABLE     ((0x0UL) << PGACTL0_ALL_EN0P_Pos)
#define PGACTL0_ALL_EN0P_ENABLE      ((0x1UL) << PGACTL0_ALL_EN0P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         EN1P
 *  @access     PGA->PGACTL0.bit.EN1P
 *  @brief      Enable the positive OP of PGA 1
 */
#define PGACTL0_ALL_EN1P_Pos (16)
#define PGACTL0_ALL_EN1P_Msk (0x1UL << PGACTL0_ALL_EN1P_Pos)

typedef enum
{
    PGACTL0_BIT_EN1P_DISABLE     = 0,  /*!< Disable the positive OP of PGA 1   */
    PGACTL0_BIT_EN1P_ENABLE      = 1,  /*!< Enable the positive OP of PGA 1    */
} PGACTL0_BIT_EN1P;

#define PGACTL0_ALL_EN1P_DISABLE     ((0x0UL) << PGACTL0_ALL_EN1P_Pos)
#define PGACTL0_ALL_EN1P_ENABLE      ((0x1UL) << PGACTL0_ALL_EN1P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL0         EN2P
 *  @access     PGA->PGACTL0.bit.EN2P
 *  @brief      Enable the positive OP of PGA 2
 */
#define PGACTL0_ALL_EN2P_Pos (17)
#define PGACTL0_ALL_EN2P_Msk (0x1UL << PGACTL0_ALL_EN2P_Pos)

typedef enum
{
    PGACTL0_BIT_EN2P_DISABLE     = 0,  /*!< Disable the positive OP of PGA 2   */
    PGACTL0_BIT_EN2P_ENABLE      = 1,  /*!< Enable the positive OP of PGA 2    */
} PGACTL0_BIT_EN2P;

#define PGACTL0_ALL_EN2P_DISABLE     ((0x0UL) << PGACTL0_ALL_EN2P_Pos)
#define PGACTL0_ALL_EN2P_ENABLE      ((0x1UL) << PGACTL0_ALL_EN2P_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         BYP0N
 *  @access     PGA->PGACTL1.bit.BYP0N
 *  @brief      Bypass the negative OP of PGA 0. Input from the negative OP of PGA 0 will be sent to ADC directly.
 */
#define PGACTL1_ALL_BYP0N_Pos (3)
#define PGACTL1_ALL_BYP0N_Msk (0x1UL << PGACTL1_ALL_BYP0N_Pos)

typedef enum
{
    PGACTL1_BIT_BYP0N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_BYP0N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_BYP0N;

#define PGACTL1_ALL_BYP0N_DISABLE     ((0x0UL) << PGACTL1_ALL_BYP0N_Pos)
#define PGACTL1_ALL_BYP0N_ENABLE      ((0x1UL) << PGACTL1_ALL_BYP0N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         BYP1N
 *  @access     PGA->PGACTL1.bit.BYP1N
 *  @brief      Bypass the negative OP of PGA 1. Input from the negative OP of PGA 1 will be sent to ADC directly.
 */
#define PGACTL1_ALL_BYP1N_Pos (4)
#define PGACTL1_ALL_BYP1N_Msk (0x1UL << PGACTL1_ALL_BYP1N_Pos)

typedef enum
{
    PGACTL1_BIT_BYP1N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_BYP1N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_BYP1N;

#define PGACTL1_ALL_BYP1N_DISABLE     ((0x0UL) << PGACTL1_ALL_BYP1N_Pos)
#define PGACTL1_ALL_BYP1N_ENABLE      ((0x1UL) << PGACTL1_ALL_BYP1N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         BYP2N
 *  @access     PGA->PGACTL1.bit.BYP2N
 *  @brief      Bypass the negative OP of PGA 2. Input from the negative OP of PGA 2 will be sent to ADC directly.
 */
#define PGACTL1_ALL_BYP2N_Pos (5)
#define PGACTL1_ALL_BYP2N_Msk (0x1UL << PGACTL1_ALL_BYP2N_Pos)

typedef enum
{
    PGACTL1_BIT_BYP2N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_BYP2N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_BYP2N;

#define PGACTL1_ALL_BYP2N_DISABLE     ((0x0UL) << PGACTL1_ALL_BYP2N_Pos)
#define PGACTL1_ALL_BYP2N_ENABLE      ((0x1UL) << PGACTL1_ALL_BYP2N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         SINGLE0N
 *  @access     PGA->PGACTL1.bit.SINGLE0N
 *  @brief      Single-ended mode enable for the negative OP of PGA 0
 */
#define PGACTL1_ALL_SINGLE0N_Pos (6)
#define PGACTL1_ALL_SINGLE0N_Msk (0x1UL << PGACTL1_ALL_SINGLE0N_Pos)

typedef enum
{
    PGACTL1_BIT_SINGLE0N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_SINGLE0N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_SINGLE0N;

#define PGACTL1_ALL_SINGLE0N_DISABLE     ((0x0UL) << PGACTL1_ALL_SINGLE0N_Pos)
#define PGACTL1_ALL_SINGLE0N_ENABLE      ((0x1UL) << PGACTL1_ALL_SINGLE0N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         SINGLE1N
 *  @access     PGA->PGACTL1.bit.SINGLE1N
 *  @brief      Single-ended mode enable for the negative OP of PGA 1
 */
#define PGACTL1_ALL_SINGLE1N_Pos (7)
#define PGACTL1_ALL_SINGLE1N_Msk (0x1UL << PGACTL1_ALL_SINGLE1N_Pos)

typedef enum
{
    PGACTL1_BIT_SINGLE1N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_SINGLE1N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_SINGLE1N;

#define PGACTL1_ALL_SINGLE1N_DISABLE     ((0x0UL) << PGACTL1_ALL_SINGLE1N_Pos)
#define PGACTL1_ALL_SINGLE1N_ENABLE      ((0x1UL) << PGACTL1_ALL_SINGLE1N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         SINGLE2N
 *  @access     PGA->PGACTL1.bit.SINGLE2N
 *  @brief      Single-ended mode enable for the negative OP of PGA 2
 */
#define PGACTL1_ALL_SINGLE2N_Pos (8)
#define PGACTL1_ALL_SINGLE2N_Msk (0x1UL << PGACTL1_ALL_SINGLE2N_Pos)

typedef enum
{
    PGACTL1_BIT_SINGLE2N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_SINGLE2N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_SINGLE2N;

#define PGACTL1_ALL_SINGLE2N_DISABLE     ((0x0UL) << PGACTL1_ALL_SINGLE2N_Pos)
#define PGACTL1_ALL_SINGLE2N_ENABLE      ((0x1UL) << PGACTL1_ALL_SINGLE2N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         CMEN0N
 *  @access     PGA->PGACTL1.bit.CMEN0N
 *  @brief      Enable using the input from the negative OP of PGA 0 as a common voltage for the differential output
 */
#define PGACTL1_ALL_CMEN0N_Pos (9)
#define PGACTL1_ALL_CMEN0N_Msk (0x1UL << PGACTL1_ALL_CMEN0N_Pos)

typedef enum
{
    PGACTL1_BIT_CMEN0N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_CMEN0N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_CMEN0N;

#define PGACTL1_ALL_CMEN0N_DISABLE     ((0x0UL) << PGACTL1_ALL_CMEN0N_Pos)
#define PGACTL1_ALL_CMEN0N_ENABLE      ((0x1UL) << PGACTL1_ALL_CMEN0N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         CMEN1N
 *  @access     PGA->PGACTL1.bit.CMEN1N
 *  @brief      Enable using the input from the negative OP of PGA 1 as a common voltage for the differential output
 */
#define PGACTL1_ALL_CMEN1N_Pos (10)
#define PGACTL1_ALL_CMEN1N_Msk (0x1UL << PGACTL1_ALL_CMEN1N_Pos)

typedef enum
{
    PGACTL1_BIT_CMEN1N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_CMEN1N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_CMEN1N;

#define PGACTL1_ALL_CMEN1N_DISABLE     ((0x0UL) << PGACTL1_ALL_CMEN1N_Pos)
#define PGACTL1_ALL_CMEN1N_ENABLE      ((0x1UL) << PGACTL1_ALL_CMEN1N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         CMEN2N
 *  @access     PGA->PGACTL1.bit.CMEN2N
 *  @brief      Enable using the input from the negative OP of PGA 2 as a common voltage for the differential output
 */
#define PGACTL1_ALL_CMEN2N_Pos (11)
#define PGACTL1_ALL_CMEN2N_Msk (0x1UL << PGACTL1_ALL_CMEN2N_Pos)

typedef enum
{
    PGACTL1_BIT_CMEN2N_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_CMEN2N_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_CMEN2N;

#define PGACTL1_ALL_CMEN2N_DISABLE     ((0x0UL) << PGACTL1_ALL_CMEN2N_Pos)
#define PGACTL1_ALL_CMEN2N_ENABLE      ((0x1UL) << PGACTL1_ALL_CMEN2N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         EN0N
 *  @access     PGA->PGACTL1.bit.EN0N
 *  @brief      Enable the negative OP of PGA 0
 */
#define PGACTL1_ALL_EN0N_Pos (15)
#define PGACTL1_ALL_EN0N_Msk (0x1UL << PGACTL1_ALL_EN0N_Pos)

typedef enum
{
    PGACTL1_BIT_EN0N_DISABLE     = 0,  /*!< Disable the positive OP of PGA 0   */
    PGACTL1_BIT_EN0N_ENABLE      = 1,  /*!< Enable the positive OP of PGA 0    */
} PGACTL1_BIT_EN0N;

#define PGACTL1_ALL_EN0N_DISABLE     ((0x0UL) << PGACTL1_ALL_EN0N_Pos)
#define PGACTL1_ALL_EN0N_ENABLE      ((0x1UL) << PGACTL1_ALL_EN0N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         EN1N
 *  @access     PGA->PGACTL1.bit.EN1N
 *  @brief      Enable the negative OP of PGA 1
 */
#define PGACTL1_ALL_EN1N_Pos (16)
#define PGACTL1_ALL_EN1N_Msk (0x1UL << PGACTL1_ALL_EN1N_Pos)

typedef enum
{
    PGACTL1_BIT_EN1N_DISABLE     = 0,  /*!< Disable the positive OP of PGA 1   */
    PGACTL1_BIT_EN1N_ENABLE      = 1,  /*!< Enable the positive OP of PGA 1    */
} PGACTL1_BIT_EN1N;

#define PGACTL1_ALL_EN1N_DISABLE     ((0x0UL) << PGACTL1_ALL_EN1N_Pos)
#define PGACTL1_ALL_EN1N_ENABLE      ((0x1UL) << PGACTL1_ALL_EN1N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         EN2N
 *  @access     PGA->PGACTL1.bit.EN2N
 *  @brief      Enable the negative OP of PGA 2
 */
#define PGACTL1_ALL_EN2N_Pos (17)
#define PGACTL1_ALL_EN2N_Msk (0x1UL << PGACTL1_ALL_EN2N_Pos)

typedef enum
{
    PGACTL1_BIT_EN2N_DISABLE     = 0,  /*!< Disable the positive OP of PGA 2   */
    PGACTL1_BIT_EN2N_ENABLE      = 1,  /*!< Enable the positive OP of PGA 2    */
} PGACTL1_BIT_EN2N;

#define PGACTL1_ALL_EN2N_DISABLE     ((0x0UL) << PGACTL1_ALL_EN2N_Pos)
#define PGACTL1_ALL_EN2N_ENABLE      ((0x1UL) << PGACTL1_ALL_EN2N_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         RDIVEN0
 *  @access     PGA->PGACTL1.bit.RDIVEN0
 *  @brief      Enable Resistor-Divider(RESDIV) 0
 */
#define PGACTL1_ALL_RDIVEN0_Pos (18)
#define PGACTL1_ALL_RDIVEN0_Msk (0x1UL << PGACTL1_ALL_RDIVEN0_Pos)

typedef enum
{
    PGACTL1_BIT_RDIVEN0_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_RDIVEN0_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_RDIVEN0;

#define PGACTL1_ALL_RDIVEN0_DISABLE     ((0x0UL) << PGACTL1_ALL_RDIVEN0_Pos)
#define PGACTL1_ALL_RDIVEN0_ENABLE      ((0x1UL) << PGACTL1_ALL_RDIVEN0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         RDIVEN1
 *  @access     PGA->PGACTL1.bit.RDIVEN1
 *  @brief      Enable Resistor-Divider(RESDIV) 1
 */
#define PGACTL1_ALL_RDIVEN1_Pos (19)
#define PGACTL1_ALL_RDIVEN1_Msk (0x1UL << PGACTL1_ALL_RDIVEN1_Pos)

typedef enum
{
    PGACTL1_BIT_RDIVEN1_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_RDIVEN1_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_RDIVEN1;

#define PGACTL1_ALL_RDIVEN1_DISABLE     ((0x0UL) << PGACTL1_ALL_RDIVEN1_Pos)
#define PGACTL1_ALL_RDIVEN1_ENABLE      ((0x1UL) << PGACTL1_ALL_RDIVEN1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PGA             PGACTL1         RDIVEN2
 *  @access     PGA->PGACTL1.bit.RDIVEN2
 *  @brief      Enable Resistor-Divider(RESDIV) 2
 */
#define PGACTL1_ALL_RDIVEN2_Pos (20)
#define PGACTL1_ALL_RDIVEN2_Msk (0x1UL << PGACTL1_ALL_RDIVEN2_Pos)

typedef enum
{
    PGACTL1_BIT_RDIVEN2_DISABLE     = 0,  /*!< Disable this function   */
    PGACTL1_BIT_RDIVEN2_ENABLE      = 1,  /*!< Enable this function    */
} PGACTL1_BIT_RDIVEN2;

#define PGACTL1_ALL_RDIVEN2_DISABLE     ((0x0UL) << PGACTL1_ALL_RDIVEN2_Pos)
#define PGACTL1_ALL_RDIVEN2_ENABLE      ((0x1UL) << PGACTL1_ALL_RDIVEN2_Pos)





/********************************************************************************
*
* Module Name     COMP
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPSEL         CHSEL0
 *  @access     COMP->COMPSEL.bit.CHSEL0
 *  @brief      Select the input source of high speed comparator in PGA 0
 */
#define COMPSEL_ALL_CHSEL0_Pos (0)
#define COMPSEL_ALL_CHSEL0_Msk (0x3UL << COMPSEL_ALL_CHSEL0_Pos)

typedef enum
{
    COMPSEL_BIT_CHSEL0_PGA0N_OUT     = 0,  /*!< Select the input source of high speed comparator as output of pga0n    */
    COMPSEL_BIT_CHSEL0_PGA0P_OUT     = 1,  /*!< Select the input source of high speed comparator as output of pga0p    */
    COMPSEL_BIT_CHSEL0_PGA0N_IN      = 2,  /*!< Select the input source of high speed comparator as  input of pga0n    */
    COMPSEL_BIT_CHSEL0_PGA0P_IN      = 3,  /*!< Select the input source of high speed comparator as  input of pga0p    */
} COMPSEL_BIT_CHSEL0;

#define COMPSEL_ALL_CHSEL0_PGA0N_OUT     ((0x0UL) << COMPSEL_ALL_CHSEL0_Pos)
#define COMPSEL_ALL_CHSEL0_PGA0P_OUT     ((0x1UL) << COMPSEL_ALL_CHSEL0_Pos)
#define COMPSEL_ALL_CHSEL0_PGA0N_IN      ((0x2UL) << COMPSEL_ALL_CHSEL0_Pos)
#define COMPSEL_ALL_CHSEL0_PGA0P_IN      ((0x3UL) << COMPSEL_ALL_CHSEL0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPSEL         CHSEL1
 *  @access     COMP->COMPSEL.bit.CHSEL1
 *  @brief      Select the input source of high speed comparator in PGA 1
 */
#define COMPSEL_ALL_CHSEL1_Pos (2)
#define COMPSEL_ALL_CHSEL1_Msk (0x3UL << COMPSEL_ALL_CHSEL1_Pos)

typedef enum
{
    COMPSEL_BIT_CHSEL1_PGA1N_OUT     = 0,  /*!< Select the input source of high speed comparator as output of pga1n    */
    COMPSEL_BIT_CHSEL1_PGA1P_OUT     = 1,  /*!< Select the input source of high speed comparator as output of pga1p    */
    COMPSEL_BIT_CHSEL1_PGA1N_IN      = 2,  /*!< Select the input source of high speed comparator as  input of pga1n    */
    COMPSEL_BIT_CHSEL1_PGA1P_IN      = 3,  /*!< Select the input source of high speed comparator as  input of pga1p    */
} COMPSEL_BIT_CHSEL1;

#define COMPSEL_ALL_CHSEL1_PGA1N_OUT     ((0x0UL) << COMPSEL_ALL_CHSEL1_Pos)
#define COMPSEL_ALL_CHSEL1_PGA1P_OUT     ((0x1UL) << COMPSEL_ALL_CHSEL1_Pos)
#define COMPSEL_ALL_CHSEL1_PGA1N_IN      ((0x2UL) << COMPSEL_ALL_CHSEL1_Pos)
#define COMPSEL_ALL_CHSEL1_PGA1P_IN      ((0x3UL) << COMPSEL_ALL_CHSEL1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPSEL         CHSEL2
 *  @access     COMP->COMPSEL.bit.CHSEL2
 *  @brief      Select the input source of high speed comparator in PGA 2
 */
#define COMPSEL_ALL_CHSEL2_Pos (4)
#define COMPSEL_ALL_CHSEL2_Msk (0x3UL << COMPSEL_ALL_CHSEL2_Pos)

typedef enum
{
    COMPSEL_BIT_CHSEL2_PGA2N_OUT     = 0,  /*!< Select the input source of high speed comparator as output of pga2n    */
    COMPSEL_BIT_CHSEL2_PGA2P_OUT     = 1,  /*!< Select the input source of high speed comparator as output of pga2p    */
    COMPSEL_BIT_CHSEL2_PGA2N_IN      = 2,  /*!< Select the input source of high speed comparator as  input of pga2n    */
    COMPSEL_BIT_CHSEL2_PGA2P_IN      = 3,  /*!< Select the input source of high speed comparator as  input of pga2p    */
} COMPSEL_BIT_CHSEL2;

#define COMPSEL_ALL_CHSEL2_PGA2N_OUT     ((0x0UL) << COMPSEL_ALL_CHSEL2_Pos)
#define COMPSEL_ALL_CHSEL2_PGA2P_OUT     ((0x1UL) << COMPSEL_ALL_CHSEL2_Pos)
#define COMPSEL_ALL_CHSEL2_PGA2N_IN      ((0x2UL) << COMPSEL_ALL_CHSEL2_Pos)
#define COMPSEL_ALL_CHSEL2_PGA2P_IN      ((0x3UL) << COMPSEL_ALL_CHSEL2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP0LINV
 *  @access     COMP->COMPCTL.bit.COMP0LINV
 *  @brief      Invert the output of high speed comparator for low-voltage protection in PGA 0
 */
#define COMPCTL_ALL_COMP0LINV_Pos (6)
#define COMPCTL_ALL_COMP0LINV_Msk (0x1UL << COMPCTL_ALL_COMP0LINV_Pos)

typedef enum
{
    COMPCTL_BIT_COMP0LINV_DISABLE     = 0,  /*!< Keep the output of high speed comparator      */
    COMPCTL_BIT_COMP0LINV_ENABLE      = 1,  /*!< Invert the output of high speed comparator    */
} COMPCTL_BIT_COMP0LINV;

#define COMPCTL_ALL_COMP0LINV_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP0LINV_Pos)
#define COMPCTL_ALL_COMP0LINV_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP0LINV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP1LINV
 *  @access     COMP->COMPCTL.bit.COMP1LINV
 *  @brief      Invert the output of high speed comparator for low-voltage protection in PGA 1
 */
#define COMPCTL_ALL_COMP1LINV_Pos (7)
#define COMPCTL_ALL_COMP1LINV_Msk (0x1UL << COMPCTL_ALL_COMP1LINV_Pos)

typedef enum
{
    COMPCTL_BIT_COMP1LINV_DISABLE     = 0,  /*!< Keep the output of high speed comparator      */
    COMPCTL_BIT_COMP1LINV_ENABLE      = 1,  /*!< Invert the output of high speed comparator    */
} COMPCTL_BIT_COMP1LINV;

#define COMPCTL_ALL_COMP1LINV_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP1LINV_Pos)
#define COMPCTL_ALL_COMP1LINV_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP1LINV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP2LINV
 *  @access     COMP->COMPCTL.bit.COMP2LINV
 *  @brief      Invert the output of high speed comparator for low-voltage protection in PGA 2
 */
#define COMPCTL_ALL_COMP2LINV_Pos (8)
#define COMPCTL_ALL_COMP2LINV_Msk (0x1UL << COMPCTL_ALL_COMP2LINV_Pos)

typedef enum
{
    COMPCTL_BIT_COMP2LINV_DISABLE     = 0,  /*!< Keep the output of high speed comparator      */
    COMPCTL_BIT_COMP2LINV_ENABLE      = 1,  /*!< Invert the output of high speed comparator    */
} COMPCTL_BIT_COMP2LINV;

#define COMPCTL_ALL_COMP2LINV_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP2LINV_Pos)
#define COMPCTL_ALL_COMP2LINV_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP2LINV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP0HINV
 *  @access     COMP->COMPCTL.bit.COMP0HINV
 *  @brief      Invert the output of high speed comparator for high-voltage protection in PGA 0
 */
#define COMPCTL_ALL_COMP0HINV_Pos (9)
#define COMPCTL_ALL_COMP0HINV_Msk (0x1UL << COMPCTL_ALL_COMP0HINV_Pos)

typedef enum
{
    COMPCTL_BIT_COMP0HINV_DISABLE     = 0,  /*!< Keep the output of high speed comparator      */
    COMPCTL_BIT_COMP0HINV_ENABLE      = 1,  /*!< Invert the output of high speed comparator    */
} COMPCTL_BIT_COMP0HINV;

#define COMPCTL_ALL_COMP0HINV_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP0HINV_Pos)
#define COMPCTL_ALL_COMP0HINV_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP0HINV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP1HINV
 *  @access     COMP->COMPCTL.bit.COMP1HINV
 *  @brief      Invert the output of high speed comparator for high-voltage protection in PGA 1
 */
#define COMPCTL_ALL_COMP1HINV_Pos (10)
#define COMPCTL_ALL_COMP1HINV_Msk (0x1UL << COMPCTL_ALL_COMP1HINV_Pos)

typedef enum
{
    COMPCTL_BIT_COMP1HINV_DISABLE     = 0,  /*!< Keep the output of high speed comparator      */
    COMPCTL_BIT_COMP1HINV_ENABLE      = 1,  /*!< Invert the output of high speed comparator    */
} COMPCTL_BIT_COMP1HINV;

#define COMPCTL_ALL_COMP1HINV_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP1HINV_Pos)
#define COMPCTL_ALL_COMP1HINV_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP1HINV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP2HINV
 *  @access     COMP->COMPCTL.bit.COMP2HINV
 *  @brief      Invert the output of high speed comparator for high-voltage protection in PGA 2
 */
#define COMPCTL_ALL_COMP2HINV_Pos (11)
#define COMPCTL_ALL_COMP2HINV_Msk (0x1UL << COMPCTL_ALL_COMP2HINV_Pos)

typedef enum
{
    COMPCTL_BIT_COMP2HINV_DISABLE     = 0,  /*!< Keep the output of high speed comparator      */
    COMPCTL_BIT_COMP2HINV_ENABLE      = 1,  /*!< Invert the output of high speed comparator    */
} COMPCTL_BIT_COMP2HINV;

#define COMPCTL_ALL_COMP2HINV_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP2HINV_Pos)
#define COMPCTL_ALL_COMP2HINV_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP2HINV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP0LEN
 *  @access     COMP->COMPCTL.bit.COMP0LEN
 *  @brief      Enable the high speed comparator of low-voltage protection in PGA0
 */
#define COMPCTL_ALL_COMP0LEN_Pos (12)
#define COMPCTL_ALL_COMP0LEN_Msk (0x1UL << COMPCTL_ALL_COMP0LEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP0LEN_DISABLE     = 0,  /*!< Disable Comparator   */
    COMPCTL_BIT_COMP0LEN_ENABLE      = 1,  /*!< Enable Comparator    */
} COMPCTL_BIT_COMP0LEN;

#define COMPCTL_ALL_COMP0LEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP0LEN_Pos)
#define COMPCTL_ALL_COMP0LEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP0LEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP1LEN
 *  @access     COMP->COMPCTL.bit.COMP1LEN
 *  @brief      Enable the high speed comparator of low-voltage protection in PGA1
 */
#define COMPCTL_ALL_COMP1LEN_Pos (13)
#define COMPCTL_ALL_COMP1LEN_Msk (0x1UL << COMPCTL_ALL_COMP1LEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP1LEN_DISABLE     = 0,  /*!< Disable Comparator   */
    COMPCTL_BIT_COMP1LEN_ENABLE      = 1,  /*!< Enable Comparator    */
} COMPCTL_BIT_COMP1LEN;

#define COMPCTL_ALL_COMP1LEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP1LEN_Pos)
#define COMPCTL_ALL_COMP1LEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP1LEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP2LEN
 *  @access     COMP->COMPCTL.bit.COMP2LEN
 *  @brief      Enable the high speed comparator of low-voltage protection in PGA2
 */
#define COMPCTL_ALL_COMP2LEN_Pos (14)
#define COMPCTL_ALL_COMP2LEN_Msk (0x1UL << COMPCTL_ALL_COMP2LEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP2LEN_DISABLE     = 0,  /*!< Disable Comparator   */
    COMPCTL_BIT_COMP2LEN_ENABLE      = 1,  /*!< Enable Comparator    */
} COMPCTL_BIT_COMP2LEN;

#define COMPCTL_ALL_COMP2LEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP2LEN_Pos)
#define COMPCTL_ALL_COMP2LEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP2LEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP0HEN
 *  @access     COMP->COMPCTL.bit.COMP0HEN
 *  @brief      Enable the high speed comparator of high-voltage protection in PGA0
 */
#define COMPCTL_ALL_COMP0HEN_Pos (15)
#define COMPCTL_ALL_COMP0HEN_Msk (0x1UL << COMPCTL_ALL_COMP0HEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP0HEN_DISABLE     = 0,  /*!< Disable Comparator   */
    COMPCTL_BIT_COMP0HEN_ENABLE      = 1,  /*!< Enable Comparator    */
} COMPCTL_BIT_COMP0HEN;

#define COMPCTL_ALL_COMP0HEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP0HEN_Pos)
#define COMPCTL_ALL_COMP0HEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP0HEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP1HEN
 *  @access     COMP->COMPCTL.bit.COMP1HEN
 *  @brief      Enable the high speed comparator of high-voltage protection in PGA1
 */
#define COMPCTL_ALL_COMP1HEN_Pos (16)
#define COMPCTL_ALL_COMP1HEN_Msk (0x1UL << COMPCTL_ALL_COMP1HEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP1HEN_DISABLE     = 0,  /*!< Disable Comparator   */
    COMPCTL_BIT_COMP1HEN_ENABLE      = 1,  /*!< Enable Comparator    */
} COMPCTL_BIT_COMP1HEN;

#define COMPCTL_ALL_COMP1HEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP1HEN_Pos)
#define COMPCTL_ALL_COMP1HEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP1HEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP2HEN
 *  @access     COMP->COMPCTL.bit.COMP2HEN
 *  @brief      Enable the high speed comparator of high-voltage protection in PGA2
 */
#define COMPCTL_ALL_COMP2HEN_Pos (17)
#define COMPCTL_ALL_COMP2HEN_Msk (0x1UL << COMPCTL_ALL_COMP2HEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP2HEN_DISABLE     = 0,  /*!< Disable Comparator   */
    COMPCTL_BIT_COMP2HEN_ENABLE      = 1,  /*!< Enable Comparator    */
} COMPCTL_BIT_COMP2HEN;

#define COMPCTL_ALL_COMP2HEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP2HEN_Pos)
#define COMPCTL_ALL_COMP2HEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP2HEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP0LHYEN
 *  @access     COMP->COMPCTL.bit.COMP0LHYEN
 *  @brief      Enable high speed comparator's hysteresis of low-voltage protection in PGA 0
 */
#define COMPCTL_ALL_COMP0LHYEN_Pos (18)
#define COMPCTL_ALL_COMP0LHYEN_Msk (0x1UL << COMPCTL_ALL_COMP0LHYEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP0LHYEN_DISABLE     = 0,  /*!< Disable hysteresis   */
    COMPCTL_BIT_COMP0LHYEN_ENABLE      = 1,  /*!< Enable hysteresis    */
} COMPCTL_BIT_COMP0LHYEN;

#define COMPCTL_ALL_COMP0LHYEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP0LHYEN_Pos)
#define COMPCTL_ALL_COMP0LHYEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP0LHYEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP1LHYEN
 *  @access     COMP->COMPCTL.bit.COMP1LHYEN
 *  @brief      Enable high speed comparator's hysteresis of low-voltage protection in PGA 1
 */
#define COMPCTL_ALL_COMP1LHYEN_Pos (19)
#define COMPCTL_ALL_COMP1LHYEN_Msk (0x1UL << COMPCTL_ALL_COMP1LHYEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP1LHYEN_DISABLE     = 0,  /*!< Disable hysteresis   */
    COMPCTL_BIT_COMP1LHYEN_ENABLE      = 1,  /*!< Enable hysteresis    */
} COMPCTL_BIT_COMP1LHYEN;

#define COMPCTL_ALL_COMP1LHYEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP1LHYEN_Pos)
#define COMPCTL_ALL_COMP1LHYEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP1LHYEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP2LHYEN
 *  @access     COMP->COMPCTL.bit.COMP2LHYEN
 *  @brief      Enable high speed comparator's hysteresis of low-voltage protection in PGA 2
 */
#define COMPCTL_ALL_COMP2LHYEN_Pos (20)
#define COMPCTL_ALL_COMP2LHYEN_Msk (0x1UL << COMPCTL_ALL_COMP2LHYEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP2LHYEN_DISABLE     = 0,  /*!< Disable hysteresis   */
    COMPCTL_BIT_COMP2LHYEN_ENABLE      = 1,  /*!< Enable hysteresis    */
} COMPCTL_BIT_COMP2LHYEN;

#define COMPCTL_ALL_COMP2LHYEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP2LHYEN_Pos)
#define COMPCTL_ALL_COMP2LHYEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP2LHYEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP0HHYEN
 *  @access     COMP->COMPCTL.bit.COMP0HHYEN
 *  @brief      Enable high speed comparator's hysteresis of high-voltage protection in PGA 0
 */
#define COMPCTL_ALL_COMP0HHYEN_Pos (21)
#define COMPCTL_ALL_COMP0HHYEN_Msk (0x1UL << COMPCTL_ALL_COMP0HHYEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP0HHYEN_DISABLE     = 0,  /*!< Disable hysteresis   */
    COMPCTL_BIT_COMP0HHYEN_ENABLE      = 1,  /*!< Enable hysteresis    */
} COMPCTL_BIT_COMP0HHYEN;

#define COMPCTL_ALL_COMP0HHYEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP0HHYEN_Pos)
#define COMPCTL_ALL_COMP0HHYEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP0HHYEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP1HHYEN
 *  @access     COMP->COMPCTL.bit.COMP1HHYEN
 *  @brief      Enable high speed comparator's hysteresis of high-voltage protection in PGA 1
 */
#define COMPCTL_ALL_COMP1HHYEN_Pos (22)
#define COMPCTL_ALL_COMP1HHYEN_Msk (0x1UL << COMPCTL_ALL_COMP1HHYEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP1HHYEN_DISABLE     = 0,  /*!< Disable hysteresis   */
    COMPCTL_BIT_COMP1HHYEN_ENABLE      = 1,  /*!< Enable hysteresis    */
} COMPCTL_BIT_COMP1HHYEN;

#define COMPCTL_ALL_COMP1HHYEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP1HHYEN_Pos)
#define COMPCTL_ALL_COMP1HHYEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP1HHYEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         COMP2HHYEN
 *  @access     COMP->COMPCTL.bit.COMP2HHYEN
 *  @brief      Enable high speed comparator's hysteresis of high-voltage protection in PGA 2
 */
#define COMPCTL_ALL_COMP2HHYEN_Pos (23)
#define COMPCTL_ALL_COMP2HHYEN_Msk (0x1UL << COMPCTL_ALL_COMP2HHYEN_Pos)

typedef enum
{
    COMPCTL_BIT_COMP2HHYEN_DISABLE     = 0,  /*!< Disable hysteresis   */
    COMPCTL_BIT_COMP2HHYEN_ENABLE      = 1,  /*!< Enable hysteresis    */
} COMPCTL_BIT_COMP2HHYEN;

#define COMPCTL_ALL_COMP2HHYEN_DISABLE     ((0x0UL) << COMPCTL_ALL_COMP2HHYEN_Pos)
#define COMPCTL_ALL_COMP2HHYEN_ENABLE      ((0x1UL) << COMPCTL_ALL_COMP2HHYEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         DGPRDSEL
 *  @access     COMP->COMPCTL.bit.DGPRDSEL
 *  @brief      Qualification period for synchronized output of the comparator
 *              00h: Synchronized value of comparator is passed through
 *              01h: Input to the block must be consistent for 2 consecutive clocks before output of deglitch block can change
 *              02h: Input to the block must be consistent for 3 consecutive clocks before output of deglitch block can change
 *              ......
 *              7fh: Input to the block must be consistent for 128 consecutive clocks before output of deglitch block can change
 */
#define COMPCTL_ALL_DGPRDSEL_Pos (24)
#define COMPCTL_ALL_DGPRDSEL_Msk (0x7FUL << COMPCTL_ALL_DGPRDSEL_Pos)

#define COMPCTL_BIT_DGPRDSEL

#define COMPCTL_ALL_DGPRDSEL_(x) ((x) << COMPCTL_ALL_DGPRDSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            COMPCTL         DGEN
 *  @access     COMP->COMPCTL.bit.DGEN
 *  @brief      Synchronization select for output of the comparator before being passed to PWM/GPIO blocks
 */
#define COMPCTL_ALL_DGEN_Pos (31)
#define COMPCTL_ALL_DGEN_Msk (0x1UL << COMPCTL_ALL_DGEN_Pos)

typedef enum
{
    COMPCTL_BIT_DGEN_FILTER_DISABLE     = 0,  /*!< Asynchronous version of Comparator output is passed   */
    COMPCTL_BIT_DGEN_FILTER_ENABLE      = 1,  /*!< Synchronous version of comparator output is passed    */
} COMPCTL_BIT_DGEN;

#define COMPCTL_ALL_DGEN_FILTER_DISABLE     ((0x0UL) << COMPCTL_ALL_DGEN_Pos)
#define COMPCTL_ALL_DGEN_FILTER_ENABLE      ((0x1UL) << COMPCTL_ALL_DGEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            DACCODE         LO
 *  @access     COMP->DACCODE.bit.LO
 *  @brief      Digital input of 10-bit DAC for low-ref
 */
#define DACCODE_ALL_LO_Pos (0)
#define DACCODE_ALL_LO_Msk (0x3FFUL << DACCODE_ALL_LO_Pos)

#define DACCODE_BIT_LO

#define DACCODE_ALL_LO_(x) ((x) << DACCODE_ALL_LO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            DACCODE         HI
 *  @access     COMP->DACCODE.bit.HI
 *  @brief      Digital input of 10-bit DAC for high-ref
 */
#define DACCODE_ALL_HI_Pos (10)
#define DACCODE_ALL_HI_Msk (0x3FFUL << DACCODE_ALL_HI_Pos)

#define DACCODE_BIT_HI

#define DACCODE_ALL_HI_(x) ((x) << DACCODE_ALL_HI_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            DACCTL          RANGE2XLO
 *  @access     COMP->DACCTL.bit.RANGE2XLO
 *  @brief      Select Low DAC range in current driving mode
 */
#define DACCTL_ALL_RANGE2XLO_Pos (2)
#define DACCTL_ALL_RANGE2XLO_Msk (0x1UL << DACCTL_ALL_RANGE2XLO_Pos)

typedef enum
{
    DACCTL_BIT_RANGE2XLO_0_TO_1dot1_V     = 0,  /*!< Set output range for low ref DAC to be 0~1.1V in current driving mode   */
    DACCTL_BIT_RANGE2XLO_0_TO_2dot2_V     = 1,  /*!< Set output range for low ref DAC to be 0~2.2V in current driving mode   */
} DACCTL_BIT_RANGE2XLO;

#define DACCTL_ALL_RANGE2XLO_0_TO_1dot1_V     ((0x0UL) << DACCTL_ALL_RANGE2XLO_Pos)
#define DACCTL_ALL_RANGE2XLO_0_TO_2dot2_V     ((0x1UL) << DACCTL_ALL_RANGE2XLO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            DACCTL          RANGE2XHI
 *  @access     COMP->DACCTL.bit.RANGE2XHI
 *  @brief      Select High DAC range in current driving mode
 */
#define DACCTL_ALL_RANGE2XHI_Pos (3)
#define DACCTL_ALL_RANGE2XHI_Msk (0x1UL << DACCTL_ALL_RANGE2XHI_Pos)

typedef enum
{
    DACCTL_BIT_RANGE2XHI_0_TO_1dot1_V     = 0,  /*!< Set output range for high ref DAC to be 0~1.1V in current driving mode   */
    DACCTL_BIT_RANGE2XHI_0_TO_2dot2_V     = 1,  /*!< Set output range for high ref DAC to be 0~2.2V in current driving mode   */
} DACCTL_BIT_RANGE2XHI;

#define DACCTL_ALL_RANGE2XHI_0_TO_1dot1_V     ((0x0UL) << DACCTL_ALL_RANGE2XHI_Pos)
#define DACCTL_ALL_RANGE2XHI_0_TO_2dot2_V     ((0x1UL) << DACCTL_ALL_RANGE2XHI_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            DACCTL          DIVSRCLO
 *  @access     COMP->DACCTL.bit.DIVSRCLO
 *  @brief      Select DAC Low DAC Driving Mode
 */
#define DACCTL_ALL_DIVSRCLO_Pos (4)
#define DACCTL_ALL_DIVSRCLO_Msk (0x1UL << DACCTL_ALL_DIVSRCLO_Pos)

typedef enum
{
    DACCTL_BIT_DIVSRCLO_CURRENT_DRV     = 0,  /*!< Enable current driving mode as High DAC output, 10 bit resolution    */
    DACCTL_BIT_DIVSRCLO_VDDX_DRV        = 1,  /*!< Enable VDDX divider mode as High DAC output, MSB 7 bit resolution    */
} DACCTL_BIT_DIVSRCLO;

#define DACCTL_ALL_DIVSRCLO_CURRENT_DRV     ((0x0UL) << DACCTL_ALL_DIVSRCLO_Pos)
#define DACCTL_ALL_DIVSRCLO_VDDX_DRV        ((0x1UL) << DACCTL_ALL_DIVSRCLO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            DACCTL          DIVSRCHI
 *  @access     COMP->DACCTL.bit.DIVSRCHI
 *  @brief      Select DAC High DAC Driving Mode
 */
#define DACCTL_ALL_DIVSRCHI_Pos (5)
#define DACCTL_ALL_DIVSRCHI_Msk (0x1UL << DACCTL_ALL_DIVSRCHI_Pos)

typedef enum
{
    DACCTL_BIT_DIVSRCHI_CURRENT_DRV     = 0,  /*!< Enable current driving mode as High DAC output, 10 bit resolution    */
    DACCTL_BIT_DIVSRCHI_VDDX_DRV        = 1,  /*!< Enable VDDX divider mode as High DAC output, MSB 7 bit resolution    */
} DACCTL_BIT_DIVSRCHI;

#define DACCTL_ALL_DIVSRCHI_CURRENT_DRV     ((0x0UL) << DACCTL_ALL_DIVSRCHI_Pos)
#define DACCTL_ALL_DIVSRCHI_VDDX_DRV        ((0x1UL) << DACCTL_ALL_DIVSRCHI_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            DACCTL          ENLO
 *  @access     COMP->DACCTL.bit.ENLO
 *  @brief      Enable 10-bit DAC to send LOW ref for comparator
 */
#define DACCTL_ALL_ENLO_Pos (6)
#define DACCTL_ALL_ENLO_Msk (0x1UL << DACCTL_ALL_ENLO_Pos)

typedef enum
{
    DACCTL_BIT_ENLO_DISABLE     = 0,  /*!< Disable DAC Low   */
    DACCTL_BIT_ENLO_ENABLE      = 1,  /*!< Enable DAC Low    */
} DACCTL_BIT_ENLO;

#define DACCTL_ALL_ENLO_DISABLE     ((0x0UL) << DACCTL_ALL_ENLO_Pos)
#define DACCTL_ALL_ENLO_ENABLE      ((0x1UL) << DACCTL_ALL_ENLO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   COMP            DACCTL          ENHI
 *  @access     COMP->DACCTL.bit.ENHI
 *  @brief      Enable 10-bit DAC to send HIGH ref for comparator
 */
#define DACCTL_ALL_ENHI_Pos (7)
#define DACCTL_ALL_ENHI_Msk (0x1UL << DACCTL_ALL_ENHI_Pos)

typedef enum
{
    DACCTL_BIT_ENHI_DISABLE     = 0,  /*!< Disable DAC High   */
    DACCTL_BIT_ENHI_ENABLE      = 1,  /*!< Enable DAC High    */
} DACCTL_BIT_ENHI;

#define DACCTL_ALL_ENHI_DISABLE     ((0x0UL) << DACCTL_ALL_ENHI_Pos)
#define DACCTL_ALL_ENHI_ENABLE      ((0x1UL) << DACCTL_ALL_ENHI_Pos)





/********************************************************************************
*
* Module Name     ADC
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL0         VREFSEL
 *  @access     ADC->ADCCTL0.bit.VREFSEL
 *  @brief      Select reference source for reference buffer
 */
#define ADCCTL0_ALL_VREFSEL_Pos (3)
#define ADCCTL0_ALL_VREFSEL_Msk (0x1UL << ADCCTL0_ALL_VREFSEL_Pos)

typedef enum
{
    ADCCTL0_BIT_VREFSEL_INTERNAL_REF     = 0,  /*!< Select internal reference source    */
    ADCCTL0_BIT_VREFSEL_EXTERNAL_REF     = 1,  /*!< Select external reference source    */
} ADCCTL0_BIT_VREFSEL;

#define ADCCTL0_ALL_VREFSEL_INTERNAL_REF     ((0x0UL) << ADCCTL0_ALL_VREFSEL_Pos)
#define ADCCTL0_ALL_VREFSEL_EXTERNAL_REF     ((0x1UL) << ADCCTL0_ALL_VREFSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL0         VREFEN
 *  @access     ADC->ADCCTL0.bit.VREFEN
 *  @brief      ADC reference buffer enable
 */
#define ADCCTL0_ALL_VREFEN_Pos (5)
#define ADCCTL0_ALL_VREFEN_Msk (0x1UL << ADCCTL0_ALL_VREFEN_Pos)

typedef enum
{
    ADCCTL0_BIT_VREFEN_DISABLE_REF_BUFF     = 0,  /*!< Disable reference buffer    */
    ADCCTL0_BIT_VREFEN_ENABLE_REF_BUFF      = 1,  /*!< Enable reference buffer     */
} ADCCTL0_BIT_VREFEN;

#define ADCCTL0_ALL_VREFEN_DISABLE_REF_BUFF     ((0x0UL) << ADCCTL0_ALL_VREFEN_Pos)
#define ADCCTL0_ALL_VREFEN_ENABLE_REF_BUFF      ((0x1UL) << ADCCTL0_ALL_VREFEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL0         EN
 *  @access     ADC->ADCCTL0.bit.EN
 *  @brief      ADC enable
 */
#define ADCCTL0_ALL_EN_Pos (14)
#define ADCCTL0_ALL_EN_Msk (0x1UL << ADCCTL0_ALL_EN_Pos)

typedef enum
{
    ADCCTL0_BIT_EN_DISABLE_ADC     = 0,  /*!< Disable ADC    */
    ADCCTL0_BIT_EN_ENABLE_ADC      = 1,  /*!< Enable ADC     */
} ADCCTL0_BIT_EN;

#define ADCCTL0_ALL_EN_DISABLE_ADC     ((0x0UL) << ADCCTL0_ALL_EN_Pos)
#define ADCCTL0_ALL_EN_ENABLE_ADC      ((0x1UL) << ADCCTL0_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL0         RST
 *  @access     ADC->ADCCTL0.bit.RST
 *  @brief      ADC registers Reset
 */
#define ADCCTL0_ALL_RST_Pos (15)
#define ADCCTL0_ALL_RST_Msk (0x1UL << ADCCTL0_ALL_RST_Pos)

typedef enum
{
    ADCCTL0_BIT_RST_NO_EFFECT     = 0,  /*!< Nothing change                         */
    ADCCTL0_BIT_RST_RESET_ADC     = 1,  /*!< Reset ADC registers to Default value   */
} ADCCTL0_BIT_RST;

#define ADCCTL0_ALL_RST_NO_EFFECT     ((0x0UL) << ADCCTL0_ALL_RST_Pos)
#define ADCCTL0_ALL_RST_RESET_ADC     ((0x1UL) << ADCCTL0_ALL_RST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         CLKSYNCEN
 *  @access     ADC->ADCCTL1.bit.CLKSYNCEN
 *  @brief      Analog clk to resynchronize mcu control signal
 */
#define ADCCTL1_ALL_CLKSYNCEN_Pos (0)
#define ADCCTL1_ALL_CLKSYNCEN_Msk (0x1UL << ADCCTL1_ALL_CLKSYNCEN_Pos)

typedef enum
{
    ADCCTL1_BIT_CLKSYNCEN_DISABLE     = 0,  /*!< Disable this function    */
    ADCCTL1_BIT_CLKSYNCEN_ENABLE      = 1,  /*!< Enable this function     */
} ADCCTL1_BIT_CLKSYNCEN;

#define ADCCTL1_ALL_CLKSYNCEN_DISABLE     ((0x0UL) << ADCCTL1_ALL_CLKSYNCEN_Pos)
#define ADCCTL1_ALL_CLKSYNCEN_ENABLE      ((0x1UL) << ADCCTL1_ALL_CLKSYNCEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         CLKDIV
 *  @access     ADC->ADCCTL1.bit.CLKDIV
 *  @brief      Select division for clk source in ADC front-end
 */
#define ADCCTL1_ALL_CLKDIV_Pos (1)
#define ADCCTL1_ALL_CLKDIV_Msk (0x7UL << ADCCTL1_ALL_CLKDIV_Pos)

typedef enum
{
    ADCCTL1_BIT_CLKDIV_1       = 0,  /*!< Fclk        */
    ADCCTL1_BIT_CLKDIV_2       = 1,  /*!< Fclk/2      */
    ADCCTL1_BIT_CLKDIV_4       = 2,  /*!< Fclk/4      */
    ADCCTL1_BIT_CLKDIV_8       = 3,  /*!< Fclk/8      */
    ADCCTL1_BIT_CLKDIV_16      = 4,  /*!< Fclk/16     */
    ADCCTL1_BIT_CLKDIV_32      = 5,  /*!< Fclk/32     */
    ADCCTL1_BIT_CLKDIV_64      = 6,  /*!< Fclk/64     */
    ADCCTL1_BIT_CLKDIV_128     = 7,  /*!< Fclk/128    */
} ADCCTL1_BIT_CLKDIV;

#define ADCCTL1_ALL_CLKDIV_1       ((0x0UL) << ADCCTL1_ALL_CLKDIV_Pos)
#define ADCCTL1_ALL_CLKDIV_2       ((0x1UL) << ADCCTL1_ALL_CLKDIV_Pos)
#define ADCCTL1_ALL_CLKDIV_4       ((0x2UL) << ADCCTL1_ALL_CLKDIV_Pos)
#define ADCCTL1_ALL_CLKDIV_8       ((0x3UL) << ADCCTL1_ALL_CLKDIV_Pos)
#define ADCCTL1_ALL_CLKDIV_16      ((0x4UL) << ADCCTL1_ALL_CLKDIV_Pos)
#define ADCCTL1_ALL_CLKDIV_32      ((0x5UL) << ADCCTL1_ALL_CLKDIV_Pos)
#define ADCCTL1_ALL_CLKDIV_64      ((0x6UL) << ADCCTL1_ALL_CLKDIV_Pos)
#define ADCCTL1_ALL_CLKDIV_128     ((0x7UL) << ADCCTL1_ALL_CLKDIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         CLKSEL
 *  @access     ADC->ADCCTL1.bit.CLKSEL
 *  @brief      Select clock source in ADC front-end
 */
#define ADCCTL1_ALL_CLKSEL_Pos (4)
#define ADCCTL1_ALL_CLKSEL_Msk (0x3UL << ADCCTL1_ALL_CLKSEL_Pos)

typedef enum
{
    ADCCTL1_BIT_CLKSEL_RCO        = 0,  /*!< RCO clock   */
    ADCCTL1_BIT_CLKSEL_XO         = 1,  /*!< XO clock    */
    ADCCTL1_BIT_CLKSEL_PLL        = 2,  /*!< PLL clock   */
    ADCCTL1_BIT_CLKSEL_ADCCLK     = 3,  /*!< ADC clock   */
} ADCCTL1_BIT_CLKSEL;

#define ADCCTL1_ALL_CLKSEL_RCO        ((0x0UL) << ADCCTL1_ALL_CLKSEL_Pos)
#define ADCCTL1_ALL_CLKSEL_XO         ((0x1UL) << ADCCTL1_ALL_CLKSEL_Pos)
#define ADCCTL1_ALL_CLKSEL_PLL        ((0x2UL) << ADCCTL1_ALL_CLKSEL_Pos)
#define ADCCTL1_ALL_CLKSEL_ADCCLK     ((0x3UL) << ADCCTL1_ALL_CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         DACSETTLECTL
 *  @access     ADC->ADCCTL1.bit.DACSETTLECTL
 *  @brief      DAC settling control for ADC conversion time.
 */
#define ADCCTL1_ALL_DACSETTLECTL_Pos (9)
#define ADCCTL1_ALL_DACSETTLECTL_Msk (0x3UL << ADCCTL1_ALL_DACSETTLECTL_Pos)

typedef enum
{
    ADCCTL1_BIT_DACSETTLECTL_0     = 0,  /*!< 125ns    */
    ADCCTL1_BIT_DACSETTLECTL_1     = 1,  /*!< 150ns    */
    ADCCTL1_BIT_DACSETTLECTL_2     = 2,  /*!< 175ns    */
    ADCCTL1_BIT_DACSETTLECTL_3     = 3,  /*!< 200ns    */
} ADCCTL1_BIT_DACSETTLECTL;

#define ADCCTL1_ALL_DACSETTLECTL_0     ((0x0UL) << ADCCTL1_ALL_DACSETTLECTL_Pos)
#define ADCCTL1_ALL_DACSETTLECTL_1     ((0x1UL) << ADCCTL1_ALL_DACSETTLECTL_Pos)
#define ADCCTL1_ALL_DACSETTLECTL_2     ((0x2UL) << ADCCTL1_ALL_DACSETTLECTL_Pos)
#define ADCCTL1_ALL_DACSETTLECTL_3     ((0x3UL) << ADCCTL1_ALL_DACSETTLECTL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SPEEDUP
 *  @access     ADC->ADCCTL1.bit.SPEEDUP
 *  @brief      ADC Speed-up mode control
 */
#define ADCCTL1_ALL_SPEEDUP_Pos (11)
#define ADCCTL1_ALL_SPEEDUP_Msk (0x1UL << ADCCTL1_ALL_SPEEDUP_Pos)

typedef enum
{
    ADCCTL1_BIT_SPEEDUP_DISABLE     = 0,  /*!< Disable speed-up mode    */
    ADCCTL1_BIT_SPEEDUP_ENABLE      = 1,  /*!< Enable speed-up mode     */
} ADCCTL1_BIT_SPEEDUP;

#define ADCCTL1_ALL_SPEEDUP_DISABLE     ((0x0UL) << ADCCTL1_ALL_SPEEDUP_Pos)
#define ADCCTL1_ALL_SPEEDUP_ENABLE      ((0x1UL) << ADCCTL1_ALL_SPEEDUP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         DLYSEL
 *  @access     ADC->ADCCTL1.bit.DLYSEL
 *  @brief      Delay adjustment of ADC front-end
 *              DLYSEL[3]: Non-overlap selection 1ns/0.5ns(1/0) from convert to sample
 *              DLYSEL[2]: Delay selection 1ns/0.5ns(1/0) from sample_cm to sample_in
 *              DLYSEL[1]: CDAC Initial selection 1ns/0.5ns(1/0)
 *              DLYSEL[0]: Delay selection 1ns/0.5ns(1/0) from CDAC released to conversion starting
 */
#define ADCCTL1_ALL_DLYSEL_Pos (12)
#define ADCCTL1_ALL_DLYSEL_Msk (0xFUL << ADCCTL1_ALL_DLYSEL_Pos)

#define ADCCTL1_BIT_DLYSEL

#define ADCCTL1_ALL_DLYSEL_(x) ((x) << ADCCTL1_ALL_DLYSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SHANTIELO
 *  @access     ADC->ADCCTL1.bit.SHANTIELO
 *  @brief      Tie-high/low selection for forcing negative input of SHA
 */
#define ADCCTL1_ALL_SHANTIELO_Pos (16)
#define ADCCTL1_ALL_SHANTIELO_Msk (0x1UL << ADCCTL1_ALL_SHANTIELO_Pos)

typedef enum
{
    ADCCTL1_BIT_SHANTIELO_SHA_NEGATIVE_TIE_HIGH     = 0,  /*!< Tie-high of the negative input of SHA   */
    ADCCTL1_BIT_SHANTIELO_SHA_NEGATIVE_TIE_LOW      = 1,  /*!< Tie-low of the negative input of SHA    */
} ADCCTL1_BIT_SHANTIELO;

#define ADCCTL1_ALL_SHANTIELO_SHA_NEGATIVE_TIE_HIGH     ((0x0UL) << ADCCTL1_ALL_SHANTIELO_Pos)
#define ADCCTL1_ALL_SHANTIELO_SHA_NEGATIVE_TIE_LOW      ((0x1UL) << ADCCTL1_ALL_SHANTIELO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SHBNTIELO
 *  @access     ADC->ADCCTL1.bit.SHBNTIELO
 *  @brief      Tie-high/low selection for forcing negative input of SHB
 */
#define ADCCTL1_ALL_SHBNTIELO_Pos (17)
#define ADCCTL1_ALL_SHBNTIELO_Msk (0x1UL << ADCCTL1_ALL_SHBNTIELO_Pos)

typedef enum
{
    ADCCTL1_BIT_SHBNTIELO_SHB_NEGATIVE_TIE_HIGH     = 0,  /*!< Tie-high of the negative input of SHB   */
    ADCCTL1_BIT_SHBNTIELO_SHB_NEGATIVE_TIE_LOW      = 1,  /*!< Tie-low of the negative input of SHB    */
} ADCCTL1_BIT_SHBNTIELO;

#define ADCCTL1_ALL_SHBNTIELO_SHB_NEGATIVE_TIE_HIGH     ((0x0UL) << ADCCTL1_ALL_SHBNTIELO_Pos)
#define ADCCTL1_ALL_SHBNTIELO_SHB_NEGATIVE_TIE_LOW      ((0x1UL) << ADCCTL1_ALL_SHBNTIELO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SHAPTIELO
 *  @access     ADC->ADCCTL1.bit.SHAPTIELO
 *  @brief      Tie-high/low selection for forcing positive input of SHA
 */
#define ADCCTL1_ALL_SHAPTIELO_Pos (18)
#define ADCCTL1_ALL_SHAPTIELO_Msk (0x1UL << ADCCTL1_ALL_SHAPTIELO_Pos)

typedef enum
{
    ADCCTL1_BIT_SHAPTIELO_SHA_POSITIVE_TIE_HIGH     = 0,  /*!< Tie-high of the positive input of SHA   */
    ADCCTL1_BIT_SHAPTIELO_SHA_POSITIVE_TIE_LOW      = 1,  /*!< Tie-low of the positive input of SHA    */
} ADCCTL1_BIT_SHAPTIELO;

#define ADCCTL1_ALL_SHAPTIELO_SHA_POSITIVE_TIE_HIGH     ((0x0UL) << ADCCTL1_ALL_SHAPTIELO_Pos)
#define ADCCTL1_ALL_SHAPTIELO_SHA_POSITIVE_TIE_LOW      ((0x1UL) << ADCCTL1_ALL_SHAPTIELO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SHBPTIELO
 *  @access     ADC->ADCCTL1.bit.SHBPTIELO
 *  @brief      Tie-high/low selection for forcing positive input of SHB
 */
#define ADCCTL1_ALL_SHBPTIELO_Pos (19)
#define ADCCTL1_ALL_SHBPTIELO_Msk (0x1UL << ADCCTL1_ALL_SHBPTIELO_Pos)

typedef enum
{
    ADCCTL1_BIT_SHBPTIELO_SHB_POSITIVE_TIE_HIGH     = 0,  /*!< Tie-high of the positive input of SHB   */
    ADCCTL1_BIT_SHBPTIELO_SHB_POSITIVE_TIE_LOW      = 1,  /*!< Tie-low of the positive input of SHB    */
} ADCCTL1_BIT_SHBPTIELO;

#define ADCCTL1_ALL_SHBPTIELO_SHB_POSITIVE_TIE_HIGH     ((0x0UL) << ADCCTL1_ALL_SHBPTIELO_Pos)
#define ADCCTL1_ALL_SHBPTIELO_SHB_POSITIVE_TIE_LOW      ((0x1UL) << ADCCTL1_ALL_SHBPTIELO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SHANTIEEN
 *  @access     ADC->ADCCTL1.bit.SHANTIEEN
 *  @brief      Control bit for forcing negative input of SHA
 */
#define ADCCTL1_ALL_SHANTIEEN_Pos (20)
#define ADCCTL1_ALL_SHANTIEEN_Msk (0x1UL << ADCCTL1_ALL_SHANTIEEN_Pos)

typedef enum
{
    ADCCTL1_BIT_SHANTIEEN_SHA_NEGATIVE_DISABLE     = 0,  /*!< Disable the function of forcing negative input of SHA   */
    ADCCTL1_BIT_SHANTIEEN_SHA_NEGATIVE_ENABLE      = 1,  /*!< Enable the function of forcing negative input of SHA    */
} ADCCTL1_BIT_SHANTIEEN;

#define ADCCTL1_ALL_SHANTIEEN_SHA_NEGATIVE_DISABLE     ((0x0UL) << ADCCTL1_ALL_SHANTIEEN_Pos)
#define ADCCTL1_ALL_SHANTIEEN_SHA_NEGATIVE_ENABLE      ((0x1UL) << ADCCTL1_ALL_SHANTIEEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SHBNTIEEN
 *  @access     ADC->ADCCTL1.bit.SHBNTIEEN
 *  @brief      Control bit for forcing negative input of SHB
 */
#define ADCCTL1_ALL_SHBNTIEEN_Pos (21)
#define ADCCTL1_ALL_SHBNTIEEN_Msk (0x1UL << ADCCTL1_ALL_SHBNTIEEN_Pos)

typedef enum
{
    ADCCTL1_BIT_SHBNTIEEN_SHB_NEGATIVE_DISABLE     = 0,  /*!< Disable the function of forcing negative input of SHB   */
    ADCCTL1_BIT_SHBNTIEEN_SHB_NEGATIVE_ENABLE      = 1,  /*!< Enable the function of forcing negative input of SHB    */
} ADCCTL1_BIT_SHBNTIEEN;

#define ADCCTL1_ALL_SHBNTIEEN_SHB_NEGATIVE_DISABLE     ((0x0UL) << ADCCTL1_ALL_SHBNTIEEN_Pos)
#define ADCCTL1_ALL_SHBNTIEEN_SHB_NEGATIVE_ENABLE      ((0x1UL) << ADCCTL1_ALL_SHBNTIEEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SHAPTIEEN
 *  @access     ADC->ADCCTL1.bit.SHAPTIEEN
 *  @brief      Control bit for forcing positive input of SHA
 */
#define ADCCTL1_ALL_SHAPTIEEN_Pos (22)
#define ADCCTL1_ALL_SHAPTIEEN_Msk (0x1UL << ADCCTL1_ALL_SHAPTIEEN_Pos)

typedef enum
{
    ADCCTL1_BIT_SHAPTIEEN_SHA_POSITIVE_DISABLE     = 0,  /*!< Disable the function of forcing positive input of SHA   */
    ADCCTL1_BIT_SHAPTIEEN_SHA_POSITIVE_ENABLE      = 1,  /*!< Enable the function of forcing positive input of SHA    */
} ADCCTL1_BIT_SHAPTIEEN;

#define ADCCTL1_ALL_SHAPTIEEN_SHA_POSITIVE_DISABLE     ((0x0UL) << ADCCTL1_ALL_SHAPTIEEN_Pos)
#define ADCCTL1_ALL_SHAPTIEEN_SHA_POSITIVE_ENABLE      ((0x1UL) << ADCCTL1_ALL_SHAPTIEEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         SHBPTIEEN
 *  @access     ADC->ADCCTL1.bit.SHBPTIEEN
 *  @brief      Control bit for forcing positive input of SHB
 */
#define ADCCTL1_ALL_SHBPTIEEN_Pos (23)
#define ADCCTL1_ALL_SHBPTIEEN_Msk (0x1UL << ADCCTL1_ALL_SHBPTIEEN_Pos)

typedef enum
{
    ADCCTL1_BIT_SHBPTIEEN_SHB_POSITIVE_DISABLE     = 0,  /*!< Disable the function of forcing positive input of SHB   */
    ADCCTL1_BIT_SHBPTIEEN_SHB_POSITIVE_ENABLE      = 1,  /*!< Enable the function of forcing positive input of SHB    */
} ADCCTL1_BIT_SHBPTIEEN;

#define ADCCTL1_ALL_SHBPTIEEN_SHB_POSITIVE_DISABLE     ((0x0UL) << ADCCTL1_ALL_SHBPTIEEN_Pos)
#define ADCCTL1_ALL_SHBPTIEEN_SHB_POSITIVE_ENABLE      ((0x1UL) << ADCCTL1_ALL_SHBPTIEEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCCTL1         COMPPREAMPCTL
 *  @access     ADC->ADCCTL1.bit.COMPPREAMPCTL
 *  @brief      Comparator pre-amplifier time control
 */
#define ADCCTL1_ALL_COMPPREAMPCTL_Pos (24)
#define ADCCTL1_ALL_COMPPREAMPCTL_Msk (0x7UL << ADCCTL1_ALL_COMPPREAMPCTL_Pos)

typedef enum
{
    ADCCTL1_BIT_COMPPREAMPCTL_1dot23_NS     = 0,  /*!< 1.23ns    */
    ADCCTL1_BIT_COMPPREAMPCTL_1dot75_NS     = 1,  /*!< 1.75ns    */
    ADCCTL1_BIT_COMPPREAMPCTL_2dot20_NS     = 2,  /*!< 2.20ns    */
    ADCCTL1_BIT_COMPPREAMPCTL_2dot69_NS     = 3,  /*!< 2.69ns    */
    ADCCTL1_BIT_COMPPREAMPCTL_2dot99_NS     = 4,  /*!< 2.99ns    */
    ADCCTL1_BIT_COMPPREAMPCTL_3dot47_NS     = 5,  /*!< 3.47ns    */
    ADCCTL1_BIT_COMPPREAMPCTL_3dot91_NS     = 6,  /*!< 3.91ns    */
    ADCCTL1_BIT_COMPPREAMPCTL_4dot40_NS     = 7,  /*!< 4.40ns    */
} ADCCTL1_BIT_COMPPREAMPCTL;

#define ADCCTL1_ALL_COMPPREAMPCTL_1dot23_NS     ((0x0UL) << ADCCTL1_ALL_COMPPREAMPCTL_Pos)
#define ADCCTL1_ALL_COMPPREAMPCTL_1dot75_NS     ((0x1UL) << ADCCTL1_ALL_COMPPREAMPCTL_Pos)
#define ADCCTL1_ALL_COMPPREAMPCTL_2dot20_NS     ((0x2UL) << ADCCTL1_ALL_COMPPREAMPCTL_Pos)
#define ADCCTL1_ALL_COMPPREAMPCTL_2dot69_NS     ((0x3UL) << ADCCTL1_ALL_COMPPREAMPCTL_Pos)
#define ADCCTL1_ALL_COMPPREAMPCTL_2dot99_NS     ((0x4UL) << ADCCTL1_ALL_COMPPREAMPCTL_Pos)
#define ADCCTL1_ALL_COMPPREAMPCTL_3dot47_NS     ((0x5UL) << ADCCTL1_ALL_COMPPREAMPCTL_Pos)
#define ADCCTL1_ALL_COMPPREAMPCTL_3dot91_NS     ((0x6UL) << ADCCTL1_ALL_COMPPREAMPCTL_Pos)
#define ADCCTL1_ALL_COMPPREAMPCTL_4dot40_NS     ((0x7UL) << ADCCTL1_ALL_COMPPREAMPCTL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT0
 *  @access     ADC->ADCIF.bit.INT0
 *  @brief      Flag signal indicates if ADC Interrupt 0 is generated
 */
#define ADCIF_ALL_INT0_Pos (0)
#define ADCIF_ALL_INT0_Msk (0x1UL << ADCIF_ALL_INT0_Pos)

typedef enum
{
    ADCIF_BIT_INT0_NOT_OCCUR     = 0,  /*!< ADC Interrupt 0 isn't generated    */
    ADCIF_BIT_INT0_OCCUR         = 1,  /*!< ADC Interrupt 0 is generated       */
} ADCIF_BIT_INT0;

#define ADCIF_ALL_INT0_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT0_Pos)
#define ADCIF_ALL_INT0_OCCUR         ((0x1UL) << ADCIF_ALL_INT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT1
 *  @access     ADC->ADCIF.bit.INT1
 *  @brief      Flag signal indicates if ADC Interrupt 1 is generated
 */
#define ADCIF_ALL_INT1_Pos (1)
#define ADCIF_ALL_INT1_Msk (0x1UL << ADCIF_ALL_INT1_Pos)

typedef enum
{
    ADCIF_BIT_INT1_NOT_OCCUR     = 0,  /*!< ADC Interrupt 1 isn't generated    */
    ADCIF_BIT_INT1_OCCUR         = 1,  /*!< ADC Interrupt 1 is generated       */
} ADCIF_BIT_INT1;

#define ADCIF_ALL_INT1_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT1_Pos)
#define ADCIF_ALL_INT1_OCCUR         ((0x1UL) << ADCIF_ALL_INT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT2
 *  @access     ADC->ADCIF.bit.INT2
 *  @brief      Flag signal indicates if ADC Interrupt 2 is generated
 */
#define ADCIF_ALL_INT2_Pos (2)
#define ADCIF_ALL_INT2_Msk (0x1UL << ADCIF_ALL_INT2_Pos)

typedef enum
{
    ADCIF_BIT_INT2_NOT_OCCUR     = 0,  /*!< ADC Interrupt 2 isn't generated    */
    ADCIF_BIT_INT2_OCCUR         = 1,  /*!< ADC Interrupt 2 is generated       */
} ADCIF_BIT_INT2;

#define ADCIF_ALL_INT2_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT2_Pos)
#define ADCIF_ALL_INT2_OCCUR         ((0x1UL) << ADCIF_ALL_INT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT3
 *  @access     ADC->ADCIF.bit.INT3
 *  @brief      Flag signal indicates if ADC Interrupt 3 is generated
 */
#define ADCIF_ALL_INT3_Pos (3)
#define ADCIF_ALL_INT3_Msk (0x1UL << ADCIF_ALL_INT3_Pos)

typedef enum
{
    ADCIF_BIT_INT3_NOT_OCCUR     = 0,  /*!< ADC Interrupt 3 isn't generated    */
    ADCIF_BIT_INT3_OCCUR         = 1,  /*!< ADC Interrupt 3 is generated       */
} ADCIF_BIT_INT3;

#define ADCIF_ALL_INT3_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT3_Pos)
#define ADCIF_ALL_INT3_OCCUR         ((0x1UL) << ADCIF_ALL_INT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT4
 *  @access     ADC->ADCIF.bit.INT4
 *  @brief      Flag signal indicates if ADC Interrupt 4 is generated
 */
#define ADCIF_ALL_INT4_Pos (4)
#define ADCIF_ALL_INT4_Msk (0x1UL << ADCIF_ALL_INT4_Pos)

typedef enum
{
    ADCIF_BIT_INT4_NOT_OCCUR     = 0,  /*!< ADC Interrupt 4 isn't generated    */
    ADCIF_BIT_INT4_OCCUR         = 1,  /*!< ADC Interrupt 4 is generated       */
} ADCIF_BIT_INT4;

#define ADCIF_ALL_INT4_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT4_Pos)
#define ADCIF_ALL_INT4_OCCUR         ((0x1UL) << ADCIF_ALL_INT4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT5
 *  @access     ADC->ADCIF.bit.INT5
 *  @brief      Flag signal indicates if ADC Interrupt 5 is generated
 */
#define ADCIF_ALL_INT5_Pos (5)
#define ADCIF_ALL_INT5_Msk (0x1UL << ADCIF_ALL_INT5_Pos)

typedef enum
{
    ADCIF_BIT_INT5_NOT_OCCUR     = 0,  /*!< ADC Interrupt 5 isn't generated    */
    ADCIF_BIT_INT5_OCCUR         = 1,  /*!< ADC Interrupt 5 is generated       */
} ADCIF_BIT_INT5;

#define ADCIF_ALL_INT5_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT5_Pos)
#define ADCIF_ALL_INT5_OCCUR         ((0x1UL) << ADCIF_ALL_INT5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT6
 *  @access     ADC->ADCIF.bit.INT6
 *  @brief      Flag signal indicates if ADC Interrupt 6 is generated
 */
#define ADCIF_ALL_INT6_Pos (6)
#define ADCIF_ALL_INT6_Msk (0x1UL << ADCIF_ALL_INT6_Pos)

typedef enum
{
    ADCIF_BIT_INT6_NOT_OCCUR     = 0,  /*!< ADC Interrupt 6 isn't generated    */
    ADCIF_BIT_INT6_OCCUR         = 1,  /*!< ADC Interrupt 6 is generated       */
} ADCIF_BIT_INT6;

#define ADCIF_ALL_INT6_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT6_Pos)
#define ADCIF_ALL_INT6_OCCUR         ((0x1UL) << ADCIF_ALL_INT6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT7
 *  @access     ADC->ADCIF.bit.INT7
 *  @brief      Flag signal indicates if ADC Interrupt 7 is generated
 */
#define ADCIF_ALL_INT7_Pos (7)
#define ADCIF_ALL_INT7_Msk (0x1UL << ADCIF_ALL_INT7_Pos)

typedef enum
{
    ADCIF_BIT_INT7_NOT_OCCUR     = 0,  /*!< ADC Interrupt 7 isn't generated    */
    ADCIF_BIT_INT7_OCCUR         = 1,  /*!< ADC Interrupt 7 is generated       */
} ADCIF_BIT_INT7;

#define ADCIF_ALL_INT7_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT7_Pos)
#define ADCIF_ALL_INT7_OCCUR         ((0x1UL) << ADCIF_ALL_INT7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT8
 *  @access     ADC->ADCIF.bit.INT8
 *  @brief      Flag signal indicates if ADC Interrupt 8 is generated
 */
#define ADCIF_ALL_INT8_Pos (8)
#define ADCIF_ALL_INT8_Msk (0x1UL << ADCIF_ALL_INT8_Pos)

typedef enum
{
    ADCIF_BIT_INT8_NOT_OCCUR     = 0,  /*!< ADC Interrupt 8 isn't generated    */
    ADCIF_BIT_INT8_OCCUR         = 1,  /*!< ADC Interrupt 8 is generated       */
} ADCIF_BIT_INT8;

#define ADCIF_ALL_INT8_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT8_Pos)
#define ADCIF_ALL_INT8_OCCUR         ((0x1UL) << ADCIF_ALL_INT8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT9
 *  @access     ADC->ADCIF.bit.INT9
 *  @brief      Flag signal indicates if ADC Interrupt 9 is generated
 */
#define ADCIF_ALL_INT9_Pos (9)
#define ADCIF_ALL_INT9_Msk (0x1UL << ADCIF_ALL_INT9_Pos)

typedef enum
{
    ADCIF_BIT_INT9_NOT_OCCUR     = 0,  /*!< ADC Interrupt 9 isn't generated    */
    ADCIF_BIT_INT9_OCCUR         = 1,  /*!< ADC Interrupt 9 is generated       */
} ADCIF_BIT_INT9;

#define ADCIF_ALL_INT9_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT9_Pos)
#define ADCIF_ALL_INT9_OCCUR         ((0x1UL) << ADCIF_ALL_INT9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT10
 *  @access     ADC->ADCIF.bit.INT10
 *  @brief      Flag signal indicates if ADC Interrupt 10 is generated
 */
#define ADCIF_ALL_INT10_Pos (10)
#define ADCIF_ALL_INT10_Msk (0x1UL << ADCIF_ALL_INT10_Pos)

typedef enum
{
    ADCIF_BIT_INT10_NOT_OCCUR     = 0,  /*!< ADC Interrupt 10 isn't generated    */
    ADCIF_BIT_INT10_OCCUR         = 1,  /*!< ADC Interrupt 10 is generated       */
} ADCIF_BIT_INT10;

#define ADCIF_ALL_INT10_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT10_Pos)
#define ADCIF_ALL_INT10_OCCUR         ((0x1UL) << ADCIF_ALL_INT10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT11
 *  @access     ADC->ADCIF.bit.INT11
 *  @brief      Flag signal indicates if ADC Interrupt 11 is generated
 */
#define ADCIF_ALL_INT11_Pos (11)
#define ADCIF_ALL_INT11_Msk (0x1UL << ADCIF_ALL_INT11_Pos)

typedef enum
{
    ADCIF_BIT_INT11_NOT_OCCUR     = 0,  /*!< ADC Interrupt 11 isn't generated    */
    ADCIF_BIT_INT11_OCCUR         = 1,  /*!< ADC Interrupt 11 is generated       */
} ADCIF_BIT_INT11;

#define ADCIF_ALL_INT11_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT11_Pos)
#define ADCIF_ALL_INT11_OCCUR         ((0x1UL) << ADCIF_ALL_INT11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT12
 *  @access     ADC->ADCIF.bit.INT12
 *  @brief      Flag signal indicates if ADC Interrupt 12 is generated
 */
#define ADCIF_ALL_INT12_Pos (12)
#define ADCIF_ALL_INT12_Msk (0x1UL << ADCIF_ALL_INT12_Pos)

typedef enum
{
    ADCIF_BIT_INT12_NOT_OCCUR     = 0,  /*!< ADC Interrupt 12 isn't generated    */
    ADCIF_BIT_INT12_OCCUR         = 1,  /*!< ADC Interrupt 12 is generated       */
} ADCIF_BIT_INT12;

#define ADCIF_ALL_INT12_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT12_Pos)
#define ADCIF_ALL_INT12_OCCUR         ((0x1UL) << ADCIF_ALL_INT12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT13
 *  @access     ADC->ADCIF.bit.INT13
 *  @brief      Flag signal indicates if ADC Interrupt 13 is generated
 */
#define ADCIF_ALL_INT13_Pos (13)
#define ADCIF_ALL_INT13_Msk (0x1UL << ADCIF_ALL_INT13_Pos)

typedef enum
{
    ADCIF_BIT_INT13_NOT_OCCUR     = 0,  /*!< ADC Interrupt 13 isn't generated    */
    ADCIF_BIT_INT13_OCCUR         = 1,  /*!< ADC Interrupt 13 is generated       */
} ADCIF_BIT_INT13;

#define ADCIF_ALL_INT13_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT13_Pos)
#define ADCIF_ALL_INT13_OCCUR         ((0x1UL) << ADCIF_ALL_INT13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT14
 *  @access     ADC->ADCIF.bit.INT14
 *  @brief      Flag signal indicates if ADC Interrupt 14 is generated
 */
#define ADCIF_ALL_INT14_Pos (14)
#define ADCIF_ALL_INT14_Msk (0x1UL << ADCIF_ALL_INT14_Pos)

typedef enum
{
    ADCIF_BIT_INT14_NOT_OCCUR     = 0,  /*!< ADC Interrupt 14 isn't generated    */
    ADCIF_BIT_INT14_OCCUR         = 1,  /*!< ADC Interrupt 14 is generated       */
} ADCIF_BIT_INT14;

#define ADCIF_ALL_INT14_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT14_Pos)
#define ADCIF_ALL_INT14_OCCUR         ((0x1UL) << ADCIF_ALL_INT14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIF           INT15
 *  @access     ADC->ADCIF.bit.INT15
 *  @brief      Flag signal indicates if ADC Interrupt 15 is generated
 */
#define ADCIF_ALL_INT15_Pos (15)
#define ADCIF_ALL_INT15_Msk (0x1UL << ADCIF_ALL_INT15_Pos)

typedef enum
{
    ADCIF_BIT_INT15_NOT_OCCUR     = 0,  /*!< ADC Interrupt 15 isn't generated    */
    ADCIF_BIT_INT15_OCCUR         = 1,  /*!< ADC Interrupt 15 is generated       */
} ADCIF_BIT_INT15;

#define ADCIF_ALL_INT15_NOT_OCCUR     ((0x0UL) << ADCIF_ALL_INT15_Pos)
#define ADCIF_ALL_INT15_OCCUR         ((0x1UL) << ADCIF_ALL_INT15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT0
 *  @access     ADC->ADCIC.bit.INT0
 *  @brief      ADC Interrupt 0 flag clear bit
 */
#define ADCIC_ALL_INT0_Pos (0)
#define ADCIC_ALL_INT0_Msk (0x1UL << ADCIC_ALL_INT0_Pos)

typedef enum
{
    ADCIC_BIT_INT0_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT0_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 0 flag   */
} ADCIC_BIT_INT0;

#define ADCIC_ALL_INT0_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT0_Pos)
#define ADCIC_ALL_INT0_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT1
 *  @access     ADC->ADCIC.bit.INT1
 *  @brief      ADC Interrupt 1 flag clear bit
 */
#define ADCIC_ALL_INT1_Pos (1)
#define ADCIC_ALL_INT1_Msk (0x1UL << ADCIC_ALL_INT1_Pos)

typedef enum
{
    ADCIC_BIT_INT1_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT1_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 1 flag   */
} ADCIC_BIT_INT1;

#define ADCIC_ALL_INT1_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT1_Pos)
#define ADCIC_ALL_INT1_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT2
 *  @access     ADC->ADCIC.bit.INT2
 *  @brief      ADC Interrupt 2 flag clear bit
 */
#define ADCIC_ALL_INT2_Pos (2)
#define ADCIC_ALL_INT2_Msk (0x1UL << ADCIC_ALL_INT2_Pos)

typedef enum
{
    ADCIC_BIT_INT2_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT2_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 2 flag   */
} ADCIC_BIT_INT2;

#define ADCIC_ALL_INT2_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT2_Pos)
#define ADCIC_ALL_INT2_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT3
 *  @access     ADC->ADCIC.bit.INT3
 *  @brief      ADC Interrupt 3 flag clear bit
 */
#define ADCIC_ALL_INT3_Pos (3)
#define ADCIC_ALL_INT3_Msk (0x1UL << ADCIC_ALL_INT3_Pos)

typedef enum
{
    ADCIC_BIT_INT3_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT3_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 3 flag   */
} ADCIC_BIT_INT3;

#define ADCIC_ALL_INT3_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT3_Pos)
#define ADCIC_ALL_INT3_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT4
 *  @access     ADC->ADCIC.bit.INT4
 *  @brief      ADC Interrupt 4 flag clear bit
 */
#define ADCIC_ALL_INT4_Pos (4)
#define ADCIC_ALL_INT4_Msk (0x1UL << ADCIC_ALL_INT4_Pos)

typedef enum
{
    ADCIC_BIT_INT4_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT4_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 4 flag   */
} ADCIC_BIT_INT4;

#define ADCIC_ALL_INT4_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT4_Pos)
#define ADCIC_ALL_INT4_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT5
 *  @access     ADC->ADCIC.bit.INT5
 *  @brief      ADC Interrupt 5 flag clear bit
 */
#define ADCIC_ALL_INT5_Pos (5)
#define ADCIC_ALL_INT5_Msk (0x1UL << ADCIC_ALL_INT5_Pos)

typedef enum
{
    ADCIC_BIT_INT5_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT5_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 5 flag   */
} ADCIC_BIT_INT5;

#define ADCIC_ALL_INT5_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT5_Pos)
#define ADCIC_ALL_INT5_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT6
 *  @access     ADC->ADCIC.bit.INT6
 *  @brief      ADC Interrupt 6 flag clear bit
 */
#define ADCIC_ALL_INT6_Pos (6)
#define ADCIC_ALL_INT6_Msk (0x1UL << ADCIC_ALL_INT6_Pos)

typedef enum
{
    ADCIC_BIT_INT6_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT6_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 6 flag   */
} ADCIC_BIT_INT6;

#define ADCIC_ALL_INT6_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT6_Pos)
#define ADCIC_ALL_INT6_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT7
 *  @access     ADC->ADCIC.bit.INT7
 *  @brief      ADC Interrupt 7 flag clear bit
 */
#define ADCIC_ALL_INT7_Pos (7)
#define ADCIC_ALL_INT7_Msk (0x1UL << ADCIC_ALL_INT7_Pos)

typedef enum
{
    ADCIC_BIT_INT7_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT7_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 7 flag   */
} ADCIC_BIT_INT7;

#define ADCIC_ALL_INT7_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT7_Pos)
#define ADCIC_ALL_INT7_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT8
 *  @access     ADC->ADCIC.bit.INT8
 *  @brief      ADC Interrupt 8 flag clear bit
 */
#define ADCIC_ALL_INT8_Pos (8)
#define ADCIC_ALL_INT8_Msk (0x1UL << ADCIC_ALL_INT8_Pos)

typedef enum
{
    ADCIC_BIT_INT8_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT8_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 8 flag   */
} ADCIC_BIT_INT8;

#define ADCIC_ALL_INT8_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT8_Pos)
#define ADCIC_ALL_INT8_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT9
 *  @access     ADC->ADCIC.bit.INT9
 *  @brief      ADC Interrupt 9 flag clear bit
 */
#define ADCIC_ALL_INT9_Pos (9)
#define ADCIC_ALL_INT9_Msk (0x1UL << ADCIC_ALL_INT9_Pos)

typedef enum
{
    ADCIC_BIT_INT9_NO_EFFECT      = 0,  /*!< No clear                     */
    ADCIC_BIT_INT9_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 9 flag   */
} ADCIC_BIT_INT9;

#define ADCIC_ALL_INT9_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT9_Pos)
#define ADCIC_ALL_INT9_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT10
 *  @access     ADC->ADCIC.bit.INT10
 *  @brief      ADC Interrupt 10 flag clear bit
 */
#define ADCIC_ALL_INT10_Pos (10)
#define ADCIC_ALL_INT10_Msk (0x1UL << ADCIC_ALL_INT10_Pos)

typedef enum
{
    ADCIC_BIT_INT10_NO_EFFECT      = 0,  /*!< No clear                      */
    ADCIC_BIT_INT10_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 10 flag   */
} ADCIC_BIT_INT10;

#define ADCIC_ALL_INT10_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT10_Pos)
#define ADCIC_ALL_INT10_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT11
 *  @access     ADC->ADCIC.bit.INT11
 *  @brief      ADC Interrupt 11 flag clear bit
 */
#define ADCIC_ALL_INT11_Pos (11)
#define ADCIC_ALL_INT11_Msk (0x1UL << ADCIC_ALL_INT11_Pos)

typedef enum
{
    ADCIC_BIT_INT11_NO_EFFECT      = 0,  /*!< No clear                      */
    ADCIC_BIT_INT11_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 11 flag   */
} ADCIC_BIT_INT11;

#define ADCIC_ALL_INT11_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT11_Pos)
#define ADCIC_ALL_INT11_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT12
 *  @access     ADC->ADCIC.bit.INT12
 *  @brief      ADC Interrupt 12 flag clear bit
 */
#define ADCIC_ALL_INT12_Pos (12)
#define ADCIC_ALL_INT12_Msk (0x1UL << ADCIC_ALL_INT12_Pos)

typedef enum
{
    ADCIC_BIT_INT12_NO_EFFECT      = 0,  /*!< No clear                      */
    ADCIC_BIT_INT12_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 12 flag   */
} ADCIC_BIT_INT12;

#define ADCIC_ALL_INT12_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT12_Pos)
#define ADCIC_ALL_INT12_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT13
 *  @access     ADC->ADCIC.bit.INT13
 *  @brief      ADC Interrupt 13 flag clear bit
 */
#define ADCIC_ALL_INT13_Pos (13)
#define ADCIC_ALL_INT13_Msk (0x1UL << ADCIC_ALL_INT13_Pos)

typedef enum
{
    ADCIC_BIT_INT13_NO_EFFECT      = 0,  /*!< No clear                      */
    ADCIC_BIT_INT13_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 13 flag   */
} ADCIC_BIT_INT13;

#define ADCIC_ALL_INT13_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT13_Pos)
#define ADCIC_ALL_INT13_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT14
 *  @access     ADC->ADCIC.bit.INT14
 *  @brief      ADC Interrupt 14 flag clear bit
 */
#define ADCIC_ALL_INT14_Pos (14)
#define ADCIC_ALL_INT14_Msk (0x1UL << ADCIC_ALL_INT14_Pos)

typedef enum
{
    ADCIC_BIT_INT14_NO_EFFECT      = 0,  /*!< No clear                      */
    ADCIC_BIT_INT14_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 14 flag   */
} ADCIC_BIT_INT14;

#define ADCIC_ALL_INT14_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT14_Pos)
#define ADCIC_ALL_INT14_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIC           INT15
 *  @access     ADC->ADCIC.bit.INT15
 *  @brief      ADC Interrupt 15 flag clear bit
 */
#define ADCIC_ALL_INT15_Pos (15)
#define ADCIC_ALL_INT15_Msk (0x1UL << ADCIC_ALL_INT15_Pos)

typedef enum
{
    ADCIC_BIT_INT15_NO_EFFECT      = 0,  /*!< No clear                      */
    ADCIC_BIT_INT15_CLEAR_FLAG     = 1,  /*!< Clear ADC interrupt 15 flag   */
} ADCIC_BIT_INT15;

#define ADCIC_ALL_INT15_NO_EFFECT      ((0x0UL) << ADCIC_ALL_INT15_Pos)
#define ADCIC_ALL_INT15_CLEAR_FLAG     ((0x1UL) << ADCIC_ALL_INT15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT0
 *  @access     ADC->ADCIOVF.bit.INT0
 *  @brief      ADC Interrupt 0 overflow flag
 */
#define ADCIOVF_ALL_INT0_Pos (0)
#define ADCIOVF_ALL_INT0_Msk (0x1UL << ADCIOVF_ALL_INT0_Pos)

typedef enum
{
    ADCIOVF_BIT_INT0_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT0_OCCUR         = 1,  /*!< ADC Interrupt 0 overflow   */
} ADCIOVF_BIT_INT0;

#define ADCIOVF_ALL_INT0_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT0_Pos)
#define ADCIOVF_ALL_INT0_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT1
 *  @access     ADC->ADCIOVF.bit.INT1
 *  @brief      ADC Interrupt 1 overflow flag
 */
#define ADCIOVF_ALL_INT1_Pos (1)
#define ADCIOVF_ALL_INT1_Msk (0x1UL << ADCIOVF_ALL_INT1_Pos)

typedef enum
{
    ADCIOVF_BIT_INT1_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT1_OCCUR         = 1,  /*!< ADC Interrupt 1 overflow   */
} ADCIOVF_BIT_INT1;

#define ADCIOVF_ALL_INT1_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT1_Pos)
#define ADCIOVF_ALL_INT1_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT2
 *  @access     ADC->ADCIOVF.bit.INT2
 *  @brief      ADC Interrupt 2 overflow flag
 */
#define ADCIOVF_ALL_INT2_Pos (2)
#define ADCIOVF_ALL_INT2_Msk (0x1UL << ADCIOVF_ALL_INT2_Pos)

typedef enum
{
    ADCIOVF_BIT_INT2_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT2_OCCUR         = 1,  /*!< ADC Interrupt 2 overflow   */
} ADCIOVF_BIT_INT2;

#define ADCIOVF_ALL_INT2_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT2_Pos)
#define ADCIOVF_ALL_INT2_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT3
 *  @access     ADC->ADCIOVF.bit.INT3
 *  @brief      ADC Interrupt 3 overflow flag
 */
#define ADCIOVF_ALL_INT3_Pos (3)
#define ADCIOVF_ALL_INT3_Msk (0x1UL << ADCIOVF_ALL_INT3_Pos)

typedef enum
{
    ADCIOVF_BIT_INT3_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT3_OCCUR         = 1,  /*!< ADC Interrupt 3 overflow   */
} ADCIOVF_BIT_INT3;

#define ADCIOVF_ALL_INT3_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT3_Pos)
#define ADCIOVF_ALL_INT3_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT4
 *  @access     ADC->ADCIOVF.bit.INT4
 *  @brief      ADC Interrupt 4 overflow flag
 */
#define ADCIOVF_ALL_INT4_Pos (4)
#define ADCIOVF_ALL_INT4_Msk (0x1UL << ADCIOVF_ALL_INT4_Pos)

typedef enum
{
    ADCIOVF_BIT_INT4_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT4_OCCUR         = 1,  /*!< ADC Interrupt 4 overflow   */
} ADCIOVF_BIT_INT4;

#define ADCIOVF_ALL_INT4_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT4_Pos)
#define ADCIOVF_ALL_INT4_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT5
 *  @access     ADC->ADCIOVF.bit.INT5
 *  @brief      ADC Interrupt 5 overflow flag
 */
#define ADCIOVF_ALL_INT5_Pos (5)
#define ADCIOVF_ALL_INT5_Msk (0x1UL << ADCIOVF_ALL_INT5_Pos)

typedef enum
{
    ADCIOVF_BIT_INT5_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT5_OCCUR         = 1,  /*!< ADC Interrupt 5 overflow   */
} ADCIOVF_BIT_INT5;

#define ADCIOVF_ALL_INT5_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT5_Pos)
#define ADCIOVF_ALL_INT5_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT6
 *  @access     ADC->ADCIOVF.bit.INT6
 *  @brief      ADC Interrupt 6 overflow flag
 */
#define ADCIOVF_ALL_INT6_Pos (6)
#define ADCIOVF_ALL_INT6_Msk (0x1UL << ADCIOVF_ALL_INT6_Pos)

typedef enum
{
    ADCIOVF_BIT_INT6_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT6_OCCUR         = 1,  /*!< ADC Interrupt 6 overflow   */
} ADCIOVF_BIT_INT6;

#define ADCIOVF_ALL_INT6_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT6_Pos)
#define ADCIOVF_ALL_INT6_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT7
 *  @access     ADC->ADCIOVF.bit.INT7
 *  @brief      ADC Interrupt 7 overflow flag
 */
#define ADCIOVF_ALL_INT7_Pos (7)
#define ADCIOVF_ALL_INT7_Msk (0x1UL << ADCIOVF_ALL_INT7_Pos)

typedef enum
{
    ADCIOVF_BIT_INT7_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT7_OCCUR         = 1,  /*!< ADC Interrupt 7 overflow   */
} ADCIOVF_BIT_INT7;

#define ADCIOVF_ALL_INT7_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT7_Pos)
#define ADCIOVF_ALL_INT7_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT8
 *  @access     ADC->ADCIOVF.bit.INT8
 *  @brief      ADC Interrupt 8 overflow flag
 */
#define ADCIOVF_ALL_INT8_Pos (8)
#define ADCIOVF_ALL_INT8_Msk (0x1UL << ADCIOVF_ALL_INT8_Pos)

typedef enum
{
    ADCIOVF_BIT_INT8_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT8_OCCUR         = 1,  /*!< ADC Interrupt 8 overflow   */
} ADCIOVF_BIT_INT8;

#define ADCIOVF_ALL_INT8_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT8_Pos)
#define ADCIOVF_ALL_INT8_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT9
 *  @access     ADC->ADCIOVF.bit.INT9
 *  @brief      ADC Interrupt 9 overflow flag
 */
#define ADCIOVF_ALL_INT9_Pos (9)
#define ADCIOVF_ALL_INT9_Msk (0x1UL << ADCIOVF_ALL_INT9_Pos)

typedef enum
{
    ADCIOVF_BIT_INT9_NOT_OCCUR     = 0,  /*!< No overflow                */
    ADCIOVF_BIT_INT9_OCCUR         = 1,  /*!< ADC Interrupt 9 overflow   */
} ADCIOVF_BIT_INT9;

#define ADCIOVF_ALL_INT9_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT9_Pos)
#define ADCIOVF_ALL_INT9_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT10
 *  @access     ADC->ADCIOVF.bit.INT10
 *  @brief      ADC Interrupt 10 overflow flag
 */
#define ADCIOVF_ALL_INT10_Pos (10)
#define ADCIOVF_ALL_INT10_Msk (0x1UL << ADCIOVF_ALL_INT10_Pos)

typedef enum
{
    ADCIOVF_BIT_INT10_NOT_OCCUR     = 0,  /*!< No overflow                 */
    ADCIOVF_BIT_INT10_OCCUR         = 1,  /*!< ADC Interrupt 10 overflow   */
} ADCIOVF_BIT_INT10;

#define ADCIOVF_ALL_INT10_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT10_Pos)
#define ADCIOVF_ALL_INT10_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT11
 *  @access     ADC->ADCIOVF.bit.INT11
 *  @brief      ADC Interrupt 11 overflow flag
 */
#define ADCIOVF_ALL_INT11_Pos (11)
#define ADCIOVF_ALL_INT11_Msk (0x1UL << ADCIOVF_ALL_INT11_Pos)

typedef enum
{
    ADCIOVF_BIT_INT11_NOT_OCCUR     = 0,  /*!< No overflow                 */
    ADCIOVF_BIT_INT11_OCCUR         = 1,  /*!< ADC Interrupt 11 overflow   */
} ADCIOVF_BIT_INT11;

#define ADCIOVF_ALL_INT11_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT11_Pos)
#define ADCIOVF_ALL_INT11_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT12
 *  @access     ADC->ADCIOVF.bit.INT12
 *  @brief      ADC Interrupt 12 overflow flag
 */
#define ADCIOVF_ALL_INT12_Pos (12)
#define ADCIOVF_ALL_INT12_Msk (0x1UL << ADCIOVF_ALL_INT12_Pos)

typedef enum
{
    ADCIOVF_BIT_INT12_NOT_OCCUR     = 0,  /*!< No overflow                 */
    ADCIOVF_BIT_INT12_OCCUR         = 1,  /*!< ADC Interrupt 12 overflow   */
} ADCIOVF_BIT_INT12;

#define ADCIOVF_ALL_INT12_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT12_Pos)
#define ADCIOVF_ALL_INT12_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT13
 *  @access     ADC->ADCIOVF.bit.INT13
 *  @brief      ADC Interrupt 13 overflow flag
 */
#define ADCIOVF_ALL_INT13_Pos (13)
#define ADCIOVF_ALL_INT13_Msk (0x1UL << ADCIOVF_ALL_INT13_Pos)

typedef enum
{
    ADCIOVF_BIT_INT13_NOT_OCCUR     = 0,  /*!< No overflow                 */
    ADCIOVF_BIT_INT13_OCCUR         = 1,  /*!< ADC Interrupt 13 overflow   */
} ADCIOVF_BIT_INT13;

#define ADCIOVF_ALL_INT13_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT13_Pos)
#define ADCIOVF_ALL_INT13_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT14
 *  @access     ADC->ADCIOVF.bit.INT14
 *  @brief      ADC Interrupt 14 overflow flag
 */
#define ADCIOVF_ALL_INT14_Pos (14)
#define ADCIOVF_ALL_INT14_Msk (0x1UL << ADCIOVF_ALL_INT14_Pos)

typedef enum
{
    ADCIOVF_BIT_INT14_NOT_OCCUR     = 0,  /*!< No overflow                 */
    ADCIOVF_BIT_INT14_OCCUR         = 1,  /*!< ADC Interrupt 14 overflow   */
} ADCIOVF_BIT_INT14;

#define ADCIOVF_ALL_INT14_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT14_Pos)
#define ADCIOVF_ALL_INT14_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVF         INT15
 *  @access     ADC->ADCIOVF.bit.INT15
 *  @brief      ADC Interrupt 15 overflow flag
 */
#define ADCIOVF_ALL_INT15_Pos (15)
#define ADCIOVF_ALL_INT15_Msk (0x1UL << ADCIOVF_ALL_INT15_Pos)

typedef enum
{
    ADCIOVF_BIT_INT15_NOT_OCCUR     = 0,  /*!< No overflow                 */
    ADCIOVF_BIT_INT15_OCCUR         = 1,  /*!< ADC Interrupt 15 overflow   */
} ADCIOVF_BIT_INT15;

#define ADCIOVF_ALL_INT15_NOT_OCCUR     ((0x0UL) << ADCIOVF_ALL_INT15_Pos)
#define ADCIOVF_ALL_INT15_OCCUR         ((0x1UL) << ADCIOVF_ALL_INT15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT0
 *  @access     ADC->ADCIOVFC.bit.INT0
 *  @brief      ADC Interrupt 0 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT0_Pos (0)
#define ADCIOVFC_ALL_INT0_Msk (0x1UL << ADCIOVFC_ALL_INT0_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT0_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT0_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 0 overflow flag    */
} ADCIOVFC_BIT_INT0;

#define ADCIOVFC_ALL_INT0_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT0_Pos)
#define ADCIOVFC_ALL_INT0_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT1
 *  @access     ADC->ADCIOVFC.bit.INT1
 *  @brief      ADC Interrupt 1 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT1_Pos (1)
#define ADCIOVFC_ALL_INT1_Msk (0x1UL << ADCIOVFC_ALL_INT1_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT1_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT1_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 1 overflow flag    */
} ADCIOVFC_BIT_INT1;

#define ADCIOVFC_ALL_INT1_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT1_Pos)
#define ADCIOVFC_ALL_INT1_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT2
 *  @access     ADC->ADCIOVFC.bit.INT2
 *  @brief      ADC Interrupt 2 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT2_Pos (2)
#define ADCIOVFC_ALL_INT2_Msk (0x1UL << ADCIOVFC_ALL_INT2_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT2_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT2_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 2 overflow flag    */
} ADCIOVFC_BIT_INT2;

#define ADCIOVFC_ALL_INT2_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT2_Pos)
#define ADCIOVFC_ALL_INT2_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT3
 *  @access     ADC->ADCIOVFC.bit.INT3
 *  @brief      ADC Interrupt 3 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT3_Pos (3)
#define ADCIOVFC_ALL_INT3_Msk (0x1UL << ADCIOVFC_ALL_INT3_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT3_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT3_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 3 overflow flag    */
} ADCIOVFC_BIT_INT3;

#define ADCIOVFC_ALL_INT3_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT3_Pos)
#define ADCIOVFC_ALL_INT3_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT4
 *  @access     ADC->ADCIOVFC.bit.INT4
 *  @brief      ADC Interrupt 4 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT4_Pos (4)
#define ADCIOVFC_ALL_INT4_Msk (0x1UL << ADCIOVFC_ALL_INT4_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT4_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT4_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 4 overflow flag    */
} ADCIOVFC_BIT_INT4;

#define ADCIOVFC_ALL_INT4_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT4_Pos)
#define ADCIOVFC_ALL_INT4_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT5
 *  @access     ADC->ADCIOVFC.bit.INT5
 *  @brief      ADC Interrupt 5 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT5_Pos (5)
#define ADCIOVFC_ALL_INT5_Msk (0x1UL << ADCIOVFC_ALL_INT5_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT5_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT5_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 5 overflow flag    */
} ADCIOVFC_BIT_INT5;

#define ADCIOVFC_ALL_INT5_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT5_Pos)
#define ADCIOVFC_ALL_INT5_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT6
 *  @access     ADC->ADCIOVFC.bit.INT6
 *  @brief      ADC Interrupt 6 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT6_Pos (6)
#define ADCIOVFC_ALL_INT6_Msk (0x1UL << ADCIOVFC_ALL_INT6_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT6_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT6_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 6 overflow flag    */
} ADCIOVFC_BIT_INT6;

#define ADCIOVFC_ALL_INT6_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT6_Pos)
#define ADCIOVFC_ALL_INT6_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT7
 *  @access     ADC->ADCIOVFC.bit.INT7
 *  @brief      ADC Interrupt 7 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT7_Pos (7)
#define ADCIOVFC_ALL_INT7_Msk (0x1UL << ADCIOVFC_ALL_INT7_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT7_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT7_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 7 overflow flag    */
} ADCIOVFC_BIT_INT7;

#define ADCIOVFC_ALL_INT7_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT7_Pos)
#define ADCIOVFC_ALL_INT7_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT8
 *  @access     ADC->ADCIOVFC.bit.INT8
 *  @brief      ADC Interrupt 8 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT8_Pos (8)
#define ADCIOVFC_ALL_INT8_Msk (0x1UL << ADCIOVFC_ALL_INT8_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT8_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT8_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 8 overflow flag    */
} ADCIOVFC_BIT_INT8;

#define ADCIOVFC_ALL_INT8_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT8_Pos)
#define ADCIOVFC_ALL_INT8_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT9
 *  @access     ADC->ADCIOVFC.bit.INT9
 *  @brief      ADC Interrupt 9 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT9_Pos (9)
#define ADCIOVFC_ALL_INT9_Msk (0x1UL << ADCIOVFC_ALL_INT9_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT9_NO_EFFECT      = 0,  /*!< No clear                               */
    ADCIOVFC_BIT_INT9_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 9 overflow flag    */
} ADCIOVFC_BIT_INT9;

#define ADCIOVFC_ALL_INT9_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT9_Pos)
#define ADCIOVFC_ALL_INT9_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT10
 *  @access     ADC->ADCIOVFC.bit.INT10
 *  @brief      ADC Interrupt 10 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT10_Pos (10)
#define ADCIOVFC_ALL_INT10_Msk (0x1UL << ADCIOVFC_ALL_INT10_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT10_NO_EFFECT      = 0,  /*!< No clear                                */
    ADCIOVFC_BIT_INT10_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 10 overflow flag    */
} ADCIOVFC_BIT_INT10;

#define ADCIOVFC_ALL_INT10_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT10_Pos)
#define ADCIOVFC_ALL_INT10_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT11
 *  @access     ADC->ADCIOVFC.bit.INT11
 *  @brief      ADC Interrupt 11 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT11_Pos (11)
#define ADCIOVFC_ALL_INT11_Msk (0x1UL << ADCIOVFC_ALL_INT11_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT11_NO_EFFECT      = 0,  /*!< No clear                                */
    ADCIOVFC_BIT_INT11_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 11 overflow flag    */
} ADCIOVFC_BIT_INT11;

#define ADCIOVFC_ALL_INT11_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT11_Pos)
#define ADCIOVFC_ALL_INT11_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT12
 *  @access     ADC->ADCIOVFC.bit.INT12
 *  @brief      ADC Interrupt 12 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT12_Pos (12)
#define ADCIOVFC_ALL_INT12_Msk (0x1UL << ADCIOVFC_ALL_INT12_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT12_NO_EFFECT      = 0,  /*!< No clear                                */
    ADCIOVFC_BIT_INT12_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 12 overflow flag    */
} ADCIOVFC_BIT_INT12;

#define ADCIOVFC_ALL_INT12_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT12_Pos)
#define ADCIOVFC_ALL_INT12_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT13
 *  @access     ADC->ADCIOVFC.bit.INT13
 *  @brief      ADC Interrupt 13 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT13_Pos (13)
#define ADCIOVFC_ALL_INT13_Msk (0x1UL << ADCIOVFC_ALL_INT13_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT13_NO_EFFECT      = 0,  /*!< No clear                                */
    ADCIOVFC_BIT_INT13_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 13 overflow flag    */
} ADCIOVFC_BIT_INT13;

#define ADCIOVFC_ALL_INT13_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT13_Pos)
#define ADCIOVFC_ALL_INT13_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT14
 *  @access     ADC->ADCIOVFC.bit.INT14
 *  @brief      ADC Interrupt 14 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT14_Pos (14)
#define ADCIOVFC_ALL_INT14_Msk (0x1UL << ADCIOVFC_ALL_INT14_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT14_NO_EFFECT      = 0,  /*!< No clear                                */
    ADCIOVFC_BIT_INT14_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 14 overflow flag    */
} ADCIOVFC_BIT_INT14;

#define ADCIOVFC_ALL_INT14_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT14_Pos)
#define ADCIOVFC_ALL_INT14_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCIOVFC        INT15
 *  @access     ADC->ADCIOVFC.bit.INT15
 *  @brief      ADC Interrupt 15 overflow flag clear bit
 */
#define ADCIOVFC_ALL_INT15_Pos (15)
#define ADCIOVFC_ALL_INT15_Msk (0x1UL << ADCIOVFC_ALL_INT15_Pos)

typedef enum
{
    ADCIOVFC_BIT_INT15_NO_EFFECT      = 0,  /*!< No clear                                */
    ADCIOVFC_BIT_INT15_CLEAR_FLAG     = 1,  /*!< Clear ADC Interrupt 15 overflow flag    */
} ADCIOVFC_BIT_INT15;

#define ADCIOVFC_ALL_INT15_NO_EFFECT      ((0x0UL) << ADCIOVFC_ALL_INT15_Pos)
#define ADCIOVFC_ALL_INT15_CLEAR_FLAG     ((0x1UL) << ADCIOVFC_ALL_INT15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL0      INT0EN
 *  @access     ADC->ADCINTSEL0.bit.INT0EN
 *  @brief      ADC interrupt 0 enable
 */
#define ADCINTSEL0_ALL_INT0EN_Pos (5)
#define ADCINTSEL0_ALL_INT0EN_Msk (0x1UL << ADCINTSEL0_ALL_INT0EN_Pos)

typedef enum
{
    ADCINTSEL0_BIT_INT0EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 0   */
    ADCINTSEL0_BIT_INT0EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 0    */
} ADCINTSEL0_BIT_INT0EN;

#define ADCINTSEL0_ALL_INT0EN_DISABLE     ((0x0UL) << ADCINTSEL0_ALL_INT0EN_Pos)
#define ADCINTSEL0_ALL_INT0EN_ENABLE      ((0x1UL) << ADCINTSEL0_ALL_INT0EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL0      INT0CONT
 *  @access     ADC->ADCINTSEL0.bit.INT0CONT
 *  @brief      ADC interrupt 0 continuous mode enable
 */
#define ADCINTSEL0_ALL_INT0CONT_Pos (6)
#define ADCINTSEL0_ALL_INT0CONT_Msk (0x1UL << ADCINTSEL0_ALL_INT0CONT_Pos)

typedef enum
{
    ADCINTSEL0_BIT_INT0CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 0 is generated unless the flag bit is clear by user   */
    ADCINTSEL0_BIT_INT0CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 0 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL0_BIT_INT0CONT;

#define ADCINTSEL0_ALL_INT0CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL0_ALL_INT0CONT_Pos)
#define ADCINTSEL0_ALL_INT0CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL0_ALL_INT0CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL0      INT1EN
 *  @access     ADC->ADCINTSEL0.bit.INT1EN
 *  @brief      ADC Interrupt 1 enable
 */
#define ADCINTSEL0_ALL_INT1EN_Pos (13)
#define ADCINTSEL0_ALL_INT1EN_Msk (0x1UL << ADCINTSEL0_ALL_INT1EN_Pos)

typedef enum
{
    ADCINTSEL0_BIT_INT1EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 1    */
    ADCINTSEL0_BIT_INT1EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 1     */
} ADCINTSEL0_BIT_INT1EN;

#define ADCINTSEL0_ALL_INT1EN_DISABLE     ((0x0UL) << ADCINTSEL0_ALL_INT1EN_Pos)
#define ADCINTSEL0_ALL_INT1EN_ENABLE      ((0x1UL) << ADCINTSEL0_ALL_INT1EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL0      INT1CONT
 *  @access     ADC->ADCINTSEL0.bit.INT1CONT
 *  @brief      ADC Interrupt 1 continuous mode enable
 */
#define ADCINTSEL0_ALL_INT1CONT_Pos (14)
#define ADCINTSEL0_ALL_INT1CONT_Msk (0x1UL << ADCINTSEL0_ALL_INT1CONT_Pos)

typedef enum
{
    ADCINTSEL0_BIT_INT1CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 1 is generated unless the flag bit is clear by user   */
    ADCINTSEL0_BIT_INT1CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 1 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL0_BIT_INT1CONT;

#define ADCINTSEL0_ALL_INT1CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL0_ALL_INT1CONT_Pos)
#define ADCINTSEL0_ALL_INT1CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL0_ALL_INT1CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL1      INT2EN
 *  @access     ADC->ADCINTSEL1.bit.INT2EN
 *  @brief      ADC interrupt 2 enable
 */
#define ADCINTSEL1_ALL_INT2EN_Pos (5)
#define ADCINTSEL1_ALL_INT2EN_Msk (0x1UL << ADCINTSEL1_ALL_INT2EN_Pos)

typedef enum
{
    ADCINTSEL1_BIT_INT2EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 2   */
    ADCINTSEL1_BIT_INT2EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 2    */
} ADCINTSEL1_BIT_INT2EN;

#define ADCINTSEL1_ALL_INT2EN_DISABLE     ((0x0UL) << ADCINTSEL1_ALL_INT2EN_Pos)
#define ADCINTSEL1_ALL_INT2EN_ENABLE      ((0x1UL) << ADCINTSEL1_ALL_INT2EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL1      INT2CONT
 *  @access     ADC->ADCINTSEL1.bit.INT2CONT
 *  @brief      ADC interrupt 2 continuous mode enable
 */
#define ADCINTSEL1_ALL_INT2CONT_Pos (6)
#define ADCINTSEL1_ALL_INT2CONT_Msk (0x1UL << ADCINTSEL1_ALL_INT2CONT_Pos)

typedef enum
{
    ADCINTSEL1_BIT_INT2CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 2 is generated unless the flag bit is clear by user   */
    ADCINTSEL1_BIT_INT2CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 2 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL1_BIT_INT2CONT;

#define ADCINTSEL1_ALL_INT2CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL1_ALL_INT2CONT_Pos)
#define ADCINTSEL1_ALL_INT2CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL1_ALL_INT2CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL1      INT3EN
 *  @access     ADC->ADCINTSEL1.bit.INT3EN
 *  @brief      ADC interrupt 3 enable
 */
#define ADCINTSEL1_ALL_INT3EN_Pos (13)
#define ADCINTSEL1_ALL_INT3EN_Msk (0x1UL << ADCINTSEL1_ALL_INT3EN_Pos)

typedef enum
{
    ADCINTSEL1_BIT_INT3EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 3   */
    ADCINTSEL1_BIT_INT3EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 3    */
} ADCINTSEL1_BIT_INT3EN;

#define ADCINTSEL1_ALL_INT3EN_DISABLE     ((0x0UL) << ADCINTSEL1_ALL_INT3EN_Pos)
#define ADCINTSEL1_ALL_INT3EN_ENABLE      ((0x1UL) << ADCINTSEL1_ALL_INT3EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL1      INT3CONT
 *  @access     ADC->ADCINTSEL1.bit.INT3CONT
 *  @brief      ADC interrupt 3 continuous mode enable
 */
#define ADCINTSEL1_ALL_INT3CONT_Pos (14)
#define ADCINTSEL1_ALL_INT3CONT_Msk (0x1UL << ADCINTSEL1_ALL_INT3CONT_Pos)

typedef enum
{
    ADCINTSEL1_BIT_INT3CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 3 is generated unless the flag bit is clear by user   */
    ADCINTSEL1_BIT_INT3CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 3 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL1_BIT_INT3CONT;

#define ADCINTSEL1_ALL_INT3CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL1_ALL_INT3CONT_Pos)
#define ADCINTSEL1_ALL_INT3CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL1_ALL_INT3CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL2      INT4EN
 *  @access     ADC->ADCINTSEL2.bit.INT4EN
 *  @brief      ADC interrupt 4 enable
 */
#define ADCINTSEL2_ALL_INT4EN_Pos (5)
#define ADCINTSEL2_ALL_INT4EN_Msk (0x1UL << ADCINTSEL2_ALL_INT4EN_Pos)

typedef enum
{
    ADCINTSEL2_BIT_INT4EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 4   */
    ADCINTSEL2_BIT_INT4EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 4    */
} ADCINTSEL2_BIT_INT4EN;

#define ADCINTSEL2_ALL_INT4EN_DISABLE     ((0x0UL) << ADCINTSEL2_ALL_INT4EN_Pos)
#define ADCINTSEL2_ALL_INT4EN_ENABLE      ((0x1UL) << ADCINTSEL2_ALL_INT4EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL2      INT4CONT
 *  @access     ADC->ADCINTSEL2.bit.INT4CONT
 *  @brief      ADC interrupt 4 continuous mode enable
 */
#define ADCINTSEL2_ALL_INT4CONT_Pos (6)
#define ADCINTSEL2_ALL_INT4CONT_Msk (0x1UL << ADCINTSEL2_ALL_INT4CONT_Pos)

typedef enum
{
    ADCINTSEL2_BIT_INT4CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 4 is generated unless the flag bit is clear by user   */
    ADCINTSEL2_BIT_INT4CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 4 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL2_BIT_INT4CONT;

#define ADCINTSEL2_ALL_INT4CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL2_ALL_INT4CONT_Pos)
#define ADCINTSEL2_ALL_INT4CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL2_ALL_INT4CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL2      INT5EN
 *  @access     ADC->ADCINTSEL2.bit.INT5EN
 *  @brief      ADC interrupt 5 enable
 */
#define ADCINTSEL2_ALL_INT5EN_Pos (13)
#define ADCINTSEL2_ALL_INT5EN_Msk (0x1UL << ADCINTSEL2_ALL_INT5EN_Pos)

typedef enum
{
    ADCINTSEL2_BIT_INT5EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 5   */
    ADCINTSEL2_BIT_INT5EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 5    */
} ADCINTSEL2_BIT_INT5EN;

#define ADCINTSEL2_ALL_INT5EN_DISABLE     ((0x0UL) << ADCINTSEL2_ALL_INT5EN_Pos)
#define ADCINTSEL2_ALL_INT5EN_ENABLE      ((0x1UL) << ADCINTSEL2_ALL_INT5EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL2      INT5CONT
 *  @access     ADC->ADCINTSEL2.bit.INT5CONT
 *  @brief      ADC interrupt 5 continuous mode enable
 */
#define ADCINTSEL2_ALL_INT5CONT_Pos (14)
#define ADCINTSEL2_ALL_INT5CONT_Msk (0x1UL << ADCINTSEL2_ALL_INT5CONT_Pos)

typedef enum
{
    ADCINTSEL2_BIT_INT5CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 5 is generated unless the flag bit is clear by user   */
    ADCINTSEL2_BIT_INT5CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 5 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL2_BIT_INT5CONT;

#define ADCINTSEL2_ALL_INT5CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL2_ALL_INT5CONT_Pos)
#define ADCINTSEL2_ALL_INT5CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL2_ALL_INT5CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT15CONT
 *  @access     ADC->ADCINTSEL3.bit.INT15CONT
 *  @brief      ADC interrupt 15 continuous mode enable
 */
#define ADCINTSEL3_ALL_INT15CONT_Pos (0)
#define ADCINTSEL3_ALL_INT15CONT_Msk (0x1UL << ADCINTSEL3_ALL_INT15CONT_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT15CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 15 is generated unless the flag bit is clear by user   */
    ADCINTSEL3_BIT_INT15CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 15 is generated whenever an EOC pulse happen                     
                                                                  irrespective whether the flag bit is clear                                      */
} ADCINTSEL3_BIT_INT15CONT;

#define ADCINTSEL3_ALL_INT15CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT15CONT_Pos)
#define ADCINTSEL3_ALL_INT15CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT15CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT12EN
 *  @access     ADC->ADCINTSEL3.bit.INT12EN
 *  @brief      ADC interrupt 12 enable
 */
#define ADCINTSEL3_ALL_INT12EN_Pos (1)
#define ADCINTSEL3_ALL_INT12EN_Msk (0x1UL << ADCINTSEL3_ALL_INT12EN_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT12EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 12   */
    ADCINTSEL3_BIT_INT12EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 12    */
} ADCINTSEL3_BIT_INT12EN;

#define ADCINTSEL3_ALL_INT12EN_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT12EN_Pos)
#define ADCINTSEL3_ALL_INT12EN_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT12EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT12CONT
 *  @access     ADC->ADCINTSEL3.bit.INT12CONT
 *  @brief      ADC interrupt 12 continuous mode enable
 */
#define ADCINTSEL3_ALL_INT12CONT_Pos (2)
#define ADCINTSEL3_ALL_INT12CONT_Msk (0x1UL << ADCINTSEL3_ALL_INT12CONT_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT12CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 12 is generated unless the flag bit is clear by user   */
    ADCINTSEL3_BIT_INT12CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 12 is generated whenever an EOC pulse happen                     
                                                                  irrespective whether the flag bit is clear                                      */
} ADCINTSEL3_BIT_INT12CONT;

#define ADCINTSEL3_ALL_INT12CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT12CONT_Pos)
#define ADCINTSEL3_ALL_INT12CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT12CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT11EN
 *  @access     ADC->ADCINTSEL3.bit.INT11EN
 *  @brief      ADC interrupt 11 enable
 */
#define ADCINTSEL3_ALL_INT11EN_Pos (3)
#define ADCINTSEL3_ALL_INT11EN_Msk (0x1UL << ADCINTSEL3_ALL_INT11EN_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT11EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 11   */
    ADCINTSEL3_BIT_INT11EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 11    */
} ADCINTSEL3_BIT_INT11EN;

#define ADCINTSEL3_ALL_INT11EN_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT11EN_Pos)
#define ADCINTSEL3_ALL_INT11EN_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT11EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT11CONT
 *  @access     ADC->ADCINTSEL3.bit.INT11CONT
 *  @brief      ADC interrupt 11 continuous mode enable
 */
#define ADCINTSEL3_ALL_INT11CONT_Pos (4)
#define ADCINTSEL3_ALL_INT11CONT_Msk (0x1UL << ADCINTSEL3_ALL_INT11CONT_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT11CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 11 is generated unless the flag bit is clear by user   */
    ADCINTSEL3_BIT_INT11CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 11 is generated whenever an EOC pulse happen                     
                                                                  irrespective whether the flag bit is clear                                      */
} ADCINTSEL3_BIT_INT11CONT;

#define ADCINTSEL3_ALL_INT11CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT11CONT_Pos)
#define ADCINTSEL3_ALL_INT11CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT11CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT6EN
 *  @access     ADC->ADCINTSEL3.bit.INT6EN
 *  @brief      ADC interrupt 6 enable
 */
#define ADCINTSEL3_ALL_INT6EN_Pos (5)
#define ADCINTSEL3_ALL_INT6EN_Msk (0x1UL << ADCINTSEL3_ALL_INT6EN_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT6EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 6   */
    ADCINTSEL3_BIT_INT6EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 6    */
} ADCINTSEL3_BIT_INT6EN;

#define ADCINTSEL3_ALL_INT6EN_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT6EN_Pos)
#define ADCINTSEL3_ALL_INT6EN_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT6EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT6CONT
 *  @access     ADC->ADCINTSEL3.bit.INT6CONT
 *  @brief      ADC interrupt 6 continuous mode enable
 */
#define ADCINTSEL3_ALL_INT6CONT_Pos (6)
#define ADCINTSEL3_ALL_INT6CONT_Msk (0x1UL << ADCINTSEL3_ALL_INT6CONT_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT6CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 6 is generated unless the flag bit is clear by user   */
    ADCINTSEL3_BIT_INT6CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 6 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL3_BIT_INT6CONT;

#define ADCINTSEL3_ALL_INT6CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT6CONT_Pos)
#define ADCINTSEL3_ALL_INT6CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT6CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT15EN
 *  @access     ADC->ADCINTSEL3.bit.INT15EN
 *  @brief      ADC interrupt 15 enable
 */
#define ADCINTSEL3_ALL_INT15EN_Pos (8)
#define ADCINTSEL3_ALL_INT15EN_Msk (0x1UL << ADCINTSEL3_ALL_INT15EN_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT15EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 15   */
    ADCINTSEL3_BIT_INT15EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 15    */
} ADCINTSEL3_BIT_INT15EN;

#define ADCINTSEL3_ALL_INT15EN_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT15EN_Pos)
#define ADCINTSEL3_ALL_INT15EN_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT15EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT14EN
 *  @access     ADC->ADCINTSEL3.bit.INT14EN
 *  @brief      ADC interrupt 14 enable
 */
#define ADCINTSEL3_ALL_INT14EN_Pos (9)
#define ADCINTSEL3_ALL_INT14EN_Msk (0x1UL << ADCINTSEL3_ALL_INT14EN_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT14EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 14   */
    ADCINTSEL3_BIT_INT14EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 14    */
} ADCINTSEL3_BIT_INT14EN;

#define ADCINTSEL3_ALL_INT14EN_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT14EN_Pos)
#define ADCINTSEL3_ALL_INT14EN_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT14EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT14CONT
 *  @access     ADC->ADCINTSEL3.bit.INT14CONT
 *  @brief      ADC interrupt 14 continuous mode enable
 */
#define ADCINTSEL3_ALL_INT14CONT_Pos (10)
#define ADCINTSEL3_ALL_INT14CONT_Msk (0x1UL << ADCINTSEL3_ALL_INT14CONT_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT14CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 14 is generated unless the flag bit is clear by user   */
    ADCINTSEL3_BIT_INT14CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 14 is generated whenever an EOC pulse happen                     
                                                                  irrespective whether the flag bit is clear                                      */
} ADCINTSEL3_BIT_INT14CONT;

#define ADCINTSEL3_ALL_INT14CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT14CONT_Pos)
#define ADCINTSEL3_ALL_INT14CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT14CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT13EN
 *  @access     ADC->ADCINTSEL3.bit.INT13EN
 *  @brief      ADC interrupt 13 enable
 */
#define ADCINTSEL3_ALL_INT13EN_Pos (11)
#define ADCINTSEL3_ALL_INT13EN_Msk (0x1UL << ADCINTSEL3_ALL_INT13EN_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT13EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 13   */
    ADCINTSEL3_BIT_INT13EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 13    */
} ADCINTSEL3_BIT_INT13EN;

#define ADCINTSEL3_ALL_INT13EN_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT13EN_Pos)
#define ADCINTSEL3_ALL_INT13EN_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT13EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT13CONT
 *  @access     ADC->ADCINTSEL3.bit.INT13CONT
 *  @brief      ADC interrupt 13 continuous mode enable
 */
#define ADCINTSEL3_ALL_INT13CONT_Pos (12)
#define ADCINTSEL3_ALL_INT13CONT_Msk (0x1UL << ADCINTSEL3_ALL_INT13CONT_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT13CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 13 is generated unless the flag bit is clear by user   */
    ADCINTSEL3_BIT_INT13CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 13 is generated whenever an EOC pulse happen                     
                                                                  irrespective whether the flag bit is clear                                      */
} ADCINTSEL3_BIT_INT13CONT;

#define ADCINTSEL3_ALL_INT13CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT13CONT_Pos)
#define ADCINTSEL3_ALL_INT13CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT13CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT7EN
 *  @access     ADC->ADCINTSEL3.bit.INT7EN
 *  @brief      ADC interrupt 7 enable
 */
#define ADCINTSEL3_ALL_INT7EN_Pos (13)
#define ADCINTSEL3_ALL_INT7EN_Msk (0x1UL << ADCINTSEL3_ALL_INT7EN_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT7EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 7   */
    ADCINTSEL3_BIT_INT7EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 7    */
} ADCINTSEL3_BIT_INT7EN;

#define ADCINTSEL3_ALL_INT7EN_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT7EN_Pos)
#define ADCINTSEL3_ALL_INT7EN_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT7EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL3      INT7CONT
 *  @access     ADC->ADCINTSEL3.bit.INT7CONT
 *  @brief      ADC interrupt 7 continuous mode enable
 */
#define ADCINTSEL3_ALL_INT7CONT_Pos (14)
#define ADCINTSEL3_ALL_INT7CONT_Msk (0x1UL << ADCINTSEL3_ALL_INT7CONT_Pos)

typedef enum
{
    ADCINTSEL3_BIT_INT7CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 7 is generated unless the flag bit is clear by user   */
    ADCINTSEL3_BIT_INT7CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 7 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL3_BIT_INT7CONT;

#define ADCINTSEL3_ALL_INT7CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL3_ALL_INT7CONT_Pos)
#define ADCINTSEL3_ALL_INT7CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL3_ALL_INT7CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL4      INT10EN
 *  @access     ADC->ADCINTSEL4.bit.INT10EN
 *  @brief      ADC interrupt 10 enable
 */
#define ADCINTSEL4_ALL_INT10EN_Pos (1)
#define ADCINTSEL4_ALL_INT10EN_Msk (0x1UL << ADCINTSEL4_ALL_INT10EN_Pos)

typedef enum
{
    ADCINTSEL4_BIT_INT10EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 10   */
    ADCINTSEL4_BIT_INT10EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 10    */
} ADCINTSEL4_BIT_INT10EN;

#define ADCINTSEL4_ALL_INT10EN_DISABLE     ((0x0UL) << ADCINTSEL4_ALL_INT10EN_Pos)
#define ADCINTSEL4_ALL_INT10EN_ENABLE      ((0x1UL) << ADCINTSEL4_ALL_INT10EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL4      INT10CONT
 *  @access     ADC->ADCINTSEL4.bit.INT10CONT
 *  @brief      ADC interrupt 10 continuous mode enable
 */
#define ADCINTSEL4_ALL_INT10CONT_Pos (2)
#define ADCINTSEL4_ALL_INT10CONT_Msk (0x1UL << ADCINTSEL4_ALL_INT10CONT_Pos)

typedef enum
{
    ADCINTSEL4_BIT_INT10CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 10 is generated unless the flag bit is clear by user   */
    ADCINTSEL4_BIT_INT10CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 10 is generated whenever an EOC pulse happen                     
                                                                  irrespective whether the flag bit is clear                                      */
} ADCINTSEL4_BIT_INT10CONT;

#define ADCINTSEL4_ALL_INT10CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL4_ALL_INT10CONT_Pos)
#define ADCINTSEL4_ALL_INT10CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL4_ALL_INT10CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL4      INT9EN
 *  @access     ADC->ADCINTSEL4.bit.INT9EN
 *  @brief      ADC interrupt 9 enable
 */
#define ADCINTSEL4_ALL_INT9EN_Pos (3)
#define ADCINTSEL4_ALL_INT9EN_Msk (0x1UL << ADCINTSEL4_ALL_INT9EN_Pos)

typedef enum
{
    ADCINTSEL4_BIT_INT9EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 9   */
    ADCINTSEL4_BIT_INT9EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 9    */
} ADCINTSEL4_BIT_INT9EN;

#define ADCINTSEL4_ALL_INT9EN_DISABLE     ((0x0UL) << ADCINTSEL4_ALL_INT9EN_Pos)
#define ADCINTSEL4_ALL_INT9EN_ENABLE      ((0x1UL) << ADCINTSEL4_ALL_INT9EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL4      INT9CONT
 *  @access     ADC->ADCINTSEL4.bit.INT9CONT
 *  @brief      ADC interrupt 9 continuous mode enable
 */
#define ADCINTSEL4_ALL_INT9CONT_Pos (4)
#define ADCINTSEL4_ALL_INT9CONT_Msk (0x1UL << ADCINTSEL4_ALL_INT9CONT_Pos)

typedef enum
{
    ADCINTSEL4_BIT_INT9CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 9 is generated unless the flag bit is clear by user   */
    ADCINTSEL4_BIT_INT9CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 9 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL4_BIT_INT9CONT;

#define ADCINTSEL4_ALL_INT9CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL4_ALL_INT9CONT_Pos)
#define ADCINTSEL4_ALL_INT9CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL4_ALL_INT9CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL4      INT8EN
 *  @access     ADC->ADCINTSEL4.bit.INT8EN
 *  @brief      ADC interrupt 8 enable
 */
#define ADCINTSEL4_ALL_INT8EN_Pos (5)
#define ADCINTSEL4_ALL_INT8EN_Msk (0x1UL << ADCINTSEL4_ALL_INT8EN_Pos)

typedef enum
{
    ADCINTSEL4_BIT_INT8EN_DISABLE     = 0,  /*!< Disable ADC Interrupt 8   */
    ADCINTSEL4_BIT_INT8EN_ENABLE      = 1,  /*!< Enable ADC Interrupt 8    */
} ADCINTSEL4_BIT_INT8EN;

#define ADCINTSEL4_ALL_INT8EN_DISABLE     ((0x0UL) << ADCINTSEL4_ALL_INT8EN_Pos)
#define ADCINTSEL4_ALL_INT8EN_ENABLE      ((0x1UL) << ADCINTSEL4_ALL_INT8EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSEL4      INT8CONT
 *  @access     ADC->ADCINTSEL4.bit.INT8CONT
 *  @brief      ADC interrupt 8 continuous mode enable
 */
#define ADCINTSEL4_ALL_INT8CONT_Pos (6)
#define ADCINTSEL4_ALL_INT8CONT_Msk (0x1UL << ADCINTSEL4_ALL_INT8CONT_Pos)

typedef enum
{
    ADCINTSEL4_BIT_INT8CONT_CONTINUE_MODE_DISABLE     = 0,  /*!< No further ADC Interrupt 8 is generated unless the flag bit is clear by user   */
    ADCINTSEL4_BIT_INT8CONT_CONTINUE_MODE_ENABLE      = 1,  /*!< ADC Interrupt 8 is generated whenever an EOC pulse happen                     
                                                                 irrespective whether the flag bit is clear                                     */
} ADCINTSEL4_BIT_INT8CONT;

#define ADCINTSEL4_ALL_INT8CONT_CONTINUE_MODE_DISABLE     ((0x0UL) << ADCINTSEL4_ALL_INT8CONT_Pos)
#define ADCINTSEL4_ALL_INT8CONT_CONTINUE_MODE_ENABLE      ((0x1UL) << ADCINTSEL4_ALL_INT8CONT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCPRICTL    PRIORITY
 *  @access     ADC->ADCSOCPRICTL.bit.PRIORITY
 *  @brief      SOC (State-machine of Conversion) Priority
 *              Determines the cutoff point for priority mode and round arbitration of SOCs
 */
#define ADCSOCPRICTL_ALL_PRIORITY_Pos (0)
#define ADCSOCPRICTL_ALL_PRIORITY_Msk (0x1FUL << ADCSOCPRICTL_ALL_PRIORITY_Pos)

typedef enum
{
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC0      = 0,  /*!< All SOCs priority follow the rule of round mode               */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC1      = 1,  /*!< SOC0 are high priority, SOC1-SOC15 is in round mode           */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC2      = 2,  /*!< SOC0-SOC1 are high priority, SOC2-SOC15 is in round mode      */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC3      = 3,  /*!< SOC0-SOC2 are high priority, SOC3-SOC15 is in round mode      */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC4      = 4,  /*!< SOC0-SOC3 are high priority, SOC4-SOC15 is in round mode      */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC5      = 5,  /*!< SOC0-SOC4 are high priority, SOC5-SOC15 is in round mode      */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC6      = 6,  /*!< SOC0-SOC5 are high priority, SOC6-SOC15 is in round mode      */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC7      = 7,  /*!< SOC0-SOC6 are high priority, SOC7-SOC15 is in round mode      */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC8      = 8,  /*!< SOC0-SOC7 are high priority, SOC8-SOC15 is in round mode      */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC9      = 9,  /*!< SOC0-SOC8 are high priority, SOC9-SOC15 is in round mode      */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC10     = 10,  /*!< SOC0-SOC9 are high priority, SOC10-SOC15 is in round mode     */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC11     = 11,  /*!< SOC0-SOC10 are high priority, SOC11-SOC15 is in round mode    */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC12     = 12,  /*!< SOC0-SOC11 are high priority, SOC12-SOC15 is in round mode    */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC13     = 13,  /*!< SOC0-SOC12 are high priority, SOC13-SOC15 is in round mode    */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC14     = 14,  /*!< SOC0-SOC13 are high priority, SOC14-SOC15 is in round mode    */
    ADCSOCPRICTL_BIT_PRIORITY_CUTOFF_AT_SOC15     = 15,  /*!< SOC0-SOC14 are high priority, SOC15 is in round mode          */
} ADCSOCPRICTL_BIT_PRIORITY;

#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC0      ((0x00UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC1      ((0x01UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC2      ((0x02UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC3      ((0x03UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC4      ((0x04UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC5      ((0x05UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC6      ((0x06UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC7      ((0x07UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC8      ((0x08UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC9      ((0x09UL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC10     ((0x0AUL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC11     ((0x0BUL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC12     ((0x0CUL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC13     ((0x0DUL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC14     ((0x0EUL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)
#define ADCSOCPRICTL_ALL_PRIORITY_CUTOFF_AT_SOC15     ((0x0FUL) << ADCSOCPRICTL_ALL_PRIORITY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCPRICTL    RRPOINTER
 *  @access     ADC->ADCSOCPRICTL.bit.RRPOINTER
 *  @brief      Round Ring Pointer
 *              Holds the latest SOCx in Round Ring, and determine the next order of conversion.
 */
#define ADCSOCPRICTL_ALL_RRPOINTER_Pos (5)
#define ADCSOCPRICTL_ALL_RRPOINTER_Msk (0x3FUL << ADCSOCPRICTL_ALL_RRPOINTER_Pos)

typedef enum
{
    ADCSOCPRICTL_BIT_RRPOINTER_SOC0      = 0,  /*!<  SOC0 was the latest SOC. SOC1 is next one in Round Robin.    */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC1      = 1,  /*!< SOC1 was the latest SOC. SOC2 is next one in Round Robin.     */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC2      = 2,  /*!< SOC2 was the latest SOC. SOC3 is next one in Round Robin.     */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC3      = 3,  /*!< SOC3 was the latest SOC. SOC4 is next one in Round Robin.     */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC4      = 4,  /*!< SOC4 was the latest SOC. SOC5 is next one in Round Robin.     */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC5      = 5,  /*!< SOC5 was the latest SOC. SOC6 is next one in Round Robin.     */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC6      = 6,  /*!< SOC6 was the latest SOC. SOC7 is next one in Round Robin.     */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC7      = 7,  /*!< SOC7 was the latest SOC. SOC8 is next one in Round Robin.     */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC8      = 8,  /*!< SOC8 was the latest SOC. SOC9 is next one in Round Robin.     */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC9      = 9,  /*!< SOC9 was the latest SOC. SOC10 is next one in Round Robin.    */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC10     = 10,  /*!< SOC10 was the latest SOC. SOC11 is next one in Round Robin.   */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC11     = 11,  /*!< SOC11 was the latest SOC. SOC12 is next one in Round Robin.   */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC12     = 12,  /*!< SOC12 was the latest SOC. SOC13 is next one in Round Robin.   */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC13     = 13,  /*!< SOC13 was the latest SOC. SOC14 is next one in Round Robin.   */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC14     = 14,  /*!< SOC14 was the latest SOC. SOC15 is next one in Round Robin.   */
    ADCSOCPRICTL_BIT_RRPOINTER_SOC15     = 15,  /*!< SOC15 was the latest SOC. SOC0 is next one in Round Robin.    */
} ADCSOCPRICTL_BIT_RRPOINTER;

#define ADCSOCPRICTL_ALL_RRPOINTER_SOC0      ((0x00UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC1      ((0x01UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC2      ((0x02UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC3      ((0x03UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC4      ((0x04UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC5      ((0x05UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC6      ((0x06UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC7      ((0x07UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC8      ((0x08UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC9      ((0x09UL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC10     ((0x0AUL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC11     ((0x0BUL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC12     ((0x0CUL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC13     ((0x0DUL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC14     ((0x0EUL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)
#define ADCSOCPRICTL_ALL_RRPOINTER_SOC15     ((0x0FUL) << ADCSOCPRICTL_ALL_RRPOINTER_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL0   SOC0
 *  @access     ADC->ADCINTSOCSEL0.bit.SOC0
 *  @brief      Select ADC interrupt source for SOC0. This Field will overrides the TRIGSEL Field in the ADCSOC0CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC0.
 */
#define ADCINTSOCSEL0_ALL_SOC0_Pos (0)
#define ADCINTSOCSEL0_ALL_SOC0_Msk (0x1FUL << ADCINTSOCSEL0_ALL_SOC0_Pos)

typedef enum
{
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC0    */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC0   */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC0   */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC0   */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC0   */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC0   */
    ADCINTSOCSEL0_BIT_SOC0_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC0   */
} ADCINTSOCSEL0_BIT_SOC0;

#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL0_ALL_SOC0_Pos)
#define ADCINTSOCSEL0_ALL_SOC0_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL0_ALL_SOC0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL0   SOC1
 *  @access     ADC->ADCINTSOCSEL0.bit.SOC1
 *  @brief      Select ADC interrupt source for SOC1. This Field will overrides the TRIGSEL Field in the ADCSOC1CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC1.
 */
#define ADCINTSOCSEL0_ALL_SOC1_Pos (5)
#define ADCINTSOCSEL0_ALL_SOC1_Msk (0x1FUL << ADCINTSOCSEL0_ALL_SOC1_Pos)

typedef enum
{
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC1    */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC1   */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC1   */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC1   */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC1   */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC1   */
    ADCINTSOCSEL0_BIT_SOC1_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC1   */
} ADCINTSOCSEL0_BIT_SOC1;

#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL0_ALL_SOC1_Pos)
#define ADCINTSOCSEL0_ALL_SOC1_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL0_ALL_SOC1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL0   SOC2
 *  @access     ADC->ADCINTSOCSEL0.bit.SOC2
 *  @brief      Select ADC interrupt source for SOC2. This Field will overrides the TRIGSEL Field in the ADCSOC2CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC2.
 */
#define ADCINTSOCSEL0_ALL_SOC2_Pos (10)
#define ADCINTSOCSEL0_ALL_SOC2_Msk (0x1FUL << ADCINTSOCSEL0_ALL_SOC2_Pos)

typedef enum
{
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC2    */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC2   */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC2   */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC2   */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC2   */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC2   */
    ADCINTSOCSEL0_BIT_SOC2_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC2   */
} ADCINTSOCSEL0_BIT_SOC2;

#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL0_ALL_SOC2_Pos)
#define ADCINTSOCSEL0_ALL_SOC2_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL0_ALL_SOC2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL0   SOC3
 *  @access     ADC->ADCINTSOCSEL0.bit.SOC3
 *  @brief      Select ADC interrupt source for SOC3. This Field will overrides the TRIGSEL Field in the ADCSOC3CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC3.
 */
#define ADCINTSOCSEL0_ALL_SOC3_Pos (15)
#define ADCINTSOCSEL0_ALL_SOC3_Msk (0x1FUL << ADCINTSOCSEL0_ALL_SOC3_Pos)

typedef enum
{
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC3    */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC3   */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC3   */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC3   */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC3   */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC3   */
    ADCINTSOCSEL0_BIT_SOC3_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC3   */
} ADCINTSOCSEL0_BIT_SOC3;

#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL0_ALL_SOC3_Pos)
#define ADCINTSOCSEL0_ALL_SOC3_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL0_ALL_SOC3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL0   SOC4
 *  @access     ADC->ADCINTSOCSEL0.bit.SOC4
 *  @brief      Select ADC interrupt source for SOC4. This Field will overrides the TRIGSEL Field in the ADCSOC4CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC4.
 */
#define ADCINTSOCSEL0_ALL_SOC4_Pos (20)
#define ADCINTSOCSEL0_ALL_SOC4_Msk (0x1FUL << ADCINTSOCSEL0_ALL_SOC4_Pos)

typedef enum
{
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC4    */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC4   */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC4   */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC4   */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC4   */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC4   */
    ADCINTSOCSEL0_BIT_SOC4_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC4   */
} ADCINTSOCSEL0_BIT_SOC4;

#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL0_ALL_SOC4_Pos)
#define ADCINTSOCSEL0_ALL_SOC4_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL0_ALL_SOC4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL0   SOC5
 *  @access     ADC->ADCINTSOCSEL0.bit.SOC5
 *  @brief      Select ADC interrupt source for SOC5. This Field will overrides the TRIGSEL Field in the ADCSOC5CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC5.
 */
#define ADCINTSOCSEL0_ALL_SOC5_Pos (25)
#define ADCINTSOCSEL0_ALL_SOC5_Msk (0x1FUL << ADCINTSOCSEL0_ALL_SOC5_Pos)

typedef enum
{
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC5    */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC5   */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC5   */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC5   */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC5   */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC5   */
    ADCINTSOCSEL0_BIT_SOC5_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC5   */
} ADCINTSOCSEL0_BIT_SOC5;

#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL0_ALL_SOC5_Pos)
#define ADCINTSOCSEL0_ALL_SOC5_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL0_ALL_SOC5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL1   SOC6
 *  @access     ADC->ADCINTSOCSEL1.bit.SOC6
 *  @brief      Select ADC interrupt source for SOC6. This Field will overrides the TRIGSEL Field in the ADCSOC6CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC6.
 */
#define ADCINTSOCSEL1_ALL_SOC6_Pos (0)
#define ADCINTSOCSEL1_ALL_SOC6_Msk (0x1FUL << ADCINTSOCSEL1_ALL_SOC6_Pos)

typedef enum
{
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC6    */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC6   */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC6   */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC6   */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC6   */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC6   */
    ADCINTSOCSEL1_BIT_SOC6_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC6   */
} ADCINTSOCSEL1_BIT_SOC6;

#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL1_ALL_SOC6_Pos)
#define ADCINTSOCSEL1_ALL_SOC6_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL1_ALL_SOC6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL1   SOC7
 *  @access     ADC->ADCINTSOCSEL1.bit.SOC7
 *  @brief      Select ADC interrupt source for SOC7. This Field will overrides the TRIGSEL Field in the ADCSOC7CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC7.
 */
#define ADCINTSOCSEL1_ALL_SOC7_Pos (5)
#define ADCINTSOCSEL1_ALL_SOC7_Msk (0x1FUL << ADCINTSOCSEL1_ALL_SOC7_Pos)

typedef enum
{
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC7    */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC7   */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC7   */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC7   */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC7   */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC7   */
    ADCINTSOCSEL1_BIT_SOC7_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC7   */
} ADCINTSOCSEL1_BIT_SOC7;

#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL1_ALL_SOC7_Pos)
#define ADCINTSOCSEL1_ALL_SOC7_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL1_ALL_SOC7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL1   SOC8
 *  @access     ADC->ADCINTSOCSEL1.bit.SOC8
 *  @brief      Select ADC interrupt source for SOC8. This Field will overrides the TRIGSEL Field in the ADCSOC8CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC8.
 */
#define ADCINTSOCSEL1_ALL_SOC8_Pos (10)
#define ADCINTSOCSEL1_ALL_SOC8_Msk (0x1FUL << ADCINTSOCSEL1_ALL_SOC8_Pos)

typedef enum
{
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC8    */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC8   */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC8   */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC8   */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC8   */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC8   */
    ADCINTSOCSEL1_BIT_SOC8_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC8   */
} ADCINTSOCSEL1_BIT_SOC8;

#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL1_ALL_SOC8_Pos)
#define ADCINTSOCSEL1_ALL_SOC8_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL1_ALL_SOC8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL1   SOC9
 *  @access     ADC->ADCINTSOCSEL1.bit.SOC9
 *  @brief      Select ADC interrupt source for SOC9. This Field will overrides the TRIGSEL Field in the ADCSOC9CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC9.
 */
#define ADCINTSOCSEL1_ALL_SOC9_Pos (15)
#define ADCINTSOCSEL1_ALL_SOC9_Msk (0x1FUL << ADCINTSOCSEL1_ALL_SOC9_Pos)

typedef enum
{
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC9    */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC9   */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC9   */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC9   */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC9   */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC9   */
    ADCINTSOCSEL1_BIT_SOC9_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC9   */
} ADCINTSOCSEL1_BIT_SOC9;

#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL1_ALL_SOC9_Pos)
#define ADCINTSOCSEL1_ALL_SOC9_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL1_ALL_SOC9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL1   SOC10
 *  @access     ADC->ADCINTSOCSEL1.bit.SOC10
 *  @brief      Select ADC interrupt source for SOC10. This Field will overrides the TRIGSEL Field in the ADCSOC10CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC10.
 */
#define ADCINTSOCSEL1_ALL_SOC10_Pos (20)
#define ADCINTSOCSEL1_ALL_SOC10_Msk (0x1FUL << ADCINTSOCSEL1_ALL_SOC10_Pos)

typedef enum
{
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC10    */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC10   */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC10   */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC10   */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC10   */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC10   */
    ADCINTSOCSEL1_BIT_SOC10_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC10   */
} ADCINTSOCSEL1_BIT_SOC10;

#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL1_ALL_SOC10_Pos)
#define ADCINTSOCSEL1_ALL_SOC10_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL1_ALL_SOC10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL1   SOC11
 *  @access     ADC->ADCINTSOCSEL1.bit.SOC11
 *  @brief      Select ADC interrupt source for SOC11. This Field will overrides the TRIGSEL Field in the ADCSOC11CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC11.
 */
#define ADCINTSOCSEL1_ALL_SOC11_Pos (25)
#define ADCINTSOCSEL1_ALL_SOC11_Msk (0x1FUL << ADCINTSOCSEL1_ALL_SOC11_Pos)

typedef enum
{
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC11    */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC11   */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC11   */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC11   */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC11   */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC11   */
    ADCINTSOCSEL1_BIT_SOC11_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC11   */
} ADCINTSOCSEL1_BIT_SOC11;

#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL1_ALL_SOC11_Pos)
#define ADCINTSOCSEL1_ALL_SOC11_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL1_ALL_SOC11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC0
 *  @access     ADC->ADCSOCFLG.bit.SOC0
 *  @brief      SOC0 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC0_Pos (0)
#define ADCSOCFLG_ALL_SOC0_Msk (0x1UL << ADCSOCFLG_ALL_SOC0_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC0_NO_PENDING        = 0,  /*!< No sample pending for SOC0                                 */
    ADCSOCFLG_BIT_SOC0_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC0   */
} ADCSOCFLG_BIT_SOC0;

#define ADCSOCFLG_ALL_SOC0_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC0_Pos)
#define ADCSOCFLG_ALL_SOC0_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC1
 *  @access     ADC->ADCSOCFLG.bit.SOC1
 *  @brief      SOC1 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC1_Pos (1)
#define ADCSOCFLG_ALL_SOC1_Msk (0x1UL << ADCSOCFLG_ALL_SOC1_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC1_NO_PENDING        = 0,  /*!< No sample pending for SOC1                                 */
    ADCSOCFLG_BIT_SOC1_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC1   */
} ADCSOCFLG_BIT_SOC1;

#define ADCSOCFLG_ALL_SOC1_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC1_Pos)
#define ADCSOCFLG_ALL_SOC1_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC2
 *  @access     ADC->ADCSOCFLG.bit.SOC2
 *  @brief      SOC2 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC2_Pos (2)
#define ADCSOCFLG_ALL_SOC2_Msk (0x1UL << ADCSOCFLG_ALL_SOC2_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC2_NO_PENDING        = 0,  /*!< No sample pending for SOC2                                 */
    ADCSOCFLG_BIT_SOC2_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC2   */
} ADCSOCFLG_BIT_SOC2;

#define ADCSOCFLG_ALL_SOC2_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC2_Pos)
#define ADCSOCFLG_ALL_SOC2_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC3
 *  @access     ADC->ADCSOCFLG.bit.SOC3
 *  @brief      SOC3 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC3_Pos (3)
#define ADCSOCFLG_ALL_SOC3_Msk (0x1UL << ADCSOCFLG_ALL_SOC3_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC3_NO_PENDING        = 0,  /*!< No sample pending for SOC3                                 */
    ADCSOCFLG_BIT_SOC3_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC3   */
} ADCSOCFLG_BIT_SOC3;

#define ADCSOCFLG_ALL_SOC3_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC3_Pos)
#define ADCSOCFLG_ALL_SOC3_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC4
 *  @access     ADC->ADCSOCFLG.bit.SOC4
 *  @brief      SOC4 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC4_Pos (4)
#define ADCSOCFLG_ALL_SOC4_Msk (0x1UL << ADCSOCFLG_ALL_SOC4_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC4_NO_PENDING        = 0,  /*!< No sample pending for SOC4                                 */
    ADCSOCFLG_BIT_SOC4_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC4   */
} ADCSOCFLG_BIT_SOC4;

#define ADCSOCFLG_ALL_SOC4_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC4_Pos)
#define ADCSOCFLG_ALL_SOC4_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC5
 *  @access     ADC->ADCSOCFLG.bit.SOC5
 *  @brief      SOC5 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC5_Pos (5)
#define ADCSOCFLG_ALL_SOC5_Msk (0x1UL << ADCSOCFLG_ALL_SOC5_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC5_NO_PENDING        = 0,  /*!< No sample pending for SOC5                                 */
    ADCSOCFLG_BIT_SOC5_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC5   */
} ADCSOCFLG_BIT_SOC5;

#define ADCSOCFLG_ALL_SOC5_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC5_Pos)
#define ADCSOCFLG_ALL_SOC5_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC6
 *  @access     ADC->ADCSOCFLG.bit.SOC6
 *  @brief      SOC6 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC6_Pos (6)
#define ADCSOCFLG_ALL_SOC6_Msk (0x1UL << ADCSOCFLG_ALL_SOC6_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC6_NO_PENDING        = 0,  /*!< No sample pending for SOC6                                 */
    ADCSOCFLG_BIT_SOC6_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC6   */
} ADCSOCFLG_BIT_SOC6;

#define ADCSOCFLG_ALL_SOC6_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC6_Pos)
#define ADCSOCFLG_ALL_SOC6_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC7
 *  @access     ADC->ADCSOCFLG.bit.SOC7
 *  @brief      SOC7 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC7_Pos (7)
#define ADCSOCFLG_ALL_SOC7_Msk (0x1UL << ADCSOCFLG_ALL_SOC7_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC7_NO_PENDING        = 0,  /*!< No sample pending for SOC7                                 */
    ADCSOCFLG_BIT_SOC7_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC7   */
} ADCSOCFLG_BIT_SOC7;

#define ADCSOCFLG_ALL_SOC7_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC7_Pos)
#define ADCSOCFLG_ALL_SOC7_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC8
 *  @access     ADC->ADCSOCFLG.bit.SOC8
 *  @brief      SOC8 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC8_Pos (8)
#define ADCSOCFLG_ALL_SOC8_Msk (0x1UL << ADCSOCFLG_ALL_SOC8_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC8_NO_PENDING        = 0,  /*!< No sample pending for SOC8                                 */
    ADCSOCFLG_BIT_SOC8_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC8   */
} ADCSOCFLG_BIT_SOC8;

#define ADCSOCFLG_ALL_SOC8_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC8_Pos)
#define ADCSOCFLG_ALL_SOC8_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC9
 *  @access     ADC->ADCSOCFLG.bit.SOC9
 *  @brief      SOC9 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC9_Pos (9)
#define ADCSOCFLG_ALL_SOC9_Msk (0x1UL << ADCSOCFLG_ALL_SOC9_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC9_NO_PENDING        = 0,  /*!< No sample pending for SOC9                                 */
    ADCSOCFLG_BIT_SOC9_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC9   */
} ADCSOCFLG_BIT_SOC9;

#define ADCSOCFLG_ALL_SOC9_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC9_Pos)
#define ADCSOCFLG_ALL_SOC9_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC10
 *  @access     ADC->ADCSOCFLG.bit.SOC10
 *  @brief      SOC10 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC10_Pos (10)
#define ADCSOCFLG_ALL_SOC10_Msk (0x1UL << ADCSOCFLG_ALL_SOC10_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC10_NO_PENDING        = 0,  /*!< No sample pending for SOC10                                 */
    ADCSOCFLG_BIT_SOC10_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC10   */
} ADCSOCFLG_BIT_SOC10;

#define ADCSOCFLG_ALL_SOC10_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC10_Pos)
#define ADCSOCFLG_ALL_SOC10_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC11
 *  @access     ADC->ADCSOCFLG.bit.SOC11
 *  @brief      SOC11 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC11_Pos (11)
#define ADCSOCFLG_ALL_SOC11_Msk (0x1UL << ADCSOCFLG_ALL_SOC11_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC11_NO_PENDING        = 0,  /*!< No sample pending for SOC11                                 */
    ADCSOCFLG_BIT_SOC11_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC11   */
} ADCSOCFLG_BIT_SOC11;

#define ADCSOCFLG_ALL_SOC11_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC11_Pos)
#define ADCSOCFLG_ALL_SOC11_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC12
 *  @access     ADC->ADCSOCFLG.bit.SOC12
 *  @brief      SOC12 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC12_Pos (12)
#define ADCSOCFLG_ALL_SOC12_Msk (0x1UL << ADCSOCFLG_ALL_SOC12_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC12_NO_PENDING        = 0,  /*!< No sample pending for SOC12                                 */
    ADCSOCFLG_BIT_SOC12_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC12   */
} ADCSOCFLG_BIT_SOC12;

#define ADCSOCFLG_ALL_SOC12_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC12_Pos)
#define ADCSOCFLG_ALL_SOC12_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC13
 *  @access     ADC->ADCSOCFLG.bit.SOC13
 *  @brief      SOC13 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC13_Pos (13)
#define ADCSOCFLG_ALL_SOC13_Msk (0x1UL << ADCSOCFLG_ALL_SOC13_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC13_NO_PENDING        = 0,  /*!< No sample pending for SOC13                                 */
    ADCSOCFLG_BIT_SOC13_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC13   */
} ADCSOCFLG_BIT_SOC13;

#define ADCSOCFLG_ALL_SOC13_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC13_Pos)
#define ADCSOCFLG_ALL_SOC13_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC14
 *  @access     ADC->ADCSOCFLG.bit.SOC14
 *  @brief      SOC14 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC14_Pos (14)
#define ADCSOCFLG_ALL_SOC14_Msk (0x1UL << ADCSOCFLG_ALL_SOC14_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC14_NO_PENDING        = 0,  /*!< No sample pending for SOC14                                 */
    ADCSOCFLG_BIT_SOC14_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC14   */
} ADCSOCFLG_BIT_SOC14;

#define ADCSOCFLG_ALL_SOC14_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC14_Pos)
#define ADCSOCFLG_ALL_SOC14_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFLG       SOC15
 *  @access     ADC->ADCSOCFLG.bit.SOC15
 *  @brief      SOC15 (State-machine of Conversion) Flag. This indicates state of each SOC. This bit will be automatically cleared when respective SOC0 conversion is started.
 *              If this bit receive both a request to set and a request to clear simultaneously, the bit will be set and ignore the request to clear. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether this bit was previously set or not.
 */
#define ADCSOCFLG_ALL_SOC15_Pos (15)
#define ADCSOCFLG_ALL_SOC15_Msk (0x1UL << ADCSOCFLG_ALL_SOC15_Pos)

typedef enum
{
    ADCSOCFLG_BIT_SOC15_NO_PENDING        = 0,  /*!< No sample pending for SOC15                                 */
    ADCSOCFLG_BIT_SOC15_TRIG_RECEIVED     = 1,  /*!< Trigger has been received and sample is pending for SOC15   */
} ADCSOCFLG_BIT_SOC15;

#define ADCSOCFLG_ALL_SOC15_NO_PENDING        ((0x0UL) << ADCSOCFLG_ALL_SOC15_Pos)
#define ADCSOCFLG_ALL_SOC15_TRIG_RECEIVED     ((0x1UL) << ADCSOCFLG_ALL_SOC15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC0
 *  @access     ADC->ADCSOCFRC.bit.SOC0
 *  @brief      SOC0 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC0_Pos (0)
#define ADCSOCFRC_ALL_SOC0_Msk (0x1UL << ADCSOCFRC_ALL_SOC0_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC0_NO_EFFECT         = 0,  /*!< No action                                           */
    ADCSOCFRC_BIT_SOC0_FORCE_CONVERT     = 1,  /*!< Force High to SOC0 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC0;

#define ADCSOCFRC_ALL_SOC0_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC0_Pos)
#define ADCSOCFRC_ALL_SOC0_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC1
 *  @access     ADC->ADCSOCFRC.bit.SOC1
 *  @brief      SOC1 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC1_Pos (1)
#define ADCSOCFRC_ALL_SOC1_Msk (0x1UL << ADCSOCFRC_ALL_SOC1_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC1_NO_EFFECT         = 0,  /*!< No action                                           */
    ADCSOCFRC_BIT_SOC1_FORCE_CONVERT     = 1,  /*!< Force High to SOC1 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC1;

#define ADCSOCFRC_ALL_SOC1_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC1_Pos)
#define ADCSOCFRC_ALL_SOC1_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC2
 *  @access     ADC->ADCSOCFRC.bit.SOC2
 *  @brief      SOC2 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC2_Pos (2)
#define ADCSOCFRC_ALL_SOC2_Msk (0x1UL << ADCSOCFRC_ALL_SOC2_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC2_NO_EFFECT         = 0,  /*!< No action                                           */
    ADCSOCFRC_BIT_SOC2_FORCE_CONVERT     = 1,  /*!< Force High to SOC2 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC2;

#define ADCSOCFRC_ALL_SOC2_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC2_Pos)
#define ADCSOCFRC_ALL_SOC2_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC3
 *  @access     ADC->ADCSOCFRC.bit.SOC3
 *  @brief      SOC3 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC3_Pos (3)
#define ADCSOCFRC_ALL_SOC3_Msk (0x1UL << ADCSOCFRC_ALL_SOC3_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC3_NO_EFFECT         = 0,  /*!< No action                                           */
    ADCSOCFRC_BIT_SOC3_FORCE_CONVERT     = 1,  /*!< Force High to SOC3 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC3;

#define ADCSOCFRC_ALL_SOC3_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC3_Pos)
#define ADCSOCFRC_ALL_SOC3_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC4
 *  @access     ADC->ADCSOCFRC.bit.SOC4
 *  @brief      SOC4 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC4_Pos (4)
#define ADCSOCFRC_ALL_SOC4_Msk (0x1UL << ADCSOCFRC_ALL_SOC4_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC4_NO_EFFECT         = 0,  /*!< No action                                           */
    ADCSOCFRC_BIT_SOC4_FORCE_CONVERT     = 1,  /*!< Force High to SOC4 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC4;

#define ADCSOCFRC_ALL_SOC4_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC4_Pos)
#define ADCSOCFRC_ALL_SOC4_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC5
 *  @access     ADC->ADCSOCFRC.bit.SOC5
 *  @brief      SOC5 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC5_Pos (5)
#define ADCSOCFRC_ALL_SOC5_Msk (0x1UL << ADCSOCFRC_ALL_SOC5_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC5_NO_EFFECT         = 0,  /*!< No action                                           */
    ADCSOCFRC_BIT_SOC5_FORCE_CONVERT     = 1,  /*!< Force High to SOC5 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC5;

#define ADCSOCFRC_ALL_SOC5_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC5_Pos)
#define ADCSOCFRC_ALL_SOC5_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC6
 *  @access     ADC->ADCSOCFRC.bit.SOC6
 *  @brief      SOC6 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC6_Pos (6)
#define ADCSOCFRC_ALL_SOC6_Msk (0x1UL << ADCSOCFRC_ALL_SOC6_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC6_NO_EFFECT         = 0,  /*!< No action.                                          */
    ADCSOCFRC_BIT_SOC6_FORCE_CONVERT     = 1,  /*!< Force High to SOC6 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC6;

#define ADCSOCFRC_ALL_SOC6_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC6_Pos)
#define ADCSOCFRC_ALL_SOC6_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC7
 *  @access     ADC->ADCSOCFRC.bit.SOC7
 *  @brief      SOC7 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC7_Pos (7)
#define ADCSOCFRC_ALL_SOC7_Msk (0x1UL << ADCSOCFRC_ALL_SOC7_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC7_NO_EFFECT         = 0,  /*!< No action                                             */
    ADCSOCFRC_BIT_SOC7_FORCE_CONVERT     = 1,  /*!< Force High to SOC7 Flag bit in ADCSOCFLG Register.    */
} ADCSOCFRC_BIT_SOC7;

#define ADCSOCFRC_ALL_SOC7_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC7_Pos)
#define ADCSOCFRC_ALL_SOC7_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC8
 *  @access     ADC->ADCSOCFRC.bit.SOC8
 *  @brief      SOC8 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC8_Pos (8)
#define ADCSOCFRC_ALL_SOC8_Msk (0x1UL << ADCSOCFRC_ALL_SOC8_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC8_NO_EFFECT         = 0,  /*!< No action                                           */
    ADCSOCFRC_BIT_SOC8_FORCE_CONVERT     = 1,  /*!< Force High to SOC8 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC8;

#define ADCSOCFRC_ALL_SOC8_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC8_Pos)
#define ADCSOCFRC_ALL_SOC8_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC9
 *  @access     ADC->ADCSOCFRC.bit.SOC9
 *  @brief      SOC9 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC9_Pos (9)
#define ADCSOCFRC_ALL_SOC9_Msk (0x1UL << ADCSOCFRC_ALL_SOC9_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC9_NO_EFFECT         = 0,  /*!< No action                                           */
    ADCSOCFRC_BIT_SOC9_FORCE_CONVERT     = 1,  /*!< Force High to SOC9 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC9;

#define ADCSOCFRC_ALL_SOC9_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC9_Pos)
#define ADCSOCFRC_ALL_SOC9_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC10
 *  @access     ADC->ADCSOCFRC.bit.SOC10
 *  @brief      SOC10 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC10_Pos (10)
#define ADCSOCFRC_ALL_SOC10_Msk (0x1UL << ADCSOCFRC_ALL_SOC10_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC10_NO_EFFECT         = 0,  /*!< No action.                                             */
    ADCSOCFRC_BIT_SOC10_FORCE_CONVERT     = 1,  /*!< Force High to SOC10 Flag bit in ADCSOCFLG Register.    */
} ADCSOCFRC_BIT_SOC10;

#define ADCSOCFRC_ALL_SOC10_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC10_Pos)
#define ADCSOCFRC_ALL_SOC10_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC11
 *  @access     ADC->ADCSOCFRC.bit.SOC11
 *  @brief      SOC11 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC11_Pos (11)
#define ADCSOCFRC_ALL_SOC11_Msk (0x1UL << ADCSOCFRC_ALL_SOC11_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC11_NO_EFFECT         = 0,  /*!< No action                                            */
    ADCSOCFRC_BIT_SOC11_FORCE_CONVERT     = 1,  /*!< Force High to SOC11 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC11;

#define ADCSOCFRC_ALL_SOC11_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC11_Pos)
#define ADCSOCFRC_ALL_SOC11_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC12
 *  @access     ADC->ADCSOCFRC.bit.SOC12
 *  @brief      SOC12 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC12_Pos (12)
#define ADCSOCFRC_ALL_SOC12_Msk (0x1UL << ADCSOCFRC_ALL_SOC12_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC12_NO_EFFECT         = 0,  /*!< No action                                            */
    ADCSOCFRC_BIT_SOC12_FORCE_CONVERT     = 1,  /*!< Force High to SOC12 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC12;

#define ADCSOCFRC_ALL_SOC12_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC12_Pos)
#define ADCSOCFRC_ALL_SOC12_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC13
 *  @access     ADC->ADCSOCFRC.bit.SOC13
 *  @brief      SOC13 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC13_Pos (13)
#define ADCSOCFRC_ALL_SOC13_Msk (0x1UL << ADCSOCFRC_ALL_SOC13_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC13_NO_EFFECT         = 0,  /*!< No action                                            */
    ADCSOCFRC_BIT_SOC13_FORCE_CONVERT     = 1,  /*!< Force High to SOC13 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC13;

#define ADCSOCFRC_ALL_SOC13_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC13_Pos)
#define ADCSOCFRC_ALL_SOC13_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC14
 *  @access     ADC->ADCSOCFRC.bit.SOC14
 *  @brief      SOC14 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC14_Pos (14)
#define ADCSOCFRC_ALL_SOC14_Msk (0x1UL << ADCSOCFRC_ALL_SOC14_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC14_NO_EFFECT         = 0,  /*!< No action                                            */
    ADCSOCFRC_BIT_SOC14_FORCE_CONVERT     = 1,  /*!< Force High to SOC14 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC14;

#define ADCSOCFRC_ALL_SOC14_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC14_Pos)
#define ADCSOCFRC_ALL_SOC14_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCFRC       SOC15
 *  @access     ADC->ADCSOCFRC.bit.SOC15
 *  @brief      SOC15 (State-machine of Conversion) Force Flag. This can be used to initialize a software initiated conversion. If ADCSOCFLG Register receive both a request to set from software and a request to clear from hardware simultaneously, then software has priority and ADCSOCFLG will be set. In this case, the overflow bit in the ADCSOCOVF Register will not be affected regardless of whether ADCSOCFLG bit was previously set or not.
 */
#define ADCSOCFRC_ALL_SOC15_Pos (15)
#define ADCSOCFRC_ALL_SOC15_Msk (0x1UL << ADCSOCFRC_ALL_SOC15_Pos)

typedef enum
{
    ADCSOCFRC_BIT_SOC15_NO_EFFECT         = 0,  /*!< No action                                            */
    ADCSOCFRC_BIT_SOC15_FORCE_CONVERT     = 1,  /*!< Force High to SOC15 Flag bit in ADCSOCFLG Register   */
} ADCSOCFRC_BIT_SOC15;

#define ADCSOCFRC_ALL_SOC15_NO_EFFECT         ((0x0UL) << ADCSOCFRC_ALL_SOC15_Pos)
#define ADCSOCFRC_ALL_SOC15_FORCE_CONVERT     ((0x1UL) << ADCSOCFRC_ALL_SOC15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC0
 *  @access     ADC->ADCSOCOVF.bit.SOC0
 *  @brief      SOC0 (State-machine of Conversion) Overflow Flag. This indicates an SOC0 event was generated while an existing SOC0 event was already pending. This overflow flag can't stop SOC0 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC0_Pos (0)
#define ADCSOCOVF_ALL_SOC0_Msk (0x1UL << ADCSOCOVF_ALL_SOC0_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC0_NOT_OCCUR     = 0,  /*!< No SOC0 event overflow   */
    ADCSOCOVF_BIT_SOC0_OCCUR         = 1,  /*!< SOC0 event overflow      */
} ADCSOCOVF_BIT_SOC0;

#define ADCSOCOVF_ALL_SOC0_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC0_Pos)
#define ADCSOCOVF_ALL_SOC0_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC1
 *  @access     ADC->ADCSOCOVF.bit.SOC1
 *  @brief      SOC1 (State-machine of Conversion) Overflow Flag. This indicates an SOC1 event was generated while an existing SOC1 event was already pending. This overflow flag can't stop SOC1 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC1_Pos (1)
#define ADCSOCOVF_ALL_SOC1_Msk (0x1UL << ADCSOCOVF_ALL_SOC1_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC1_NOT_OCCUR     = 0,  /*!< No SOC1 event overflow   */
    ADCSOCOVF_BIT_SOC1_OCCUR         = 1,  /*!< SOC1 event overflow      */
} ADCSOCOVF_BIT_SOC1;

#define ADCSOCOVF_ALL_SOC1_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC1_Pos)
#define ADCSOCOVF_ALL_SOC1_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC2
 *  @access     ADC->ADCSOCOVF.bit.SOC2
 *  @brief      SOC2 (State-machine of Conversion) Overflow Flag. This indicates an SOC2 event was generated while an existing SOC2 event was already pending. This overflow flag can't stop SOC2 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC2_Pos (2)
#define ADCSOCOVF_ALL_SOC2_Msk (0x1UL << ADCSOCOVF_ALL_SOC2_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC2_NOT_OCCUR     = 0,  /*!< No SOC2 event overflow   */
    ADCSOCOVF_BIT_SOC2_OCCUR         = 1,  /*!< SOC2 event overflow      */
} ADCSOCOVF_BIT_SOC2;

#define ADCSOCOVF_ALL_SOC2_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC2_Pos)
#define ADCSOCOVF_ALL_SOC2_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC3
 *  @access     ADC->ADCSOCOVF.bit.SOC3
 *  @brief      SOC3 (State-machine of Conversion) Overflow Flag. This indicates an SOC3 event was generated while an existing SOC3 event was already pending. This overflow flag can't stop SOC3 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC3_Pos (3)
#define ADCSOCOVF_ALL_SOC3_Msk (0x1UL << ADCSOCOVF_ALL_SOC3_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC3_NOT_OCCUR     = 0,  /*!< No SOC3 event overflow   */
    ADCSOCOVF_BIT_SOC3_OCCUR         = 1,  /*!< SOC3 event overflow      */
} ADCSOCOVF_BIT_SOC3;

#define ADCSOCOVF_ALL_SOC3_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC3_Pos)
#define ADCSOCOVF_ALL_SOC3_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC4
 *  @access     ADC->ADCSOCOVF.bit.SOC4
 *  @brief      SOC4 (State-machine of Conversion) Overflow Flag. This indicates an SOC4 event was generated while an existing SOC4 event was already pending. This overflow flag can't stop SOC4 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC4_Pos (4)
#define ADCSOCOVF_ALL_SOC4_Msk (0x1UL << ADCSOCOVF_ALL_SOC4_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC4_NOT_OCCUR     = 0,  /*!< No SOC4 event overflow   */
    ADCSOCOVF_BIT_SOC4_OCCUR         = 1,  /*!< SOC4 event overflow      */
} ADCSOCOVF_BIT_SOC4;

#define ADCSOCOVF_ALL_SOC4_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC4_Pos)
#define ADCSOCOVF_ALL_SOC4_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC5
 *  @access     ADC->ADCSOCOVF.bit.SOC5
 *  @brief      SOC5 (State-machine of Conversion) Overflow Flag. This indicates an SOC5 event was generated while an existing SOC5 event was already pending. This overflow flag can't stop SOC5 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC5_Pos (5)
#define ADCSOCOVF_ALL_SOC5_Msk (0x1UL << ADCSOCOVF_ALL_SOC5_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC5_NOT_OCCUR     = 0,  /*!< No SOC5 event overflow   */
    ADCSOCOVF_BIT_SOC5_OCCUR         = 1,  /*!< SOC5 event overflow      */
} ADCSOCOVF_BIT_SOC5;

#define ADCSOCOVF_ALL_SOC5_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC5_Pos)
#define ADCSOCOVF_ALL_SOC5_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC6
 *  @access     ADC->ADCSOCOVF.bit.SOC6
 *  @brief      SOC6 (State-machine of Conversion) Overflow Flag. This indicates an SOC6 event was generated while an existing SOC6 event was already pending. This overflow flag can't stop SOC6 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC6_Pos (6)
#define ADCSOCOVF_ALL_SOC6_Msk (0x1UL << ADCSOCOVF_ALL_SOC6_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC6_NOT_OCCUR     = 0,  /*!< No SOC6 event overflow   */
    ADCSOCOVF_BIT_SOC6_OCCUR         = 1,  /*!< SOC6 event overflow      */
} ADCSOCOVF_BIT_SOC6;

#define ADCSOCOVF_ALL_SOC6_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC6_Pos)
#define ADCSOCOVF_ALL_SOC6_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC7
 *  @access     ADC->ADCSOCOVF.bit.SOC7
 *  @brief      SOC7 (State-machine of Conversion) Overflow Flag. This indicates an SOC7 event was generated while an existing SOC7 event was already pending. This overflow flag can't stop SOC7 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC7_Pos (7)
#define ADCSOCOVF_ALL_SOC7_Msk (0x1UL << ADCSOCOVF_ALL_SOC7_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC7_NOT_OCCUR     = 0,  /*!< No SOC7 event overflow   */
    ADCSOCOVF_BIT_SOC7_OCCUR         = 1,  /*!< SOC7 event overflow      */
} ADCSOCOVF_BIT_SOC7;

#define ADCSOCOVF_ALL_SOC7_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC7_Pos)
#define ADCSOCOVF_ALL_SOC7_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC8
 *  @access     ADC->ADCSOCOVF.bit.SOC8
 *  @brief      SOC8 (State-machine of Conversion) Overflow Flag. This indicates an SOC8 event was generated while an existing SOC8 event was already pending. This overflow flag can't stop SOC8 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC8_Pos (8)
#define ADCSOCOVF_ALL_SOC8_Msk (0x1UL << ADCSOCOVF_ALL_SOC8_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC8_NOT_OCCUR     = 0,  /*!< No SOC8 event overflow   */
    ADCSOCOVF_BIT_SOC8_OCCUR         = 1,  /*!< SOC8 event overflow      */
} ADCSOCOVF_BIT_SOC8;

#define ADCSOCOVF_ALL_SOC8_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC8_Pos)
#define ADCSOCOVF_ALL_SOC8_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC9
 *  @access     ADC->ADCSOCOVF.bit.SOC9
 *  @brief      SOC9 (State-machine of Conversion) Overflow Flag. This indicates an SOC9 event was generated while an existing SOC9 event was already pending. This overflow flag can't stop SOC9 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC9_Pos (9)
#define ADCSOCOVF_ALL_SOC9_Msk (0x1UL << ADCSOCOVF_ALL_SOC9_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC9_NOT_OCCUR     = 0,  /*!< No SOC9 event overflow   */
    ADCSOCOVF_BIT_SOC9_OCCUR         = 1,  /*!< SOC9 event overflow      */
} ADCSOCOVF_BIT_SOC9;

#define ADCSOCOVF_ALL_SOC9_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC9_Pos)
#define ADCSOCOVF_ALL_SOC9_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC10
 *  @access     ADC->ADCSOCOVF.bit.SOC10
 *  @brief      SOC10 (State-machine of Conversion) Overflow Flag. This indicates an SOC10 event was generated while an existing SOC10 event was already pending. This overflow flag can't stop SOC10 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC10_Pos (10)
#define ADCSOCOVF_ALL_SOC10_Msk (0x1UL << ADCSOCOVF_ALL_SOC10_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC10_NOT_OCCUR     = 0,  /*!< No SOC10 event overflow   */
    ADCSOCOVF_BIT_SOC10_OCCUR         = 1,  /*!< SOC10 event overflow      */
} ADCSOCOVF_BIT_SOC10;

#define ADCSOCOVF_ALL_SOC10_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC10_Pos)
#define ADCSOCOVF_ALL_SOC10_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC11
 *  @access     ADC->ADCSOCOVF.bit.SOC11
 *  @brief      SOC11 (State-machine of Conversion) Overflow Flag. This indicates an SOC11 event was generated while an existing SOC11 event was already pending. This overflow flag can't stop SOC11 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC11_Pos (11)
#define ADCSOCOVF_ALL_SOC11_Msk (0x1UL << ADCSOCOVF_ALL_SOC11_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC11_NOT_OCCUR     = 0,  /*!< No SOC11 event overflow   */
    ADCSOCOVF_BIT_SOC11_OCCUR         = 1,  /*!< SOC11 event overflow      */
} ADCSOCOVF_BIT_SOC11;

#define ADCSOCOVF_ALL_SOC11_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC11_Pos)
#define ADCSOCOVF_ALL_SOC11_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC12
 *  @access     ADC->ADCSOCOVF.bit.SOC12
 *  @brief      SOC12 (State-machine of Conversion) Overflow Flag. This indicates an SOC12 event was generated while an existing SOC12 event was already pending. This overflow flag can't stop SOC12 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC12_Pos (12)
#define ADCSOCOVF_ALL_SOC12_Msk (0x1UL << ADCSOCOVF_ALL_SOC12_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC12_NOT_OCCUR     = 0,  /*!< No SOC12 event overflow   */
    ADCSOCOVF_BIT_SOC12_OCCUR         = 1,  /*!< SOC12 event overflow      */
} ADCSOCOVF_BIT_SOC12;

#define ADCSOCOVF_ALL_SOC12_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC12_Pos)
#define ADCSOCOVF_ALL_SOC12_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC13
 *  @access     ADC->ADCSOCOVF.bit.SOC13
 *  @brief      SOC13 (State-machine of Conversion) Overflow Flag. This indicates an SOC13 event was generated while an existing SOC13 event was already pending. This overflow flag can't stop SOC13 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC13_Pos (13)
#define ADCSOCOVF_ALL_SOC13_Msk (0x1UL << ADCSOCOVF_ALL_SOC13_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC13_NOT_OCCUR     = 0,  /*!< No SOC13 event overflow   */
    ADCSOCOVF_BIT_SOC13_OCCUR         = 1,  /*!< SOC13 event overflow      */
} ADCSOCOVF_BIT_SOC13;

#define ADCSOCOVF_ALL_SOC13_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC13_Pos)
#define ADCSOCOVF_ALL_SOC13_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC14
 *  @access     ADC->ADCSOCOVF.bit.SOC14
 *  @brief      SOC14 (State-machine of Conversion) Overflow Flag. This indicates an SOC14 event was generated while an existing SOC14 event was already pending. This overflow flag can't stop SOC14 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC14_Pos (14)
#define ADCSOCOVF_ALL_SOC14_Msk (0x1UL << ADCSOCOVF_ALL_SOC14_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC14_NOT_OCCUR     = 0,  /*!< No SOC14 event overflow   */
    ADCSOCOVF_BIT_SOC14_OCCUR         = 1,  /*!< SOC14 event overflow      */
} ADCSOCOVF_BIT_SOC14;

#define ADCSOCOVF_ALL_SOC14_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC14_Pos)
#define ADCSOCOVF_ALL_SOC14_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVF       SOC15
 *  @access     ADC->ADCSOCOVF.bit.SOC15
 *  @brief      SOC15 (State-machine of Conversion) Overflow Flag. This indicates an SOC15 event was generated while an existing SOC15 event was already pending. This overflow flag can't stop SOC15 events from being processing. It just show that a trigger was missed.
 */
#define ADCSOCOVF_ALL_SOC15_Pos (15)
#define ADCSOCOVF_ALL_SOC15_Msk (0x1UL << ADCSOCOVF_ALL_SOC15_Pos)

typedef enum
{
    ADCSOCOVF_BIT_SOC15_NOT_OCCUR     = 0,  /*!< No SOC15 event overflow   */
    ADCSOCOVF_BIT_SOC15_OCCUR         = 1,  /*!< SOC15 event overflow      */
} ADCSOCOVF_BIT_SOC15;

#define ADCSOCOVF_ALL_SOC15_NOT_OCCUR     ((0x0UL) << ADCSOCOVF_ALL_SOC15_Pos)
#define ADCSOCOVF_ALL_SOC15_OCCUR         ((0x1UL) << ADCSOCOVF_ALL_SOC15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC0
 *  @access     ADC->ADCSOCOVFC.bit.SOC0
 *  @brief      Clear SOC0 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC0 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC0_Pos (0)
#define ADCSOCOVFC_ALL_SOC0_Msk (0x1UL << ADCSOCOVFC_ALL_SOC0_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC0_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC0_CLEAR_FLAG     = 1,  /*!< Clear SOC0 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC0;

#define ADCSOCOVFC_ALL_SOC0_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC0_Pos)
#define ADCSOCOVFC_ALL_SOC0_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC1
 *  @access     ADC->ADCSOCOVFC.bit.SOC1
 *  @brief      Clear SOC1 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC1 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC1_Pos (1)
#define ADCSOCOVFC_ALL_SOC1_Msk (0x1UL << ADCSOCOVFC_ALL_SOC1_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC1_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC1_CLEAR_FLAG     = 1,  /*!< Clear SOC1 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC1;

#define ADCSOCOVFC_ALL_SOC1_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC1_Pos)
#define ADCSOCOVFC_ALL_SOC1_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC2
 *  @access     ADC->ADCSOCOVFC.bit.SOC2
 *  @brief      Clear SOC2 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC2 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC2_Pos (2)
#define ADCSOCOVFC_ALL_SOC2_Msk (0x1UL << ADCSOCOVFC_ALL_SOC2_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC2_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC2_CLEAR_FLAG     = 1,  /*!< Clear SOC2 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC2;

#define ADCSOCOVFC_ALL_SOC2_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC2_Pos)
#define ADCSOCOVFC_ALL_SOC2_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC3
 *  @access     ADC->ADCSOCOVFC.bit.SOC3
 *  @brief      Clear SOC3 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC3 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC3_Pos (3)
#define ADCSOCOVFC_ALL_SOC3_Msk (0x1UL << ADCSOCOVFC_ALL_SOC3_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC3_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC3_CLEAR_FLAG     = 1,  /*!< Clear SOC3 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC3;

#define ADCSOCOVFC_ALL_SOC3_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC3_Pos)
#define ADCSOCOVFC_ALL_SOC3_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC4
 *  @access     ADC->ADCSOCOVFC.bit.SOC4
 *  @brief      Clear SOC4 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC4 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC4_Pos (4)
#define ADCSOCOVFC_ALL_SOC4_Msk (0x1UL << ADCSOCOVFC_ALL_SOC4_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC4_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC4_CLEAR_FLAG     = 1,  /*!< Clear SOC4 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC4;

#define ADCSOCOVFC_ALL_SOC4_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC4_Pos)
#define ADCSOCOVFC_ALL_SOC4_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC5
 *  @access     ADC->ADCSOCOVFC.bit.SOC5
 *  @brief      Clear SOC5 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC5 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC5_Pos (5)
#define ADCSOCOVFC_ALL_SOC5_Msk (0x1UL << ADCSOCOVFC_ALL_SOC5_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC5_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC5_CLEAR_FLAG     = 1,  /*!< Clear SOC5 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC5;

#define ADCSOCOVFC_ALL_SOC5_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC5_Pos)
#define ADCSOCOVFC_ALL_SOC5_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC6
 *  @access     ADC->ADCSOCOVFC.bit.SOC6
 *  @brief      Clear SOC6 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC6 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC6_Pos (6)
#define ADCSOCOVFC_ALL_SOC6_Msk (0x1UL << ADCSOCOVFC_ALL_SOC6_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC6_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC6_CLEAR_FLAG     = 1,  /*!< Clear SOC6 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC6;

#define ADCSOCOVFC_ALL_SOC6_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC6_Pos)
#define ADCSOCOVFC_ALL_SOC6_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC7
 *  @access     ADC->ADCSOCOVFC.bit.SOC7
 *  @brief      Clear SOC7 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC7 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC7_Pos (7)
#define ADCSOCOVFC_ALL_SOC7_Msk (0x1UL << ADCSOCOVFC_ALL_SOC7_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC7_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC7_CLEAR_FLAG     = 1,  /*!< Clear SOC7 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC7;

#define ADCSOCOVFC_ALL_SOC7_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC7_Pos)
#define ADCSOCOVFC_ALL_SOC7_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC8
 *  @access     ADC->ADCSOCOVFC.bit.SOC8
 *  @brief      Clear SOC8 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC8 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC8_Pos (8)
#define ADCSOCOVFC_ALL_SOC8_Msk (0x1UL << ADCSOCOVFC_ALL_SOC8_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC8_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC8_CLEAR_FLAG     = 1,  /*!< Clear SOC8 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC8;

#define ADCSOCOVFC_ALL_SOC8_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC8_Pos)
#define ADCSOCOVFC_ALL_SOC8_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC9
 *  @access     ADC->ADCSOCOVFC.bit.SOC9
 *  @brief      Clear SOC9 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC9 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC9_Pos (9)
#define ADCSOCOVFC_ALL_SOC9_Msk (0x1UL << ADCSOCOVFC_ALL_SOC9_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC9_NO_EFFECT      = 0,  /*!< No clear                   */
    ADCSOCOVFC_BIT_SOC9_CLEAR_FLAG     = 1,  /*!< Clear SOC9 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC9;

#define ADCSOCOVFC_ALL_SOC9_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC9_Pos)
#define ADCSOCOVFC_ALL_SOC9_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC10
 *  @access     ADC->ADCSOCOVFC.bit.SOC10
 *  @brief      Clear SOC10 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC10 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC10_Pos (10)
#define ADCSOCOVFC_ALL_SOC10_Msk (0x1UL << ADCSOCOVFC_ALL_SOC10_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC10_NO_EFFECT      = 0,  /*!< No clear                    */
    ADCSOCOVFC_BIT_SOC10_CLEAR_FLAG     = 1,  /*!< Clear SOC10 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC10;

#define ADCSOCOVFC_ALL_SOC10_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC10_Pos)
#define ADCSOCOVFC_ALL_SOC10_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC11
 *  @access     ADC->ADCSOCOVFC.bit.SOC11
 *  @brief      Clear SOC11 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC11 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC11_Pos (11)
#define ADCSOCOVFC_ALL_SOC11_Msk (0x1UL << ADCSOCOVFC_ALL_SOC11_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC11_NO_EFFECT      = 0,  /*!< No clear                    */
    ADCSOCOVFC_BIT_SOC11_CLEAR_FLAG     = 1,  /*!< Clear SOC11 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC11;

#define ADCSOCOVFC_ALL_SOC11_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC11_Pos)
#define ADCSOCOVFC_ALL_SOC11_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC12
 *  @access     ADC->ADCSOCOVFC.bit.SOC12
 *  @brief      Clear SOC12 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC12 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC12_Pos (12)
#define ADCSOCOVFC_ALL_SOC12_Msk (0x1UL << ADCSOCOVFC_ALL_SOC12_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC12_NO_EFFECT      = 0,  /*!< No clear                    */
    ADCSOCOVFC_BIT_SOC12_CLEAR_FLAG     = 1,  /*!< Clear SOC12 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC12;

#define ADCSOCOVFC_ALL_SOC12_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC12_Pos)
#define ADCSOCOVFC_ALL_SOC12_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC13
 *  @access     ADC->ADCSOCOVFC.bit.SOC13
 *  @brief      Clear SOC13 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC13 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC13_Pos (13)
#define ADCSOCOVFC_ALL_SOC13_Msk (0x1UL << ADCSOCOVFC_ALL_SOC13_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC13_NO_EFFECT      = 0,  /*!< No clear                    */
    ADCSOCOVFC_BIT_SOC13_CLEAR_FLAG     = 1,  /*!< Clear SOC13 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC13;

#define ADCSOCOVFC_ALL_SOC13_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC13_Pos)
#define ADCSOCOVFC_ALL_SOC13_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC14
 *  @access     ADC->ADCSOCOVFC.bit.SOC14
 *  @brief      Clear SOC14 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC14 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC14_Pos (14)
#define ADCSOCOVFC_ALL_SOC14_Msk (0x1UL << ADCSOCOVFC_ALL_SOC14_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC14_NO_EFFECT      = 0,  /*!< No clear                    */
    ADCSOCOVFC_BIT_SOC14_CLEAR_FLAG     = 1,  /*!< Clear SOC14 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC14;

#define ADCSOCOVFC_ALL_SOC14_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC14_Pos)
#define ADCSOCOVFC_ALL_SOC14_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCOVFC      SOC15
 *  @access     ADC->ADCSOCOVFC.bit.SOC15
 *  @brief      Clear SOC15 Overflow Flag
 *              If this bit receive a request to set from software and hardware try to set respective SOC15 overflow bit in ADCSOCOVF Register simultaneously, then hardware has priority and ADCSOCOVF Register will be set.
 */
#define ADCSOCOVFC_ALL_SOC15_Pos (15)
#define ADCSOCOVFC_ALL_SOC15_Msk (0x1UL << ADCSOCOVFC_ALL_SOC15_Pos)

typedef enum
{
    ADCSOCOVFC_BIT_SOC15_NO_EFFECT      = 0,  /*!< No clear                    */
    ADCSOCOVFC_BIT_SOC15_CLEAR_FLAG     = 1,  /*!< Clear SOC15 Overflow Flag   */
} ADCSOCOVFC_BIT_SOC15;

#define ADCSOCOVFC_ALL_SOC15_NO_EFFECT      ((0x0UL) << ADCSOCOVFC_ALL_SOC15_Pos)
#define ADCSOCOVFC_ALL_SOC15_CLEAR_FLAG     ((0x1UL) << ADCSOCOVFC_ALL_SOC15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      CONVCNT
 *  @access     ADC->ADCSOCCTL0.bit.CONVCNT
 *  @brief      Select SOC0 Convert Window Size
 */
#define ADCSOCCTL0_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL0_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL0_ALL_CONVCNT_Pos)

#define ADCSOCCTL0_BIT_CONVCNT

#define ADCSOCCTL0_ALL_CONVCNT_(x) ((x) << ADCSOCCTL0_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      SAMPCNT
 *  @access     ADC->ADCSOCCTL0.bit.SAMPCNT
 *  @brief      Select SOC0 Sample Window Size
 */
#define ADCSOCCTL0_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL0_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL0_ALL_SAMPCNT_Pos)

#define ADCSOCCTL0_BIT_SAMPCNT

#define ADCSOCCTL0_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL0_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      CHSELAN
 *  @access     ADC->ADCSOCCTL0.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC0
 */
#define ADCSOCCTL0_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL0_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL0_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL0_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL0_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL0_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL0_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL0_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL0_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL0_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL0_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL0_BIT_CHSELAN;

#define ADCSOCCTL0_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL0_ALL_CHSELAN_Pos)
#define ADCSOCCTL0_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL0_ALL_CHSELAN_Pos)
#define ADCSOCCTL0_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL0_ALL_CHSELAN_Pos)
#define ADCSOCCTL0_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL0_ALL_CHSELAN_Pos)
#define ADCSOCCTL0_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL0_ALL_CHSELAN_Pos)
#define ADCSOCCTL0_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL0_ALL_CHSELAN_Pos)
#define ADCSOCCTL0_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL0_ALL_CHSELAN_Pos)
#define ADCSOCCTL0_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL0_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      CHSELAP
 *  @access     ADC->ADCSOCCTL0.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC0
 */
#define ADCSOCCTL0_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL0_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL0_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL0_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL0_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL0_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL0_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL0_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL0_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL0_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL0_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL0_BIT_CHSELAP;

#define ADCSOCCTL0_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL0_ALL_CHSELAP_Pos)
#define ADCSOCCTL0_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL0_ALL_CHSELAP_Pos)
#define ADCSOCCTL0_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL0_ALL_CHSELAP_Pos)
#define ADCSOCCTL0_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL0_ALL_CHSELAP_Pos)
#define ADCSOCCTL0_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL0_ALL_CHSELAP_Pos)
#define ADCSOCCTL0_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL0_ALL_CHSELAP_Pos)
#define ADCSOCCTL0_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL0_ALL_CHSELAP_Pos)
#define ADCSOCCTL0_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL0_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      CHSELBN
 *  @access     ADC->ADCSOCCTL0.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC0
 */
#define ADCSOCCTL0_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL0_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL0_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL0_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL0_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL0_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL0_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL0_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL0_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL0_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL0_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL0_BIT_CHSELBN;

#define ADCSOCCTL0_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL0_ALL_CHSELBN_Pos)
#define ADCSOCCTL0_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL0_ALL_CHSELBN_Pos)
#define ADCSOCCTL0_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL0_ALL_CHSELBN_Pos)
#define ADCSOCCTL0_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL0_ALL_CHSELBN_Pos)
#define ADCSOCCTL0_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL0_ALL_CHSELBN_Pos)
#define ADCSOCCTL0_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL0_ALL_CHSELBN_Pos)
#define ADCSOCCTL0_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL0_ALL_CHSELBN_Pos)
#define ADCSOCCTL0_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL0_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      CHSELBP
 *  @access     ADC->ADCSOCCTL0.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC0
 */
#define ADCSOCCTL0_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL0_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL0_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL0_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL0_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL0_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL0_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL0_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL0_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL0_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL0_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL0_BIT_CHSELBP;

#define ADCSOCCTL0_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL0_ALL_CHSELBP_Pos)
#define ADCSOCCTL0_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL0_ALL_CHSELBP_Pos)
#define ADCSOCCTL0_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL0_ALL_CHSELBP_Pos)
#define ADCSOCCTL0_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL0_ALL_CHSELBP_Pos)
#define ADCSOCCTL0_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL0_ALL_CHSELBP_Pos)
#define ADCSOCCTL0_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL0_ALL_CHSELBP_Pos)
#define ADCSOCCTL0_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL0_ALL_CHSELBP_Pos)
#define ADCSOCCTL0_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL0_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      TRIGSEL
 *  @access     ADC->ADCSOCCTL0.bit.TRIGSEL
 *  @brief      Select SOC0 Trigger Source
 *              Configures which trigger source will set SOC0 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC0. This setting can be overridden by the respective SOC0 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL0_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL0_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL0_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL0_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL0_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL0_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL0_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL0_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL0_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL0_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL0_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL0_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL0_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL0_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL0_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL0_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL0_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL0_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL0_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL0_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL0_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL0_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL0_BIT_TRIGSEL;

#define ADCSOCCTL0_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)
#define ADCSOCCTL0_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL0_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      SHBEN
 *  @access     ADC->ADCSOCCTL0.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL0_ALL_SHBEN_Pos (30)
#define ADCSOCCTL0_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL0_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL0_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL0_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL0_BIT_SHBEN;

#define ADCSOCCTL0_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL0_ALL_SHBEN_Pos)
#define ADCSOCCTL0_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL0_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL0      SHAEN
 *  @access     ADC->ADCSOCCTL0.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL0_ALL_SHAEN_Pos (31)
#define ADCSOCCTL0_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL0_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL0_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL0_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL0_BIT_SHAEN;

#define ADCSOCCTL0_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL0_ALL_SHAEN_Pos)
#define ADCSOCCTL0_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL0_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      CONVCNT
 *  @access     ADC->ADCSOCCTL1.bit.CONVCNT
 *  @brief      Select SOC1 Convert Window Size
 */
#define ADCSOCCTL1_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL1_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL1_ALL_CONVCNT_Pos)

#define ADCSOCCTL1_BIT_CONVCNT

#define ADCSOCCTL1_ALL_CONVCNT_(x) ((x) << ADCSOCCTL1_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      SAMPCNT
 *  @access     ADC->ADCSOCCTL1.bit.SAMPCNT
 *  @brief      Select SOC1 Sample Window Size
 */
#define ADCSOCCTL1_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL1_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL1_ALL_SAMPCNT_Pos)

#define ADCSOCCTL1_BIT_SAMPCNT

#define ADCSOCCTL1_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL1_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      CHSELAN
 *  @access     ADC->ADCSOCCTL1.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC1
 */
#define ADCSOCCTL1_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL1_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL1_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL1_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL1_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL1_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL1_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL1_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL1_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL1_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL1_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL1_BIT_CHSELAN;

#define ADCSOCCTL1_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL1_ALL_CHSELAN_Pos)
#define ADCSOCCTL1_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL1_ALL_CHSELAN_Pos)
#define ADCSOCCTL1_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL1_ALL_CHSELAN_Pos)
#define ADCSOCCTL1_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL1_ALL_CHSELAN_Pos)
#define ADCSOCCTL1_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL1_ALL_CHSELAN_Pos)
#define ADCSOCCTL1_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL1_ALL_CHSELAN_Pos)
#define ADCSOCCTL1_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL1_ALL_CHSELAN_Pos)
#define ADCSOCCTL1_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL1_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      CHSELAP
 *  @access     ADC->ADCSOCCTL1.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC1
 */
#define ADCSOCCTL1_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL1_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL1_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL1_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL1_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL1_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL1_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL1_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL1_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL1_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL1_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL1_BIT_CHSELAP;

#define ADCSOCCTL1_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL1_ALL_CHSELAP_Pos)
#define ADCSOCCTL1_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL1_ALL_CHSELAP_Pos)
#define ADCSOCCTL1_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL1_ALL_CHSELAP_Pos)
#define ADCSOCCTL1_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL1_ALL_CHSELAP_Pos)
#define ADCSOCCTL1_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL1_ALL_CHSELAP_Pos)
#define ADCSOCCTL1_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL1_ALL_CHSELAP_Pos)
#define ADCSOCCTL1_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL1_ALL_CHSELAP_Pos)
#define ADCSOCCTL1_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL1_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      CHSELBN
 *  @access     ADC->ADCSOCCTL1.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC1
 */
#define ADCSOCCTL1_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL1_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL1_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL1_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL1_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL1_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL1_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL1_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL1_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL1_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL1_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL1_BIT_CHSELBN;

#define ADCSOCCTL1_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL1_ALL_CHSELBN_Pos)
#define ADCSOCCTL1_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL1_ALL_CHSELBN_Pos)
#define ADCSOCCTL1_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL1_ALL_CHSELBN_Pos)
#define ADCSOCCTL1_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL1_ALL_CHSELBN_Pos)
#define ADCSOCCTL1_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL1_ALL_CHSELBN_Pos)
#define ADCSOCCTL1_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL1_ALL_CHSELBN_Pos)
#define ADCSOCCTL1_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL1_ALL_CHSELBN_Pos)
#define ADCSOCCTL1_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL1_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      CHSELBP
 *  @access     ADC->ADCSOCCTL1.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC1
 */
#define ADCSOCCTL1_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL1_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL1_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL1_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL1_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL1_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL1_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL1_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL1_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL1_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL1_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL1_BIT_CHSELBP;

#define ADCSOCCTL1_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL1_ALL_CHSELBP_Pos)
#define ADCSOCCTL1_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL1_ALL_CHSELBP_Pos)
#define ADCSOCCTL1_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL1_ALL_CHSELBP_Pos)
#define ADCSOCCTL1_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL1_ALL_CHSELBP_Pos)
#define ADCSOCCTL1_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL1_ALL_CHSELBP_Pos)
#define ADCSOCCTL1_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL1_ALL_CHSELBP_Pos)
#define ADCSOCCTL1_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL1_ALL_CHSELBP_Pos)
#define ADCSOCCTL1_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL1_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      TRIGSEL
 *  @access     ADC->ADCSOCCTL1.bit.TRIGSEL
 *  @brief      Select SOC1 Trigger Source
 *              Configures which trigger source will set SOC1 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC1. This setting can be overridden by the respective SOC1 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL1_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL1_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL1_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL1_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL1_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL1_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL1_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL1_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL1_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL1_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL1_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL1_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL1_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL1_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL1_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL1_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL1_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL1_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL1_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL1_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL1_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL1_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL1_BIT_TRIGSEL;

#define ADCSOCCTL1_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)
#define ADCSOCCTL1_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL1_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      SHBEN
 *  @access     ADC->ADCSOCCTL1.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL1_ALL_SHBEN_Pos (30)
#define ADCSOCCTL1_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL1_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL1_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL1_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL1_BIT_SHBEN;

#define ADCSOCCTL1_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL1_ALL_SHBEN_Pos)
#define ADCSOCCTL1_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL1_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL1      SHAEN
 *  @access     ADC->ADCSOCCTL1.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL1_ALL_SHAEN_Pos (31)
#define ADCSOCCTL1_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL1_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL1_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL1_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL1_BIT_SHAEN;

#define ADCSOCCTL1_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL1_ALL_SHAEN_Pos)
#define ADCSOCCTL1_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL1_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      CONVCNT
 *  @access     ADC->ADCSOCCTL2.bit.CONVCNT
 *  @brief      Select SOC2 Convert Window Size
 */
#define ADCSOCCTL2_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL2_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL2_ALL_CONVCNT_Pos)

#define ADCSOCCTL2_BIT_CONVCNT

#define ADCSOCCTL2_ALL_CONVCNT_(x) ((x) << ADCSOCCTL2_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      SAMPCNT
 *  @access     ADC->ADCSOCCTL2.bit.SAMPCNT
 *  @brief      Select SOC2 Sample Window Size
 */
#define ADCSOCCTL2_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL2_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL2_ALL_SAMPCNT_Pos)

#define ADCSOCCTL2_BIT_SAMPCNT

#define ADCSOCCTL2_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL2_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      CHSELAN
 *  @access     ADC->ADCSOCCTL2.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC2
 */
#define ADCSOCCTL2_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL2_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL2_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL2_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL2_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL2_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL2_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL2_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL2_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL2_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL2_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL2_BIT_CHSELAN;

#define ADCSOCCTL2_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL2_ALL_CHSELAN_Pos)
#define ADCSOCCTL2_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL2_ALL_CHSELAN_Pos)
#define ADCSOCCTL2_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL2_ALL_CHSELAN_Pos)
#define ADCSOCCTL2_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL2_ALL_CHSELAN_Pos)
#define ADCSOCCTL2_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL2_ALL_CHSELAN_Pos)
#define ADCSOCCTL2_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL2_ALL_CHSELAN_Pos)
#define ADCSOCCTL2_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL2_ALL_CHSELAN_Pos)
#define ADCSOCCTL2_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL2_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      CHSELAP
 *  @access     ADC->ADCSOCCTL2.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC2
 */
#define ADCSOCCTL2_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL2_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL2_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL2_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL2_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL2_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL2_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL2_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL2_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL2_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL2_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL2_BIT_CHSELAP;

#define ADCSOCCTL2_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL2_ALL_CHSELAP_Pos)
#define ADCSOCCTL2_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL2_ALL_CHSELAP_Pos)
#define ADCSOCCTL2_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL2_ALL_CHSELAP_Pos)
#define ADCSOCCTL2_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL2_ALL_CHSELAP_Pos)
#define ADCSOCCTL2_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL2_ALL_CHSELAP_Pos)
#define ADCSOCCTL2_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL2_ALL_CHSELAP_Pos)
#define ADCSOCCTL2_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL2_ALL_CHSELAP_Pos)
#define ADCSOCCTL2_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL2_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      CHSELBN
 *  @access     ADC->ADCSOCCTL2.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC2
 */
#define ADCSOCCTL2_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL2_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL2_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL2_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL2_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL2_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL2_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL2_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL2_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL2_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL2_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL2_BIT_CHSELBN;

#define ADCSOCCTL2_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL2_ALL_CHSELBN_Pos)
#define ADCSOCCTL2_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL2_ALL_CHSELBN_Pos)
#define ADCSOCCTL2_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL2_ALL_CHSELBN_Pos)
#define ADCSOCCTL2_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL2_ALL_CHSELBN_Pos)
#define ADCSOCCTL2_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL2_ALL_CHSELBN_Pos)
#define ADCSOCCTL2_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL2_ALL_CHSELBN_Pos)
#define ADCSOCCTL2_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL2_ALL_CHSELBN_Pos)
#define ADCSOCCTL2_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL2_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      CHSELBP
 *  @access     ADC->ADCSOCCTL2.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC2
 */
#define ADCSOCCTL2_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL2_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL2_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL2_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL2_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL2_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL2_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL2_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL2_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL2_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL2_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL2_BIT_CHSELBP;

#define ADCSOCCTL2_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL2_ALL_CHSELBP_Pos)
#define ADCSOCCTL2_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL2_ALL_CHSELBP_Pos)
#define ADCSOCCTL2_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL2_ALL_CHSELBP_Pos)
#define ADCSOCCTL2_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL2_ALL_CHSELBP_Pos)
#define ADCSOCCTL2_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL2_ALL_CHSELBP_Pos)
#define ADCSOCCTL2_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL2_ALL_CHSELBP_Pos)
#define ADCSOCCTL2_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL2_ALL_CHSELBP_Pos)
#define ADCSOCCTL2_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL2_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      TRIGSEL
 *  @access     ADC->ADCSOCCTL2.bit.TRIGSEL
 *  @brief      Select SOC2 Trigger Source
 *              Configures which trigger source will set SOC2 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC2. This setting can be overridden by the respective SOC2 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL2_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL2_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL2_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL2_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL2_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL2_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL2_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL2_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL2_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL2_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL2_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL2_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL2_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL2_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL2_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL2_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL2_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL2_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL2_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL2_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL2_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL2_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL2_BIT_TRIGSEL;

#define ADCSOCCTL2_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)
#define ADCSOCCTL2_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL2_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      SHBEN
 *  @access     ADC->ADCSOCCTL2.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL2_ALL_SHBEN_Pos (30)
#define ADCSOCCTL2_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL2_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL2_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL2_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL2_BIT_SHBEN;

#define ADCSOCCTL2_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL2_ALL_SHBEN_Pos)
#define ADCSOCCTL2_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL2_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL2      SHAEN
 *  @access     ADC->ADCSOCCTL2.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL2_ALL_SHAEN_Pos (31)
#define ADCSOCCTL2_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL2_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL2_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL2_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL2_BIT_SHAEN;

#define ADCSOCCTL2_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL2_ALL_SHAEN_Pos)
#define ADCSOCCTL2_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL2_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      CONVCNT
 *  @access     ADC->ADCSOCCTL3.bit.CONVCNT
 *  @brief      Select SOC3 Convert Window Size
 */
#define ADCSOCCTL3_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL3_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL3_ALL_CONVCNT_Pos)

#define ADCSOCCTL3_BIT_CONVCNT

#define ADCSOCCTL3_ALL_CONVCNT_(x) ((x) << ADCSOCCTL3_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      SAMPCNT
 *  @access     ADC->ADCSOCCTL3.bit.SAMPCNT
 *  @brief      Select SOC3 Sample Window Size
 */
#define ADCSOCCTL3_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL3_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL3_ALL_SAMPCNT_Pos)

#define ADCSOCCTL3_BIT_SAMPCNT

#define ADCSOCCTL3_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL3_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      CHSELAN
 *  @access     ADC->ADCSOCCTL3.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC3
 */
#define ADCSOCCTL3_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL3_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL3_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL3_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL3_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL3_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL3_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL3_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL3_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL3_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL3_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL3_BIT_CHSELAN;

#define ADCSOCCTL3_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL3_ALL_CHSELAN_Pos)
#define ADCSOCCTL3_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL3_ALL_CHSELAN_Pos)
#define ADCSOCCTL3_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL3_ALL_CHSELAN_Pos)
#define ADCSOCCTL3_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL3_ALL_CHSELAN_Pos)
#define ADCSOCCTL3_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL3_ALL_CHSELAN_Pos)
#define ADCSOCCTL3_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL3_ALL_CHSELAN_Pos)
#define ADCSOCCTL3_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL3_ALL_CHSELAN_Pos)
#define ADCSOCCTL3_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL3_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      CHSELAP
 *  @access     ADC->ADCSOCCTL3.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC3
 */
#define ADCSOCCTL3_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL3_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL3_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL3_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL3_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL3_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL3_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL3_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL3_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL3_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL3_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL3_BIT_CHSELAP;

#define ADCSOCCTL3_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL3_ALL_CHSELAP_Pos)
#define ADCSOCCTL3_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL3_ALL_CHSELAP_Pos)
#define ADCSOCCTL3_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL3_ALL_CHSELAP_Pos)
#define ADCSOCCTL3_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL3_ALL_CHSELAP_Pos)
#define ADCSOCCTL3_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL3_ALL_CHSELAP_Pos)
#define ADCSOCCTL3_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL3_ALL_CHSELAP_Pos)
#define ADCSOCCTL3_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL3_ALL_CHSELAP_Pos)
#define ADCSOCCTL3_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL3_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      CHSELBN
 *  @access     ADC->ADCSOCCTL3.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC3
 */
#define ADCSOCCTL3_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL3_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL3_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL3_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL3_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL3_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL3_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL3_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL3_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL3_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL3_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL3_BIT_CHSELBN;

#define ADCSOCCTL3_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL3_ALL_CHSELBN_Pos)
#define ADCSOCCTL3_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL3_ALL_CHSELBN_Pos)
#define ADCSOCCTL3_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL3_ALL_CHSELBN_Pos)
#define ADCSOCCTL3_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL3_ALL_CHSELBN_Pos)
#define ADCSOCCTL3_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL3_ALL_CHSELBN_Pos)
#define ADCSOCCTL3_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL3_ALL_CHSELBN_Pos)
#define ADCSOCCTL3_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL3_ALL_CHSELBN_Pos)
#define ADCSOCCTL3_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL3_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      CHSELBP
 *  @access     ADC->ADCSOCCTL3.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC3
 */
#define ADCSOCCTL3_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL3_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL3_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL3_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL3_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL3_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL3_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL3_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL3_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL3_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL3_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL3_BIT_CHSELBP;

#define ADCSOCCTL3_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL3_ALL_CHSELBP_Pos)
#define ADCSOCCTL3_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL3_ALL_CHSELBP_Pos)
#define ADCSOCCTL3_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL3_ALL_CHSELBP_Pos)
#define ADCSOCCTL3_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL3_ALL_CHSELBP_Pos)
#define ADCSOCCTL3_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL3_ALL_CHSELBP_Pos)
#define ADCSOCCTL3_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL3_ALL_CHSELBP_Pos)
#define ADCSOCCTL3_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL3_ALL_CHSELBP_Pos)
#define ADCSOCCTL3_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL3_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      TRIGSEL
 *  @access     ADC->ADCSOCCTL3.bit.TRIGSEL
 *  @brief      Select SOC3 Trigger Source
 *              Configures which trigger source will set SOC3 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC3. This setting can be overridden by the respective SOC3 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL3_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL3_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL3_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL3_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL3_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL3_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL3_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL3_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL3_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL3_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL3_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL3_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL3_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL3_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL3_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL3_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL3_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL3_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL3_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL3_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL3_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL3_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL3_BIT_TRIGSEL;

#define ADCSOCCTL3_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)
#define ADCSOCCTL3_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL3_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      SHBEN
 *  @access     ADC->ADCSOCCTL3.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL3_ALL_SHBEN_Pos (30)
#define ADCSOCCTL3_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL3_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL3_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL3_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL3_BIT_SHBEN;

#define ADCSOCCTL3_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL3_ALL_SHBEN_Pos)
#define ADCSOCCTL3_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL3_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL3      SHAEN
 *  @access     ADC->ADCSOCCTL3.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL3_ALL_SHAEN_Pos (31)
#define ADCSOCCTL3_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL3_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL3_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL3_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL3_BIT_SHAEN;

#define ADCSOCCTL3_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL3_ALL_SHAEN_Pos)
#define ADCSOCCTL3_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL3_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      CONVCNT
 *  @access     ADC->ADCSOCCTL4.bit.CONVCNT
 *  @brief      Select SOC4 Convert Window Size
 */
#define ADCSOCCTL4_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL4_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL4_ALL_CONVCNT_Pos)

#define ADCSOCCTL4_BIT_CONVCNT

#define ADCSOCCTL4_ALL_CONVCNT_(x) ((x) << ADCSOCCTL4_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      SAMPCNT
 *  @access     ADC->ADCSOCCTL4.bit.SAMPCNT
 *  @brief      Select SOC4 Sample Window Size
 */
#define ADCSOCCTL4_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL4_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL4_ALL_SAMPCNT_Pos)

#define ADCSOCCTL4_BIT_SAMPCNT

#define ADCSOCCTL4_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL4_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      CHSELAN
 *  @access     ADC->ADCSOCCTL4.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC4
 */
#define ADCSOCCTL4_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL4_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL4_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL4_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL4_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL4_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL4_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL4_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL4_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL4_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL4_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL4_BIT_CHSELAN;

#define ADCSOCCTL4_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL4_ALL_CHSELAN_Pos)
#define ADCSOCCTL4_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL4_ALL_CHSELAN_Pos)
#define ADCSOCCTL4_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL4_ALL_CHSELAN_Pos)
#define ADCSOCCTL4_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL4_ALL_CHSELAN_Pos)
#define ADCSOCCTL4_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL4_ALL_CHSELAN_Pos)
#define ADCSOCCTL4_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL4_ALL_CHSELAN_Pos)
#define ADCSOCCTL4_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL4_ALL_CHSELAN_Pos)
#define ADCSOCCTL4_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL4_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      CHSELAP
 *  @access     ADC->ADCSOCCTL4.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC4
 */
#define ADCSOCCTL4_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL4_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL4_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL4_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL4_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL4_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL4_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL4_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL4_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL4_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL4_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL4_BIT_CHSELAP;

#define ADCSOCCTL4_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL4_ALL_CHSELAP_Pos)
#define ADCSOCCTL4_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL4_ALL_CHSELAP_Pos)
#define ADCSOCCTL4_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL4_ALL_CHSELAP_Pos)
#define ADCSOCCTL4_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL4_ALL_CHSELAP_Pos)
#define ADCSOCCTL4_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL4_ALL_CHSELAP_Pos)
#define ADCSOCCTL4_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL4_ALL_CHSELAP_Pos)
#define ADCSOCCTL4_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL4_ALL_CHSELAP_Pos)
#define ADCSOCCTL4_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL4_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      CHSELBN
 *  @access     ADC->ADCSOCCTL4.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC4
 */
#define ADCSOCCTL4_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL4_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL4_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL4_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL4_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL4_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL4_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL4_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL4_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL4_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL4_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL4_BIT_CHSELBN;

#define ADCSOCCTL4_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL4_ALL_CHSELBN_Pos)
#define ADCSOCCTL4_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL4_ALL_CHSELBN_Pos)
#define ADCSOCCTL4_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL4_ALL_CHSELBN_Pos)
#define ADCSOCCTL4_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL4_ALL_CHSELBN_Pos)
#define ADCSOCCTL4_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL4_ALL_CHSELBN_Pos)
#define ADCSOCCTL4_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL4_ALL_CHSELBN_Pos)
#define ADCSOCCTL4_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL4_ALL_CHSELBN_Pos)
#define ADCSOCCTL4_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL4_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      CHSELBP
 *  @access     ADC->ADCSOCCTL4.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC4
 */
#define ADCSOCCTL4_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL4_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL4_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL4_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL4_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL4_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL4_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL4_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL4_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL4_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL4_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL4_BIT_CHSELBP;

#define ADCSOCCTL4_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL4_ALL_CHSELBP_Pos)
#define ADCSOCCTL4_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL4_ALL_CHSELBP_Pos)
#define ADCSOCCTL4_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL4_ALL_CHSELBP_Pos)
#define ADCSOCCTL4_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL4_ALL_CHSELBP_Pos)
#define ADCSOCCTL4_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL4_ALL_CHSELBP_Pos)
#define ADCSOCCTL4_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL4_ALL_CHSELBP_Pos)
#define ADCSOCCTL4_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL4_ALL_CHSELBP_Pos)
#define ADCSOCCTL4_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL4_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      TRIGSEL
 *  @access     ADC->ADCSOCCTL4.bit.TRIGSEL
 *  @brief      Select SOC4 Trigger Source
 *              Configures which trigger source will set SOC4 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC4. This setting can be overridden by the respective SOC4 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL4_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL4_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL4_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL4_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL4_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL4_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL4_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL4_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL4_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL4_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL4_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL4_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL4_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL4_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL4_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL4_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL4_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL4_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL4_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL4_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL4_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL4_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL4_BIT_TRIGSEL;

#define ADCSOCCTL4_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)
#define ADCSOCCTL4_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL4_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      SHBEN
 *  @access     ADC->ADCSOCCTL4.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL4_ALL_SHBEN_Pos (30)
#define ADCSOCCTL4_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL4_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL4_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL4_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL4_BIT_SHBEN;

#define ADCSOCCTL4_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL4_ALL_SHBEN_Pos)
#define ADCSOCCTL4_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL4_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL4      SHAEN
 *  @access     ADC->ADCSOCCTL4.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL4_ALL_SHAEN_Pos (31)
#define ADCSOCCTL4_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL4_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL4_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL4_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL4_BIT_SHAEN;

#define ADCSOCCTL4_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL4_ALL_SHAEN_Pos)
#define ADCSOCCTL4_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL4_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      CONVCNT
 *  @access     ADC->ADCSOCCTL5.bit.CONVCNT
 *  @brief      Select SOC5 Convert Window Size
 */
#define ADCSOCCTL5_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL5_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL5_ALL_CONVCNT_Pos)

#define ADCSOCCTL5_BIT_CONVCNT

#define ADCSOCCTL5_ALL_CONVCNT_(x) ((x) << ADCSOCCTL5_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      SAMPCNT
 *  @access     ADC->ADCSOCCTL5.bit.SAMPCNT
 *  @brief      Select SOC5 Sample Window Size
 */
#define ADCSOCCTL5_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL5_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL5_ALL_SAMPCNT_Pos)

#define ADCSOCCTL5_BIT_SAMPCNT

#define ADCSOCCTL5_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL5_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      CHSELAN
 *  @access     ADC->ADCSOCCTL5.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC5
 */
#define ADCSOCCTL5_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL5_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL5_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL5_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL5_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL5_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL5_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL5_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL5_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL5_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL5_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL5_BIT_CHSELAN;

#define ADCSOCCTL5_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL5_ALL_CHSELAN_Pos)
#define ADCSOCCTL5_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL5_ALL_CHSELAN_Pos)
#define ADCSOCCTL5_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL5_ALL_CHSELAN_Pos)
#define ADCSOCCTL5_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL5_ALL_CHSELAN_Pos)
#define ADCSOCCTL5_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL5_ALL_CHSELAN_Pos)
#define ADCSOCCTL5_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL5_ALL_CHSELAN_Pos)
#define ADCSOCCTL5_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL5_ALL_CHSELAN_Pos)
#define ADCSOCCTL5_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL5_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      CHSELAP
 *  @access     ADC->ADCSOCCTL5.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC5
 */
#define ADCSOCCTL5_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL5_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL5_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL5_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL5_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL5_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL5_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL5_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL5_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL5_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL5_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL5_BIT_CHSELAP;

#define ADCSOCCTL5_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL5_ALL_CHSELAP_Pos)
#define ADCSOCCTL5_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL5_ALL_CHSELAP_Pos)
#define ADCSOCCTL5_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL5_ALL_CHSELAP_Pos)
#define ADCSOCCTL5_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL5_ALL_CHSELAP_Pos)
#define ADCSOCCTL5_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL5_ALL_CHSELAP_Pos)
#define ADCSOCCTL5_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL5_ALL_CHSELAP_Pos)
#define ADCSOCCTL5_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL5_ALL_CHSELAP_Pos)
#define ADCSOCCTL5_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL5_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      CHSELBN
 *  @access     ADC->ADCSOCCTL5.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC5
 */
#define ADCSOCCTL5_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL5_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL5_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL5_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL5_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL5_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL5_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL5_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL5_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL5_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL5_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL5_BIT_CHSELBN;

#define ADCSOCCTL5_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL5_ALL_CHSELBN_Pos)
#define ADCSOCCTL5_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL5_ALL_CHSELBN_Pos)
#define ADCSOCCTL5_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL5_ALL_CHSELBN_Pos)
#define ADCSOCCTL5_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL5_ALL_CHSELBN_Pos)
#define ADCSOCCTL5_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL5_ALL_CHSELBN_Pos)
#define ADCSOCCTL5_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL5_ALL_CHSELBN_Pos)
#define ADCSOCCTL5_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL5_ALL_CHSELBN_Pos)
#define ADCSOCCTL5_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL5_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      CHSELBP
 *  @access     ADC->ADCSOCCTL5.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC5
 */
#define ADCSOCCTL5_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL5_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL5_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL5_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL5_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL5_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL5_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL5_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL5_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL5_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL5_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL5_BIT_CHSELBP;

#define ADCSOCCTL5_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL5_ALL_CHSELBP_Pos)
#define ADCSOCCTL5_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL5_ALL_CHSELBP_Pos)
#define ADCSOCCTL5_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL5_ALL_CHSELBP_Pos)
#define ADCSOCCTL5_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL5_ALL_CHSELBP_Pos)
#define ADCSOCCTL5_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL5_ALL_CHSELBP_Pos)
#define ADCSOCCTL5_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL5_ALL_CHSELBP_Pos)
#define ADCSOCCTL5_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL5_ALL_CHSELBP_Pos)
#define ADCSOCCTL5_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL5_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      TRIGSEL
 *  @access     ADC->ADCSOCCTL5.bit.TRIGSEL
 *  @brief      Select SOC5 Trigger Source
 *              Configures which trigger source will set SOC5 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC5. This setting can be overridden by the respective SOC5 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL5_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL5_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL5_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL5_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL5_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL5_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL5_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL5_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL5_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL5_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL5_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL5_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL5_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL5_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL5_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL5_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL5_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL5_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL5_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL5_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL5_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL5_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL5_BIT_TRIGSEL;

#define ADCSOCCTL5_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)
#define ADCSOCCTL5_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL5_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      SHBEN
 *  @access     ADC->ADCSOCCTL5.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL5_ALL_SHBEN_Pos (30)
#define ADCSOCCTL5_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL5_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL5_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL5_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL5_BIT_SHBEN;

#define ADCSOCCTL5_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL5_ALL_SHBEN_Pos)
#define ADCSOCCTL5_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL5_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL5      SHAEN
 *  @access     ADC->ADCSOCCTL5.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL5_ALL_SHAEN_Pos (31)
#define ADCSOCCTL5_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL5_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL5_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL5_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL5_BIT_SHAEN;

#define ADCSOCCTL5_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL5_ALL_SHAEN_Pos)
#define ADCSOCCTL5_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL5_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      CONVCNT
 *  @access     ADC->ADCSOCCTL6.bit.CONVCNT
 *  @brief      Select SOC6 Convert Window Size
 */
#define ADCSOCCTL6_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL6_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL6_ALL_CONVCNT_Pos)

#define ADCSOCCTL6_BIT_CONVCNT

#define ADCSOCCTL6_ALL_CONVCNT_(x) ((x) << ADCSOCCTL6_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      SAMPCNT
 *  @access     ADC->ADCSOCCTL6.bit.SAMPCNT
 *  @brief      Select SOC6 Sample Window Size
 */
#define ADCSOCCTL6_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL6_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL6_ALL_SAMPCNT_Pos)

#define ADCSOCCTL6_BIT_SAMPCNT

#define ADCSOCCTL6_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL6_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      CHSELAN
 *  @access     ADC->ADCSOCCTL6.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC6
 */
#define ADCSOCCTL6_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL6_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL6_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL6_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL6_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL6_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL6_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL6_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL6_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL6_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL6_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL6_BIT_CHSELAN;

#define ADCSOCCTL6_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL6_ALL_CHSELAN_Pos)
#define ADCSOCCTL6_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL6_ALL_CHSELAN_Pos)
#define ADCSOCCTL6_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL6_ALL_CHSELAN_Pos)
#define ADCSOCCTL6_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL6_ALL_CHSELAN_Pos)
#define ADCSOCCTL6_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL6_ALL_CHSELAN_Pos)
#define ADCSOCCTL6_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL6_ALL_CHSELAN_Pos)
#define ADCSOCCTL6_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL6_ALL_CHSELAN_Pos)
#define ADCSOCCTL6_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL6_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      CHSELAP
 *  @access     ADC->ADCSOCCTL6.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC6
 */
#define ADCSOCCTL6_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL6_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL6_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL6_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL6_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL6_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL6_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL6_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL6_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL6_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL6_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL6_BIT_CHSELAP;

#define ADCSOCCTL6_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL6_ALL_CHSELAP_Pos)
#define ADCSOCCTL6_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL6_ALL_CHSELAP_Pos)
#define ADCSOCCTL6_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL6_ALL_CHSELAP_Pos)
#define ADCSOCCTL6_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL6_ALL_CHSELAP_Pos)
#define ADCSOCCTL6_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL6_ALL_CHSELAP_Pos)
#define ADCSOCCTL6_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL6_ALL_CHSELAP_Pos)
#define ADCSOCCTL6_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL6_ALL_CHSELAP_Pos)
#define ADCSOCCTL6_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL6_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      CHSELBN
 *  @access     ADC->ADCSOCCTL6.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC6
 */
#define ADCSOCCTL6_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL6_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL6_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL6_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL6_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL6_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL6_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL6_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL6_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL6_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL6_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL6_BIT_CHSELBN;

#define ADCSOCCTL6_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL6_ALL_CHSELBN_Pos)
#define ADCSOCCTL6_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL6_ALL_CHSELBN_Pos)
#define ADCSOCCTL6_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL6_ALL_CHSELBN_Pos)
#define ADCSOCCTL6_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL6_ALL_CHSELBN_Pos)
#define ADCSOCCTL6_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL6_ALL_CHSELBN_Pos)
#define ADCSOCCTL6_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL6_ALL_CHSELBN_Pos)
#define ADCSOCCTL6_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL6_ALL_CHSELBN_Pos)
#define ADCSOCCTL6_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL6_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      CHSELBP
 *  @access     ADC->ADCSOCCTL6.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC6
 */
#define ADCSOCCTL6_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL6_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL6_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL6_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL6_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL6_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL6_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL6_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL6_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL6_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL6_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL6_BIT_CHSELBP;

#define ADCSOCCTL6_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL6_ALL_CHSELBP_Pos)
#define ADCSOCCTL6_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL6_ALL_CHSELBP_Pos)
#define ADCSOCCTL6_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL6_ALL_CHSELBP_Pos)
#define ADCSOCCTL6_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL6_ALL_CHSELBP_Pos)
#define ADCSOCCTL6_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL6_ALL_CHSELBP_Pos)
#define ADCSOCCTL6_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL6_ALL_CHSELBP_Pos)
#define ADCSOCCTL6_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL6_ALL_CHSELBP_Pos)
#define ADCSOCCTL6_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL6_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      TRIGSEL
 *  @access     ADC->ADCSOCCTL6.bit.TRIGSEL
 *  @brief      Select SOC6 Trigger Source
 *              Configures which trigger source will set SOC6 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC6. This setting can be overridden by the respective SOC6 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL6_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL6_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL6_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL6_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL6_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL6_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL6_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL6_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL6_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL6_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL6_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL6_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL6_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL6_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL6_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL6_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL6_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL6_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL6_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL6_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL6_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL6_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL6_BIT_TRIGSEL;

#define ADCSOCCTL6_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)
#define ADCSOCCTL6_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL6_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      SHBEN
 *  @access     ADC->ADCSOCCTL6.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL6_ALL_SHBEN_Pos (30)
#define ADCSOCCTL6_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL6_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL6_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL6_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL6_BIT_SHBEN;

#define ADCSOCCTL6_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL6_ALL_SHBEN_Pos)
#define ADCSOCCTL6_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL6_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL6      SHAEN
 *  @access     ADC->ADCSOCCTL6.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL6_ALL_SHAEN_Pos (31)
#define ADCSOCCTL6_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL6_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL6_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL6_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL6_BIT_SHAEN;

#define ADCSOCCTL6_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL6_ALL_SHAEN_Pos)
#define ADCSOCCTL6_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL6_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      CONVCNT
 *  @access     ADC->ADCSOCCTL7.bit.CONVCNT
 *  @brief      Select SOC7 Convert Window Size
 */
#define ADCSOCCTL7_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL7_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL7_ALL_CONVCNT_Pos)

#define ADCSOCCTL7_BIT_CONVCNT

#define ADCSOCCTL7_ALL_CONVCNT_(x) ((x) << ADCSOCCTL7_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      SAMPCNT
 *  @access     ADC->ADCSOCCTL7.bit.SAMPCNT
 *  @brief      Select SOC7 Sample Window Size
 */
#define ADCSOCCTL7_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL7_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL7_ALL_SAMPCNT_Pos)

#define ADCSOCCTL7_BIT_SAMPCNT

#define ADCSOCCTL7_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL7_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      CHSELAN
 *  @access     ADC->ADCSOCCTL7.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC7
 */
#define ADCSOCCTL7_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL7_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL7_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL7_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL7_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL7_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL7_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL7_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL7_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL7_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL7_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL7_BIT_CHSELAN;

#define ADCSOCCTL7_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL7_ALL_CHSELAN_Pos)
#define ADCSOCCTL7_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL7_ALL_CHSELAN_Pos)
#define ADCSOCCTL7_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL7_ALL_CHSELAN_Pos)
#define ADCSOCCTL7_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL7_ALL_CHSELAN_Pos)
#define ADCSOCCTL7_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL7_ALL_CHSELAN_Pos)
#define ADCSOCCTL7_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL7_ALL_CHSELAN_Pos)
#define ADCSOCCTL7_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL7_ALL_CHSELAN_Pos)
#define ADCSOCCTL7_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL7_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      CHSELAP
 *  @access     ADC->ADCSOCCTL7.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC7
 */
#define ADCSOCCTL7_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL7_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL7_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL7_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL7_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL7_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL7_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL7_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL7_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL7_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL7_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL7_BIT_CHSELAP;

#define ADCSOCCTL7_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL7_ALL_CHSELAP_Pos)
#define ADCSOCCTL7_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL7_ALL_CHSELAP_Pos)
#define ADCSOCCTL7_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL7_ALL_CHSELAP_Pos)
#define ADCSOCCTL7_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL7_ALL_CHSELAP_Pos)
#define ADCSOCCTL7_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL7_ALL_CHSELAP_Pos)
#define ADCSOCCTL7_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL7_ALL_CHSELAP_Pos)
#define ADCSOCCTL7_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL7_ALL_CHSELAP_Pos)
#define ADCSOCCTL7_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL7_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      CHSELBN
 *  @access     ADC->ADCSOCCTL7.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC7
 */
#define ADCSOCCTL7_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL7_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL7_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL7_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL7_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL7_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL7_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL7_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL7_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL7_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL7_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL7_BIT_CHSELBN;

#define ADCSOCCTL7_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL7_ALL_CHSELBN_Pos)
#define ADCSOCCTL7_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL7_ALL_CHSELBN_Pos)
#define ADCSOCCTL7_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL7_ALL_CHSELBN_Pos)
#define ADCSOCCTL7_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL7_ALL_CHSELBN_Pos)
#define ADCSOCCTL7_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL7_ALL_CHSELBN_Pos)
#define ADCSOCCTL7_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL7_ALL_CHSELBN_Pos)
#define ADCSOCCTL7_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL7_ALL_CHSELBN_Pos)
#define ADCSOCCTL7_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL7_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      CHSELBP
 *  @access     ADC->ADCSOCCTL7.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC7
 */
#define ADCSOCCTL7_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL7_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL7_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL7_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL7_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL7_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL7_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL7_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL7_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL7_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL7_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL7_BIT_CHSELBP;

#define ADCSOCCTL7_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL7_ALL_CHSELBP_Pos)
#define ADCSOCCTL7_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL7_ALL_CHSELBP_Pos)
#define ADCSOCCTL7_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL7_ALL_CHSELBP_Pos)
#define ADCSOCCTL7_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL7_ALL_CHSELBP_Pos)
#define ADCSOCCTL7_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL7_ALL_CHSELBP_Pos)
#define ADCSOCCTL7_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL7_ALL_CHSELBP_Pos)
#define ADCSOCCTL7_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL7_ALL_CHSELBP_Pos)
#define ADCSOCCTL7_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL7_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      TRIGSEL
 *  @access     ADC->ADCSOCCTL7.bit.TRIGSEL
 *  @brief      Select SOC7 Trigger Source
 *              Configures which trigger source will set SOC7 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC7. This setting can be overridden by the respective SOC7 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL7_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL7_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL7_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL7_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL7_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL7_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL7_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL7_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL7_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL7_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL7_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL7_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL7_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL7_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL7_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL7_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL7_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL7_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL7_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL7_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL7_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL7_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL7_BIT_TRIGSEL;

#define ADCSOCCTL7_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)
#define ADCSOCCTL7_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL7_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      SHBEN
 *  @access     ADC->ADCSOCCTL7.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL7_ALL_SHBEN_Pos (30)
#define ADCSOCCTL7_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL7_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL7_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL7_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL7_BIT_SHBEN;

#define ADCSOCCTL7_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL7_ALL_SHBEN_Pos)
#define ADCSOCCTL7_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL7_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL7      SHAEN
 *  @access     ADC->ADCSOCCTL7.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL7_ALL_SHAEN_Pos (31)
#define ADCSOCCTL7_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL7_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL7_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL7_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL7_BIT_SHAEN;

#define ADCSOCCTL7_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL7_ALL_SHAEN_Pos)
#define ADCSOCCTL7_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL7_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      CONVCNT
 *  @access     ADC->ADCSOCCTL8.bit.CONVCNT
 *  @brief      Select SOC8 Convert Window Size
 */
#define ADCSOCCTL8_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL8_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL8_ALL_CONVCNT_Pos)

#define ADCSOCCTL8_BIT_CONVCNT

#define ADCSOCCTL8_ALL_CONVCNT_(x) ((x) << ADCSOCCTL8_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      SAMPCNT
 *  @access     ADC->ADCSOCCTL8.bit.SAMPCNT
 *  @brief      Select SOC8 Sample Window Size
 */
#define ADCSOCCTL8_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL8_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL8_ALL_SAMPCNT_Pos)

#define ADCSOCCTL8_BIT_SAMPCNT

#define ADCSOCCTL8_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL8_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      CHSELAN
 *  @access     ADC->ADCSOCCTL8.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC8
 */
#define ADCSOCCTL8_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL8_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL8_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL8_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL8_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL8_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL8_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL8_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL8_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL8_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL8_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL8_BIT_CHSELAN;

#define ADCSOCCTL8_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL8_ALL_CHSELAN_Pos)
#define ADCSOCCTL8_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL8_ALL_CHSELAN_Pos)
#define ADCSOCCTL8_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL8_ALL_CHSELAN_Pos)
#define ADCSOCCTL8_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL8_ALL_CHSELAN_Pos)
#define ADCSOCCTL8_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL8_ALL_CHSELAN_Pos)
#define ADCSOCCTL8_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL8_ALL_CHSELAN_Pos)
#define ADCSOCCTL8_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL8_ALL_CHSELAN_Pos)
#define ADCSOCCTL8_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL8_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      CHSELAP
 *  @access     ADC->ADCSOCCTL8.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC8
 */
#define ADCSOCCTL8_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL8_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL8_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL8_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL8_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL8_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL8_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL8_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL8_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL8_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL8_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL8_BIT_CHSELAP;

#define ADCSOCCTL8_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL8_ALL_CHSELAP_Pos)
#define ADCSOCCTL8_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL8_ALL_CHSELAP_Pos)
#define ADCSOCCTL8_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL8_ALL_CHSELAP_Pos)
#define ADCSOCCTL8_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL8_ALL_CHSELAP_Pos)
#define ADCSOCCTL8_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL8_ALL_CHSELAP_Pos)
#define ADCSOCCTL8_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL8_ALL_CHSELAP_Pos)
#define ADCSOCCTL8_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL8_ALL_CHSELAP_Pos)
#define ADCSOCCTL8_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL8_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      CHSELBN
 *  @access     ADC->ADCSOCCTL8.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC8
 */
#define ADCSOCCTL8_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL8_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL8_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL8_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL8_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL8_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL8_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL8_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL8_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL8_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL8_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL8_BIT_CHSELBN;

#define ADCSOCCTL8_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL8_ALL_CHSELBN_Pos)
#define ADCSOCCTL8_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL8_ALL_CHSELBN_Pos)
#define ADCSOCCTL8_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL8_ALL_CHSELBN_Pos)
#define ADCSOCCTL8_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL8_ALL_CHSELBN_Pos)
#define ADCSOCCTL8_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL8_ALL_CHSELBN_Pos)
#define ADCSOCCTL8_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL8_ALL_CHSELBN_Pos)
#define ADCSOCCTL8_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL8_ALL_CHSELBN_Pos)
#define ADCSOCCTL8_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL8_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      CHSELBP
 *  @access     ADC->ADCSOCCTL8.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC8
 */
#define ADCSOCCTL8_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL8_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL8_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL8_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL8_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL8_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL8_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL8_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL8_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL8_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL8_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL8_BIT_CHSELBP;

#define ADCSOCCTL8_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL8_ALL_CHSELBP_Pos)
#define ADCSOCCTL8_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL8_ALL_CHSELBP_Pos)
#define ADCSOCCTL8_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL8_ALL_CHSELBP_Pos)
#define ADCSOCCTL8_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL8_ALL_CHSELBP_Pos)
#define ADCSOCCTL8_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL8_ALL_CHSELBP_Pos)
#define ADCSOCCTL8_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL8_ALL_CHSELBP_Pos)
#define ADCSOCCTL8_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL8_ALL_CHSELBP_Pos)
#define ADCSOCCTL8_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL8_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      TRIGSEL
 *  @access     ADC->ADCSOCCTL8.bit.TRIGSEL
 *  @brief      Select SOC8 Trigger Source
 *              Configures which trigger source will set SOC8 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC8. This setting can be overridden by the respective SOC8 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL8_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL8_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL8_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL8_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL8_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL8_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL8_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL8_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL8_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL8_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL8_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL8_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL8_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL8_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL8_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL8_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL8_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL8_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL8_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL8_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL8_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL8_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL8_BIT_TRIGSEL;

#define ADCSOCCTL8_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)
#define ADCSOCCTL8_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL8_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      SHBEN
 *  @access     ADC->ADCSOCCTL8.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL8_ALL_SHBEN_Pos (30)
#define ADCSOCCTL8_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL8_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL8_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL8_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL8_BIT_SHBEN;

#define ADCSOCCTL8_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL8_ALL_SHBEN_Pos)
#define ADCSOCCTL8_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL8_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL8      SHAEN
 *  @access     ADC->ADCSOCCTL8.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL8_ALL_SHAEN_Pos (31)
#define ADCSOCCTL8_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL8_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL8_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL8_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL8_BIT_SHAEN;

#define ADCSOCCTL8_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL8_ALL_SHAEN_Pos)
#define ADCSOCCTL8_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL8_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      CONVCNT
 *  @access     ADC->ADCSOCCTL9.bit.CONVCNT
 *  @brief      Select SOC9 Convert Window Size
 */
#define ADCSOCCTL9_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL9_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL9_ALL_CONVCNT_Pos)

#define ADCSOCCTL9_BIT_CONVCNT

#define ADCSOCCTL9_ALL_CONVCNT_(x) ((x) << ADCSOCCTL9_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      SAMPCNT
 *  @access     ADC->ADCSOCCTL9.bit.SAMPCNT
 *  @brief      Select SOC9 Sample Window Size
 */
#define ADCSOCCTL9_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL9_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL9_ALL_SAMPCNT_Pos)

#define ADCSOCCTL9_BIT_SAMPCNT

#define ADCSOCCTL9_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL9_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      CHSELAN
 *  @access     ADC->ADCSOCCTL9.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC9
 */
#define ADCSOCCTL9_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL9_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL9_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL9_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL9_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL9_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL9_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL9_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL9_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL9_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL9_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL9_BIT_CHSELAN;

#define ADCSOCCTL9_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL9_ALL_CHSELAN_Pos)
#define ADCSOCCTL9_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL9_ALL_CHSELAN_Pos)
#define ADCSOCCTL9_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL9_ALL_CHSELAN_Pos)
#define ADCSOCCTL9_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL9_ALL_CHSELAN_Pos)
#define ADCSOCCTL9_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL9_ALL_CHSELAN_Pos)
#define ADCSOCCTL9_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL9_ALL_CHSELAN_Pos)
#define ADCSOCCTL9_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL9_ALL_CHSELAN_Pos)
#define ADCSOCCTL9_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL9_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      CHSELAP
 *  @access     ADC->ADCSOCCTL9.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC9
 */
#define ADCSOCCTL9_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL9_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL9_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL9_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL9_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL9_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL9_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL9_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL9_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL9_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL9_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL9_BIT_CHSELAP;

#define ADCSOCCTL9_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL9_ALL_CHSELAP_Pos)
#define ADCSOCCTL9_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL9_ALL_CHSELAP_Pos)
#define ADCSOCCTL9_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL9_ALL_CHSELAP_Pos)
#define ADCSOCCTL9_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL9_ALL_CHSELAP_Pos)
#define ADCSOCCTL9_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL9_ALL_CHSELAP_Pos)
#define ADCSOCCTL9_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL9_ALL_CHSELAP_Pos)
#define ADCSOCCTL9_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL9_ALL_CHSELAP_Pos)
#define ADCSOCCTL9_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL9_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      CHSELBN
 *  @access     ADC->ADCSOCCTL9.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC9
 */
#define ADCSOCCTL9_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL9_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL9_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL9_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL9_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL9_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL9_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL9_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL9_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL9_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL9_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL9_BIT_CHSELBN;

#define ADCSOCCTL9_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL9_ALL_CHSELBN_Pos)
#define ADCSOCCTL9_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL9_ALL_CHSELBN_Pos)
#define ADCSOCCTL9_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL9_ALL_CHSELBN_Pos)
#define ADCSOCCTL9_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL9_ALL_CHSELBN_Pos)
#define ADCSOCCTL9_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL9_ALL_CHSELBN_Pos)
#define ADCSOCCTL9_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL9_ALL_CHSELBN_Pos)
#define ADCSOCCTL9_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL9_ALL_CHSELBN_Pos)
#define ADCSOCCTL9_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL9_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      CHSELBP
 *  @access     ADC->ADCSOCCTL9.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC9
 */
#define ADCSOCCTL9_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL9_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL9_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL9_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL9_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL9_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL9_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL9_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL9_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL9_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL9_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL9_BIT_CHSELBP;

#define ADCSOCCTL9_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL9_ALL_CHSELBP_Pos)
#define ADCSOCCTL9_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL9_ALL_CHSELBP_Pos)
#define ADCSOCCTL9_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL9_ALL_CHSELBP_Pos)
#define ADCSOCCTL9_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL9_ALL_CHSELBP_Pos)
#define ADCSOCCTL9_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL9_ALL_CHSELBP_Pos)
#define ADCSOCCTL9_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL9_ALL_CHSELBP_Pos)
#define ADCSOCCTL9_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL9_ALL_CHSELBP_Pos)
#define ADCSOCCTL9_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL9_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      TRIGSEL
 *  @access     ADC->ADCSOCCTL9.bit.TRIGSEL
 *  @brief      Select SOC9 Trigger Source
 *              Configures which trigger source will set SOC9 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC9. This setting can be overridden by the respective SOC9 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL9_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL9_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL9_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL9_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL9_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL9_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL9_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL9_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL9_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL9_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL9_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL9_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL9_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL9_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL9_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL9_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL9_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL9_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL9_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL9_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL9_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL9_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL9_BIT_TRIGSEL;

#define ADCSOCCTL9_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)
#define ADCSOCCTL9_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL9_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      SHBEN
 *  @access     ADC->ADCSOCCTL9.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL9_ALL_SHBEN_Pos (30)
#define ADCSOCCTL9_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL9_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL9_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL9_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL9_BIT_SHBEN;

#define ADCSOCCTL9_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL9_ALL_SHBEN_Pos)
#define ADCSOCCTL9_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL9_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL9      SHAEN
 *  @access     ADC->ADCSOCCTL9.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL9_ALL_SHAEN_Pos (31)
#define ADCSOCCTL9_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL9_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL9_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL9_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL9_BIT_SHAEN;

#define ADCSOCCTL9_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL9_ALL_SHAEN_Pos)
#define ADCSOCCTL9_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL9_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     CONVCNT
 *  @access     ADC->ADCSOCCTL10.bit.CONVCNT
 *  @brief      Select SOC10 Convert Window Size
 */
#define ADCSOCCTL10_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL10_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL10_ALL_CONVCNT_Pos)

#define ADCSOCCTL10_BIT_CONVCNT

#define ADCSOCCTL10_ALL_CONVCNT_(x) ((x) << ADCSOCCTL10_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     SAMPCNT
 *  @access     ADC->ADCSOCCTL10.bit.SAMPCNT
 *  @brief      Select SOC10 Sample Window Size
 */
#define ADCSOCCTL10_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL10_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL10_ALL_SAMPCNT_Pos)

#define ADCSOCCTL10_BIT_SAMPCNT

#define ADCSOCCTL10_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL10_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     CHSELAN
 *  @access     ADC->ADCSOCCTL10.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC10
 */
#define ADCSOCCTL10_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL10_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL10_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL10_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL10_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL10_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL10_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL10_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL10_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL10_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL10_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL10_BIT_CHSELAN;

#define ADCSOCCTL10_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL10_ALL_CHSELAN_Pos)
#define ADCSOCCTL10_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL10_ALL_CHSELAN_Pos)
#define ADCSOCCTL10_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL10_ALL_CHSELAN_Pos)
#define ADCSOCCTL10_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL10_ALL_CHSELAN_Pos)
#define ADCSOCCTL10_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL10_ALL_CHSELAN_Pos)
#define ADCSOCCTL10_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL10_ALL_CHSELAN_Pos)
#define ADCSOCCTL10_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL10_ALL_CHSELAN_Pos)
#define ADCSOCCTL10_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL10_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     CHSELAP
 *  @access     ADC->ADCSOCCTL10.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC10
 */
#define ADCSOCCTL10_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL10_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL10_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL10_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL10_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL10_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL10_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL10_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL10_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL10_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL10_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL10_BIT_CHSELAP;

#define ADCSOCCTL10_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL10_ALL_CHSELAP_Pos)
#define ADCSOCCTL10_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL10_ALL_CHSELAP_Pos)
#define ADCSOCCTL10_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL10_ALL_CHSELAP_Pos)
#define ADCSOCCTL10_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL10_ALL_CHSELAP_Pos)
#define ADCSOCCTL10_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL10_ALL_CHSELAP_Pos)
#define ADCSOCCTL10_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL10_ALL_CHSELAP_Pos)
#define ADCSOCCTL10_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL10_ALL_CHSELAP_Pos)
#define ADCSOCCTL10_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL10_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     CHSELBN
 *  @access     ADC->ADCSOCCTL10.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC10
 */
#define ADCSOCCTL10_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL10_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL10_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL10_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL10_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL10_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL10_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL10_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL10_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL10_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL10_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL10_BIT_CHSELBN;

#define ADCSOCCTL10_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL10_ALL_CHSELBN_Pos)
#define ADCSOCCTL10_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL10_ALL_CHSELBN_Pos)
#define ADCSOCCTL10_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL10_ALL_CHSELBN_Pos)
#define ADCSOCCTL10_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL10_ALL_CHSELBN_Pos)
#define ADCSOCCTL10_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL10_ALL_CHSELBN_Pos)
#define ADCSOCCTL10_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL10_ALL_CHSELBN_Pos)
#define ADCSOCCTL10_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL10_ALL_CHSELBN_Pos)
#define ADCSOCCTL10_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL10_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     CHSELBP
 *  @access     ADC->ADCSOCCTL10.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC10
 */
#define ADCSOCCTL10_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL10_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL10_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL10_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL10_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL10_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL10_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL10_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL10_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL10_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL10_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL10_BIT_CHSELBP;

#define ADCSOCCTL10_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL10_ALL_CHSELBP_Pos)
#define ADCSOCCTL10_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL10_ALL_CHSELBP_Pos)
#define ADCSOCCTL10_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL10_ALL_CHSELBP_Pos)
#define ADCSOCCTL10_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL10_ALL_CHSELBP_Pos)
#define ADCSOCCTL10_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL10_ALL_CHSELBP_Pos)
#define ADCSOCCTL10_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL10_ALL_CHSELBP_Pos)
#define ADCSOCCTL10_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL10_ALL_CHSELBP_Pos)
#define ADCSOCCTL10_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL10_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     TRIGSEL
 *  @access     ADC->ADCSOCCTL10.bit.TRIGSEL
 *  @brief      Select SOC10 Trigger Source
 *              Configures which trigger source will set SOC10 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC10. This setting can be overridden by the respective SOC10 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL10_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL10_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL10_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL10_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL10_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL10_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL10_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL10_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL10_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL10_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL10_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL10_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL10_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL10_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL10_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL10_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL10_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL10_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL10_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL10_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL10_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL10_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL10_BIT_TRIGSEL;

#define ADCSOCCTL10_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)
#define ADCSOCCTL10_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL10_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     SHBEN
 *  @access     ADC->ADCSOCCTL10.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL10_ALL_SHBEN_Pos (30)
#define ADCSOCCTL10_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL10_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL10_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL10_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL10_BIT_SHBEN;

#define ADCSOCCTL10_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL10_ALL_SHBEN_Pos)
#define ADCSOCCTL10_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL10_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL10     SHAEN
 *  @access     ADC->ADCSOCCTL10.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL10_ALL_SHAEN_Pos (31)
#define ADCSOCCTL10_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL10_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL10_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL10_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL10_BIT_SHAEN;

#define ADCSOCCTL10_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL10_ALL_SHAEN_Pos)
#define ADCSOCCTL10_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL10_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     CONVCNT
 *  @access     ADC->ADCSOCCTL11.bit.CONVCNT
 *  @brief      Select SOC11 Convert Window Size
 */
#define ADCSOCCTL11_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL11_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL11_ALL_CONVCNT_Pos)

#define ADCSOCCTL11_BIT_CONVCNT

#define ADCSOCCTL11_ALL_CONVCNT_(x) ((x) << ADCSOCCTL11_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     SAMPCNT
 *  @access     ADC->ADCSOCCTL11.bit.SAMPCNT
 *  @brief      Select SOC11 Sample Window Size
 */
#define ADCSOCCTL11_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL11_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL11_ALL_SAMPCNT_Pos)

#define ADCSOCCTL11_BIT_SAMPCNT

#define ADCSOCCTL11_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL11_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     CHSELAN
 *  @access     ADC->ADCSOCCTL11.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC11
 */
#define ADCSOCCTL11_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL11_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL11_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL11_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL11_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL11_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL11_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL11_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL11_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL11_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL11_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL11_BIT_CHSELAN;

#define ADCSOCCTL11_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL11_ALL_CHSELAN_Pos)
#define ADCSOCCTL11_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL11_ALL_CHSELAN_Pos)
#define ADCSOCCTL11_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL11_ALL_CHSELAN_Pos)
#define ADCSOCCTL11_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL11_ALL_CHSELAN_Pos)
#define ADCSOCCTL11_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL11_ALL_CHSELAN_Pos)
#define ADCSOCCTL11_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL11_ALL_CHSELAN_Pos)
#define ADCSOCCTL11_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL11_ALL_CHSELAN_Pos)
#define ADCSOCCTL11_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL11_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     CHSELAP
 *  @access     ADC->ADCSOCCTL11.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC11
 */
#define ADCSOCCTL11_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL11_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL11_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL11_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL11_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL11_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL11_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL11_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL11_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL11_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL11_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL11_BIT_CHSELAP;

#define ADCSOCCTL11_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL11_ALL_CHSELAP_Pos)
#define ADCSOCCTL11_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL11_ALL_CHSELAP_Pos)
#define ADCSOCCTL11_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL11_ALL_CHSELAP_Pos)
#define ADCSOCCTL11_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL11_ALL_CHSELAP_Pos)
#define ADCSOCCTL11_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL11_ALL_CHSELAP_Pos)
#define ADCSOCCTL11_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL11_ALL_CHSELAP_Pos)
#define ADCSOCCTL11_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL11_ALL_CHSELAP_Pos)
#define ADCSOCCTL11_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL11_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     CHSELBN
 *  @access     ADC->ADCSOCCTL11.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC11
 */
#define ADCSOCCTL11_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL11_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL11_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL11_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL11_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL11_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL11_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL11_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL11_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL11_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL11_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL11_BIT_CHSELBN;

#define ADCSOCCTL11_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL11_ALL_CHSELBN_Pos)
#define ADCSOCCTL11_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL11_ALL_CHSELBN_Pos)
#define ADCSOCCTL11_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL11_ALL_CHSELBN_Pos)
#define ADCSOCCTL11_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL11_ALL_CHSELBN_Pos)
#define ADCSOCCTL11_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL11_ALL_CHSELBN_Pos)
#define ADCSOCCTL11_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL11_ALL_CHSELBN_Pos)
#define ADCSOCCTL11_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL11_ALL_CHSELBN_Pos)
#define ADCSOCCTL11_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL11_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     CHSELBP
 *  @access     ADC->ADCSOCCTL11.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC11
 */
#define ADCSOCCTL11_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL11_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL11_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL11_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL11_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL11_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL11_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL11_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL11_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL11_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL11_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL11_BIT_CHSELBP;

#define ADCSOCCTL11_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL11_ALL_CHSELBP_Pos)
#define ADCSOCCTL11_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL11_ALL_CHSELBP_Pos)
#define ADCSOCCTL11_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL11_ALL_CHSELBP_Pos)
#define ADCSOCCTL11_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL11_ALL_CHSELBP_Pos)
#define ADCSOCCTL11_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL11_ALL_CHSELBP_Pos)
#define ADCSOCCTL11_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL11_ALL_CHSELBP_Pos)
#define ADCSOCCTL11_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL11_ALL_CHSELBP_Pos)
#define ADCSOCCTL11_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL11_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     TRIGSEL
 *  @access     ADC->ADCSOCCTL11.bit.TRIGSEL
 *  @brief      Select SOC11 Trigger Source
 *              Configures which trigger source will set SOC11 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC11. This setting can be overridden by the respective SOC11 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL11_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL11_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL11_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL11_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL11_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL11_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL11_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL11_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL11_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL11_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL11_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL11_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL11_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL11_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL11_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL11_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL11_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL11_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL11_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL11_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL11_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL11_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL11_BIT_TRIGSEL;

#define ADCSOCCTL11_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)
#define ADCSOCCTL11_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL11_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     SHBEN
 *  @access     ADC->ADCSOCCTL11.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL11_ALL_SHBEN_Pos (30)
#define ADCSOCCTL11_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL11_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL11_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL11_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL11_BIT_SHBEN;

#define ADCSOCCTL11_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL11_ALL_SHBEN_Pos)
#define ADCSOCCTL11_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL11_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL11     SHAEN
 *  @access     ADC->ADCSOCCTL11.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL11_ALL_SHAEN_Pos (31)
#define ADCSOCCTL11_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL11_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL11_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL11_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL11_BIT_SHAEN;

#define ADCSOCCTL11_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL11_ALL_SHAEN_Pos)
#define ADCSOCCTL11_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL11_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     CONVCNT
 *  @access     ADC->ADCSOCCTL12.bit.CONVCNT
 *  @brief      Select SOC12 Convert Window Size
 */
#define ADCSOCCTL12_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL12_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL12_ALL_CONVCNT_Pos)

#define ADCSOCCTL12_BIT_CONVCNT

#define ADCSOCCTL12_ALL_CONVCNT_(x) ((x) << ADCSOCCTL12_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     SAMPCNT
 *  @access     ADC->ADCSOCCTL12.bit.SAMPCNT
 *  @brief      Select SOC12 Sample Window Size
 */
#define ADCSOCCTL12_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL12_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL12_ALL_SAMPCNT_Pos)

#define ADCSOCCTL12_BIT_SAMPCNT

#define ADCSOCCTL12_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL12_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     CHSELAN
 *  @access     ADC->ADCSOCCTL12.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC12
 */
#define ADCSOCCTL12_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL12_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL12_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL12_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL12_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL12_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL12_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL12_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL12_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL12_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL12_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL12_BIT_CHSELAN;

#define ADCSOCCTL12_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL12_ALL_CHSELAN_Pos)
#define ADCSOCCTL12_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL12_ALL_CHSELAN_Pos)
#define ADCSOCCTL12_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL12_ALL_CHSELAN_Pos)
#define ADCSOCCTL12_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL12_ALL_CHSELAN_Pos)
#define ADCSOCCTL12_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL12_ALL_CHSELAN_Pos)
#define ADCSOCCTL12_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL12_ALL_CHSELAN_Pos)
#define ADCSOCCTL12_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL12_ALL_CHSELAN_Pos)
#define ADCSOCCTL12_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL12_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     CHSELAP
 *  @access     ADC->ADCSOCCTL12.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC12
 */
#define ADCSOCCTL12_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL12_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL12_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL12_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL12_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL12_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL12_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL12_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL12_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL12_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL12_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL12_BIT_CHSELAP;

#define ADCSOCCTL12_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL12_ALL_CHSELAP_Pos)
#define ADCSOCCTL12_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL12_ALL_CHSELAP_Pos)
#define ADCSOCCTL12_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL12_ALL_CHSELAP_Pos)
#define ADCSOCCTL12_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL12_ALL_CHSELAP_Pos)
#define ADCSOCCTL12_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL12_ALL_CHSELAP_Pos)
#define ADCSOCCTL12_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL12_ALL_CHSELAP_Pos)
#define ADCSOCCTL12_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL12_ALL_CHSELAP_Pos)
#define ADCSOCCTL12_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL12_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     CHSELBN
 *  @access     ADC->ADCSOCCTL12.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC12
 */
#define ADCSOCCTL12_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL12_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL12_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL12_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL12_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL12_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL12_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL12_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL12_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL12_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL12_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL12_BIT_CHSELBN;

#define ADCSOCCTL12_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL12_ALL_CHSELBN_Pos)
#define ADCSOCCTL12_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL12_ALL_CHSELBN_Pos)
#define ADCSOCCTL12_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL12_ALL_CHSELBN_Pos)
#define ADCSOCCTL12_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL12_ALL_CHSELBN_Pos)
#define ADCSOCCTL12_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL12_ALL_CHSELBN_Pos)
#define ADCSOCCTL12_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL12_ALL_CHSELBN_Pos)
#define ADCSOCCTL12_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL12_ALL_CHSELBN_Pos)
#define ADCSOCCTL12_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL12_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     CHSELBP
 *  @access     ADC->ADCSOCCTL12.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC12
 */
#define ADCSOCCTL12_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL12_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL12_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL12_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL12_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL12_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL12_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL12_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL12_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL12_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL12_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL12_BIT_CHSELBP;

#define ADCSOCCTL12_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL12_ALL_CHSELBP_Pos)
#define ADCSOCCTL12_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL12_ALL_CHSELBP_Pos)
#define ADCSOCCTL12_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL12_ALL_CHSELBP_Pos)
#define ADCSOCCTL12_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL12_ALL_CHSELBP_Pos)
#define ADCSOCCTL12_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL12_ALL_CHSELBP_Pos)
#define ADCSOCCTL12_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL12_ALL_CHSELBP_Pos)
#define ADCSOCCTL12_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL12_ALL_CHSELBP_Pos)
#define ADCSOCCTL12_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL12_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     TRIGSEL
 *  @access     ADC->ADCSOCCTL12.bit.TRIGSEL
 *  @brief      Select SOC12 Trigger Source
 *              Configures which trigger source will set SOC12 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC12. This setting can be overridden by the respective SOC12 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL12_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL12_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL12_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL12_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL12_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL12_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL12_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL12_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL12_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL12_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL12_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL12_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL12_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL12_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL12_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL12_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL12_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL12_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL12_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL12_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL12_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL12_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL12_BIT_TRIGSEL;

#define ADCSOCCTL12_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)
#define ADCSOCCTL12_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL12_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     SHBEN
 *  @access     ADC->ADCSOCCTL12.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL12_ALL_SHBEN_Pos (30)
#define ADCSOCCTL12_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL12_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL12_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL12_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL12_BIT_SHBEN;

#define ADCSOCCTL12_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL12_ALL_SHBEN_Pos)
#define ADCSOCCTL12_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL12_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL12     SHAEN
 *  @access     ADC->ADCSOCCTL12.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL12_ALL_SHAEN_Pos (31)
#define ADCSOCCTL12_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL12_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL12_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL12_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL12_BIT_SHAEN;

#define ADCSOCCTL12_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL12_ALL_SHAEN_Pos)
#define ADCSOCCTL12_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL12_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     CONVCNT
 *  @access     ADC->ADCSOCCTL13.bit.CONVCNT
 *  @brief      Select SOC13 Convert Window Size
 */
#define ADCSOCCTL13_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL13_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL13_ALL_CONVCNT_Pos)

#define ADCSOCCTL13_BIT_CONVCNT

#define ADCSOCCTL13_ALL_CONVCNT_(x) ((x) << ADCSOCCTL13_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     SAMPCNT
 *  @access     ADC->ADCSOCCTL13.bit.SAMPCNT
 *  @brief      Select SOC13 Sample Window Size
 */
#define ADCSOCCTL13_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL13_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL13_ALL_SAMPCNT_Pos)

#define ADCSOCCTL13_BIT_SAMPCNT

#define ADCSOCCTL13_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL13_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     CHSELAN
 *  @access     ADC->ADCSOCCTL13.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC13
 */
#define ADCSOCCTL13_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL13_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL13_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL13_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL13_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL13_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL13_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL13_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL13_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL13_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL13_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL13_BIT_CHSELAN;

#define ADCSOCCTL13_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL13_ALL_CHSELAN_Pos)
#define ADCSOCCTL13_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL13_ALL_CHSELAN_Pos)
#define ADCSOCCTL13_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL13_ALL_CHSELAN_Pos)
#define ADCSOCCTL13_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL13_ALL_CHSELAN_Pos)
#define ADCSOCCTL13_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL13_ALL_CHSELAN_Pos)
#define ADCSOCCTL13_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL13_ALL_CHSELAN_Pos)
#define ADCSOCCTL13_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL13_ALL_CHSELAN_Pos)
#define ADCSOCCTL13_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL13_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     CHSELAP
 *  @access     ADC->ADCSOCCTL13.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC13
 */
#define ADCSOCCTL13_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL13_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL13_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL13_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL13_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL13_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL13_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL13_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL13_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL13_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL13_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL13_BIT_CHSELAP;

#define ADCSOCCTL13_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL13_ALL_CHSELAP_Pos)
#define ADCSOCCTL13_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL13_ALL_CHSELAP_Pos)
#define ADCSOCCTL13_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL13_ALL_CHSELAP_Pos)
#define ADCSOCCTL13_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL13_ALL_CHSELAP_Pos)
#define ADCSOCCTL13_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL13_ALL_CHSELAP_Pos)
#define ADCSOCCTL13_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL13_ALL_CHSELAP_Pos)
#define ADCSOCCTL13_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL13_ALL_CHSELAP_Pos)
#define ADCSOCCTL13_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL13_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     CHSELBN
 *  @access     ADC->ADCSOCCTL13.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC13
 */
#define ADCSOCCTL13_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL13_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL13_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL13_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL13_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL13_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL13_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL13_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL13_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL13_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL13_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL13_BIT_CHSELBN;

#define ADCSOCCTL13_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL13_ALL_CHSELBN_Pos)
#define ADCSOCCTL13_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL13_ALL_CHSELBN_Pos)
#define ADCSOCCTL13_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL13_ALL_CHSELBN_Pos)
#define ADCSOCCTL13_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL13_ALL_CHSELBN_Pos)
#define ADCSOCCTL13_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL13_ALL_CHSELBN_Pos)
#define ADCSOCCTL13_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL13_ALL_CHSELBN_Pos)
#define ADCSOCCTL13_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL13_ALL_CHSELBN_Pos)
#define ADCSOCCTL13_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL13_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     CHSELBP
 *  @access     ADC->ADCSOCCTL13.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC13
 */
#define ADCSOCCTL13_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL13_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL13_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL13_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL13_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL13_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL13_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL13_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL13_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL13_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL13_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL13_BIT_CHSELBP;

#define ADCSOCCTL13_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL13_ALL_CHSELBP_Pos)
#define ADCSOCCTL13_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL13_ALL_CHSELBP_Pos)
#define ADCSOCCTL13_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL13_ALL_CHSELBP_Pos)
#define ADCSOCCTL13_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL13_ALL_CHSELBP_Pos)
#define ADCSOCCTL13_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL13_ALL_CHSELBP_Pos)
#define ADCSOCCTL13_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL13_ALL_CHSELBP_Pos)
#define ADCSOCCTL13_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL13_ALL_CHSELBP_Pos)
#define ADCSOCCTL13_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL13_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     TRIGSEL
 *  @access     ADC->ADCSOCCTL13.bit.TRIGSEL
 *  @brief      Select SOC13 Trigger Source
 *              Configures which trigger source will set SOC13 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC13. This setting can be overridden by the respective SOC13 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL13_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL13_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL13_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL13_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL13_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL13_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL13_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL13_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL13_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL13_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL13_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL13_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL13_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL13_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL13_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL13_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL13_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL13_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL13_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL13_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL13_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL13_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL13_BIT_TRIGSEL;

#define ADCSOCCTL13_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)
#define ADCSOCCTL13_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL13_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     SHBEN
 *  @access     ADC->ADCSOCCTL13.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL13_ALL_SHBEN_Pos (30)
#define ADCSOCCTL13_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL13_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL13_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL13_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL13_BIT_SHBEN;

#define ADCSOCCTL13_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL13_ALL_SHBEN_Pos)
#define ADCSOCCTL13_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL13_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL13     SHAEN
 *  @access     ADC->ADCSOCCTL13.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL13_ALL_SHAEN_Pos (31)
#define ADCSOCCTL13_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL13_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL13_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL13_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL13_BIT_SHAEN;

#define ADCSOCCTL13_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL13_ALL_SHAEN_Pos)
#define ADCSOCCTL13_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL13_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     CONVCNT
 *  @access     ADC->ADCSOCCTL14.bit.CONVCNT
 *  @brief      Select SOC14 Convert Window Size
 */
#define ADCSOCCTL14_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL14_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL14_ALL_CONVCNT_Pos)

#define ADCSOCCTL14_BIT_CONVCNT

#define ADCSOCCTL14_ALL_CONVCNT_(x) ((x) << ADCSOCCTL14_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     SAMPCNT
 *  @access     ADC->ADCSOCCTL14.bit.SAMPCNT
 *  @brief      Select SOC14 Sample Window Size
 */
#define ADCSOCCTL14_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL14_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL14_ALL_SAMPCNT_Pos)

#define ADCSOCCTL14_BIT_SAMPCNT

#define ADCSOCCTL14_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL14_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     CHSELAN
 *  @access     ADC->ADCSOCCTL14.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC14
 */
#define ADCSOCCTL14_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL14_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL14_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL14_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL14_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL14_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL14_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL14_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL14_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL14_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL14_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL14_BIT_CHSELAN;

#define ADCSOCCTL14_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL14_ALL_CHSELAN_Pos)
#define ADCSOCCTL14_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL14_ALL_CHSELAN_Pos)
#define ADCSOCCTL14_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL14_ALL_CHSELAN_Pos)
#define ADCSOCCTL14_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL14_ALL_CHSELAN_Pos)
#define ADCSOCCTL14_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL14_ALL_CHSELAN_Pos)
#define ADCSOCCTL14_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL14_ALL_CHSELAN_Pos)
#define ADCSOCCTL14_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL14_ALL_CHSELAN_Pos)
#define ADCSOCCTL14_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL14_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     CHSELAP
 *  @access     ADC->ADCSOCCTL14.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC14
 */
#define ADCSOCCTL14_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL14_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL14_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL14_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL14_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL14_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL14_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL14_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL14_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL14_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL14_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL14_BIT_CHSELAP;

#define ADCSOCCTL14_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL14_ALL_CHSELAP_Pos)
#define ADCSOCCTL14_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL14_ALL_CHSELAP_Pos)
#define ADCSOCCTL14_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL14_ALL_CHSELAP_Pos)
#define ADCSOCCTL14_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL14_ALL_CHSELAP_Pos)
#define ADCSOCCTL14_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL14_ALL_CHSELAP_Pos)
#define ADCSOCCTL14_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL14_ALL_CHSELAP_Pos)
#define ADCSOCCTL14_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL14_ALL_CHSELAP_Pos)
#define ADCSOCCTL14_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL14_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     CHSELBN
 *  @access     ADC->ADCSOCCTL14.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC14
 */
#define ADCSOCCTL14_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL14_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL14_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL14_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL14_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL14_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL14_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL14_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL14_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL14_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL14_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL14_BIT_CHSELBN;

#define ADCSOCCTL14_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL14_ALL_CHSELBN_Pos)
#define ADCSOCCTL14_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL14_ALL_CHSELBN_Pos)
#define ADCSOCCTL14_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL14_ALL_CHSELBN_Pos)
#define ADCSOCCTL14_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL14_ALL_CHSELBN_Pos)
#define ADCSOCCTL14_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL14_ALL_CHSELBN_Pos)
#define ADCSOCCTL14_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL14_ALL_CHSELBN_Pos)
#define ADCSOCCTL14_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL14_ALL_CHSELBN_Pos)
#define ADCSOCCTL14_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL14_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     CHSELBP
 *  @access     ADC->ADCSOCCTL14.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC14
 */
#define ADCSOCCTL14_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL14_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL14_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL14_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL14_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL14_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL14_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL14_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL14_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL14_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL14_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL14_BIT_CHSELBP;

#define ADCSOCCTL14_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL14_ALL_CHSELBP_Pos)
#define ADCSOCCTL14_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL14_ALL_CHSELBP_Pos)
#define ADCSOCCTL14_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL14_ALL_CHSELBP_Pos)
#define ADCSOCCTL14_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL14_ALL_CHSELBP_Pos)
#define ADCSOCCTL14_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL14_ALL_CHSELBP_Pos)
#define ADCSOCCTL14_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL14_ALL_CHSELBP_Pos)
#define ADCSOCCTL14_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL14_ALL_CHSELBP_Pos)
#define ADCSOCCTL14_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL14_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     TRIGSEL
 *  @access     ADC->ADCSOCCTL14.bit.TRIGSEL
 *  @brief      Select SOC14 Trigger Source
 *              Configures which trigger source will set SOC14 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC14. This setting can be overridden by the respective SOC14 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL14_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL14_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL14_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL14_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL14_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL14_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL14_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL14_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL14_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL14_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL14_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL14_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL14_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL14_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL14_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL14_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL14_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL14_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL14_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL14_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL14_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL14_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL14_BIT_TRIGSEL;

#define ADCSOCCTL14_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)
#define ADCSOCCTL14_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL14_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     SHBEN
 *  @access     ADC->ADCSOCCTL14.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL14_ALL_SHBEN_Pos (30)
#define ADCSOCCTL14_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL14_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL14_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL14_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL14_BIT_SHBEN;

#define ADCSOCCTL14_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL14_ALL_SHBEN_Pos)
#define ADCSOCCTL14_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL14_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL14     SHAEN
 *  @access     ADC->ADCSOCCTL14.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL14_ALL_SHAEN_Pos (31)
#define ADCSOCCTL14_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL14_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL14_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL14_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL14_BIT_SHAEN;

#define ADCSOCCTL14_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL14_ALL_SHAEN_Pos)
#define ADCSOCCTL14_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL14_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     CONVCNT
 *  @access     ADC->ADCSOCCTL15.bit.CONVCNT
 *  @brief      Select SOC15 Convert Window Size
 */
#define ADCSOCCTL15_ALL_CONVCNT_Pos (0)
#define ADCSOCCTL15_ALL_CONVCNT_Msk (0x3FUL << ADCSOCCTL15_ALL_CONVCNT_Pos)

#define ADCSOCCTL15_BIT_CONVCNT

#define ADCSOCCTL15_ALL_CONVCNT_(x) ((x) << ADCSOCCTL15_ALL_CONVCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     SAMPCNT
 *  @access     ADC->ADCSOCCTL15.bit.SAMPCNT
 *  @brief      Select SOC15 Sample Window Size
 */
#define ADCSOCCTL15_ALL_SAMPCNT_Pos (6)
#define ADCSOCCTL15_ALL_SAMPCNT_Msk (0x7FUL << ADCSOCCTL15_ALL_SAMPCNT_Pos)

#define ADCSOCCTL15_BIT_SAMPCNT

#define ADCSOCCTL15_ALL_SAMPCNT_(x) ((x) << ADCSOCCTL15_ALL_SAMPCNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     CHSELAN
 *  @access     ADC->ADCSOCCTL15.bit.CHSELAN
 *  @brief      Select channel to negative terminal of SHA for SOC15
 */
#define ADCSOCCTL15_ALL_CHSELAN_Pos (13)
#define ADCSOCCTL15_ALL_CHSELAN_Msk (0x7UL << ADCSOCCTL15_ALL_CHSELAN_Pos)

typedef enum
{
    ADCSOCCTL15_BIT_CHSELAN_PGA0N_OUT     = 0,  /*!< Negative output of PGA0    */
    ADCSOCCTL15_BIT_CHSELAN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL15_BIT_CHSELAN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL15_BIT_CHSELAN_VDDA          = 3,  /*!< VDDA                       */
    ADCSOCCTL15_BIT_CHSELAN_ADC4          = 4,  /*!< GPIO5                      */
    ADCSOCCTL15_BIT_CHSELAN_ADC5          = 5,  /*!< GPIO6                      */
    ADCSOCCTL15_BIT_CHSELAN_ADC6          = 6,  /*!< GPIO7                      */
    ADCSOCCTL15_BIT_CHSELAN_ADC7          = 7,  /*!< GPIO8                      */
} ADCSOCCTL15_BIT_CHSELAN;

#define ADCSOCCTL15_ALL_CHSELAN_PGA0N_OUT     ((0x0UL) << ADCSOCCTL15_ALL_CHSELAN_Pos)
#define ADCSOCCTL15_ALL_CHSELAN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL15_ALL_CHSELAN_Pos)
#define ADCSOCCTL15_ALL_CHSELAN_GND           ((0x2UL) << ADCSOCCTL15_ALL_CHSELAN_Pos)
#define ADCSOCCTL15_ALL_CHSELAN_VDDA          ((0x3UL) << ADCSOCCTL15_ALL_CHSELAN_Pos)
#define ADCSOCCTL15_ALL_CHSELAN_ADC4          ((0x4UL) << ADCSOCCTL15_ALL_CHSELAN_Pos)
#define ADCSOCCTL15_ALL_CHSELAN_ADC5          ((0x5UL) << ADCSOCCTL15_ALL_CHSELAN_Pos)
#define ADCSOCCTL15_ALL_CHSELAN_ADC6          ((0x6UL) << ADCSOCCTL15_ALL_CHSELAN_Pos)
#define ADCSOCCTL15_ALL_CHSELAN_ADC7          ((0x7UL) << ADCSOCCTL15_ALL_CHSELAN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     CHSELAP
 *  @access     ADC->ADCSOCCTL15.bit.CHSELAP
 *  @brief      Select channel to positive terminal of SHA for SOC15
 */
#define ADCSOCCTL15_ALL_CHSELAP_Pos (16)
#define ADCSOCCTL15_ALL_CHSELAP_Msk (0x7UL << ADCSOCCTL15_ALL_CHSELAP_Pos)

typedef enum
{
    ADCSOCCTL15_BIT_CHSELAP_PGA0P_OUT     = 0,  /*!< Positive output of PGA0    */
    ADCSOCCTL15_BIT_CHSELAP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL15_BIT_CHSELAP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL15_BIT_CHSELAP_VDD12         = 3,  /*!< VDD12                      */
    ADCSOCCTL15_BIT_CHSELAP_ADC0          = 4,  /*!< GPIO1                      */
    ADCSOCCTL15_BIT_CHSELAP_ADC1          = 5,  /*!< GPIO2                      */
    ADCSOCCTL15_BIT_CHSELAP_ADC2          = 6,  /*!< GPIO3                      */
    ADCSOCCTL15_BIT_CHSELAP_ADC3          = 7,  /*!< GPIO4                      */
} ADCSOCCTL15_BIT_CHSELAP;

#define ADCSOCCTL15_ALL_CHSELAP_PGA0P_OUT     ((0x0UL) << ADCSOCCTL15_ALL_CHSELAP_Pos)
#define ADCSOCCTL15_ALL_CHSELAP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL15_ALL_CHSELAP_Pos)
#define ADCSOCCTL15_ALL_CHSELAP_GND           ((0x2UL) << ADCSOCCTL15_ALL_CHSELAP_Pos)
#define ADCSOCCTL15_ALL_CHSELAP_VDD12         ((0x3UL) << ADCSOCCTL15_ALL_CHSELAP_Pos)
#define ADCSOCCTL15_ALL_CHSELAP_ADC0          ((0x4UL) << ADCSOCCTL15_ALL_CHSELAP_Pos)
#define ADCSOCCTL15_ALL_CHSELAP_ADC1          ((0x5UL) << ADCSOCCTL15_ALL_CHSELAP_Pos)
#define ADCSOCCTL15_ALL_CHSELAP_ADC2          ((0x6UL) << ADCSOCCTL15_ALL_CHSELAP_Pos)
#define ADCSOCCTL15_ALL_CHSELAP_ADC3          ((0x7UL) << ADCSOCCTL15_ALL_CHSELAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     CHSELBN
 *  @access     ADC->ADCSOCCTL15.bit.CHSELBN
 *  @brief      Select channel to negative terminal of SHB for SOC15
 */
#define ADCSOCCTL15_ALL_CHSELBN_Pos (19)
#define ADCSOCCTL15_ALL_CHSELBN_Msk (0x7UL << ADCSOCCTL15_ALL_CHSELBN_Pos)

typedef enum
{
    ADCSOCCTL15_BIT_CHSELBN_PGA2N_OUT     = 0,  /*!< Negative output of PGA2    */
    ADCSOCCTL15_BIT_CHSELBN_PGA1N_OUT     = 1,  /*!< Negative output of PGA1    */
    ADCSOCCTL15_BIT_CHSELBN_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL15_BIT_CHSELBN_TSENSOR0      = 3,  /*!< T-sensor output 0          */
    ADCSOCCTL15_BIT_CHSELBN_ADC12         = 4,  /*!< GPIO13                     */
    ADCSOCCTL15_BIT_CHSELBN_ADC13         = 5,  /*!< GPIO14                     */
    ADCSOCCTL15_BIT_CHSELBN_ADC14         = 6,  /*!< GPIO15                     */
    ADCSOCCTL15_BIT_CHSELBN_ADC15         = 7,  /*!< GPIO16                     */
} ADCSOCCTL15_BIT_CHSELBN;

#define ADCSOCCTL15_ALL_CHSELBN_PGA2N_OUT     ((0x0UL) << ADCSOCCTL15_ALL_CHSELBN_Pos)
#define ADCSOCCTL15_ALL_CHSELBN_PGA1N_OUT     ((0x1UL) << ADCSOCCTL15_ALL_CHSELBN_Pos)
#define ADCSOCCTL15_ALL_CHSELBN_GND           ((0x2UL) << ADCSOCCTL15_ALL_CHSELBN_Pos)
#define ADCSOCCTL15_ALL_CHSELBN_TSENSOR0      ((0x3UL) << ADCSOCCTL15_ALL_CHSELBN_Pos)
#define ADCSOCCTL15_ALL_CHSELBN_ADC12         ((0x4UL) << ADCSOCCTL15_ALL_CHSELBN_Pos)
#define ADCSOCCTL15_ALL_CHSELBN_ADC13         ((0x5UL) << ADCSOCCTL15_ALL_CHSELBN_Pos)
#define ADCSOCCTL15_ALL_CHSELBN_ADC14         ((0x6UL) << ADCSOCCTL15_ALL_CHSELBN_Pos)
#define ADCSOCCTL15_ALL_CHSELBN_ADC15         ((0x7UL) << ADCSOCCTL15_ALL_CHSELBN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     CHSELBP
 *  @access     ADC->ADCSOCCTL15.bit.CHSELBP
 *  @brief      Select channel to positive terminal of SHB for SOC15
 */
#define ADCSOCCTL15_ALL_CHSELBP_Pos (22)
#define ADCSOCCTL15_ALL_CHSELBP_Msk (0x7UL << ADCSOCCTL15_ALL_CHSELBP_Pos)

typedef enum
{
    ADCSOCCTL15_BIT_CHSELBP_PGA2P_OUT     = 0,  /*!< Positive output of PGA2    */
    ADCSOCCTL15_BIT_CHSELBP_PGA1P_OUT     = 1,  /*!< Positive output of PGA1    */
    ADCSOCCTL15_BIT_CHSELBP_GND           = 2,  /*!< VSSA                       */
    ADCSOCCTL15_BIT_CHSELBP_TSENSOR1      = 3,  /*!< T-sensor output 1          */
    ADCSOCCTL15_BIT_CHSELBP_ADC8          = 4,  /*!< GPIO9                      */
    ADCSOCCTL15_BIT_CHSELBP_ADC9          = 5,  /*!< GPIO10                     */
    ADCSOCCTL15_BIT_CHSELBP_ADC10         = 6,  /*!< GPIO11                     */
    ADCSOCCTL15_BIT_CHSELBP_ADC11         = 7,  /*!< GPIO12                     */
} ADCSOCCTL15_BIT_CHSELBP;

#define ADCSOCCTL15_ALL_CHSELBP_PGA2P_OUT     ((0x0UL) << ADCSOCCTL15_ALL_CHSELBP_Pos)
#define ADCSOCCTL15_ALL_CHSELBP_PGA1P_OUT     ((0x1UL) << ADCSOCCTL15_ALL_CHSELBP_Pos)
#define ADCSOCCTL15_ALL_CHSELBP_GND           ((0x2UL) << ADCSOCCTL15_ALL_CHSELBP_Pos)
#define ADCSOCCTL15_ALL_CHSELBP_TSENSOR1      ((0x3UL) << ADCSOCCTL15_ALL_CHSELBP_Pos)
#define ADCSOCCTL15_ALL_CHSELBP_ADC8          ((0x4UL) << ADCSOCCTL15_ALL_CHSELBP_Pos)
#define ADCSOCCTL15_ALL_CHSELBP_ADC9          ((0x5UL) << ADCSOCCTL15_ALL_CHSELBP_Pos)
#define ADCSOCCTL15_ALL_CHSELBP_ADC10         ((0x6UL) << ADCSOCCTL15_ALL_CHSELBP_Pos)
#define ADCSOCCTL15_ALL_CHSELBP_ADC11         ((0x7UL) << ADCSOCCTL15_ALL_CHSELBP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     TRIGSEL
 *  @access     ADC->ADCSOCCTL15.bit.TRIGSEL
 *  @brief      Select SOC15 Trigger Source
 *              Configures which trigger source will set SOC15 flag in the ADCSOCFLG Register. The Flag will initiate a conversion to start once and the priority is given to SOC15. This setting can be overridden by the respective SOC15 Field in the ADCINTSOCSEL0~2 Registers.
 */
#define ADCSOCCTL15_ALL_TRIGSEL_Pos (25)
#define ADCSOCCTL15_ALL_TRIGSEL_Msk (0x1FUL << ADCSOCCTL15_ALL_TRIGSEL_Pos)

typedef enum
{
    ADCSOCCTL15_BIT_TRIGSEL_SOFTWARE     = 0,  /*!< ADCTRIG0 - Software only   */
    ADCSOCCTL15_BIT_TRIGSEL_TIMER0       = 1,  /*!< ADCTRIG1 - CPU Timer 0     */
    ADCSOCCTL15_BIT_TRIGSEL_TIMER1       = 2,  /*!< ADCTRIG2 - CPU Timer 1     */
    ADCSOCCTL15_BIT_TRIGSEL_TIMER2       = 3,  /*!< ADCTRIG3 - CPU Timer 2     */
    ADCSOCCTL15_BIT_TRIGSEL_XINT2        = 4,  /*!< ADCTRIG4 - XINT2           */
    ADCSOCCTL15_BIT_TRIGSEL_PWM0A        = 5,  /*!< ADCTRIG5 - PWM0A           */
    ADCSOCCTL15_BIT_TRIGSEL_PWM0B        = 6,  /*!< ADCTRIG6 - PWM0B           */
    ADCSOCCTL15_BIT_TRIGSEL_PWM1A        = 7,  /*!< ADCTRIG7 - PWM1A           */
    ADCSOCCTL15_BIT_TRIGSEL_PWM1B        = 8,  /*!< ADCTRIG8 - PWM1B           */
    ADCSOCCTL15_BIT_TRIGSEL_PWM2A        = 9,  /*!< ADCTRIG9 - PWM2A           */
    ADCSOCCTL15_BIT_TRIGSEL_PWM2B        = 10,  /*!< ADCTRIG10 - PWM2B          */
    ADCSOCCTL15_BIT_TRIGSEL_PWM3A        = 11,  /*!< ADCTRIG11 - PWM3A          */
    ADCSOCCTL15_BIT_TRIGSEL_PWM3B        = 12,  /*!< ADCTRIG12 - PWM3B          */
    ADCSOCCTL15_BIT_TRIGSEL_PWM4A        = 13,  /*!< ADCTRIG13 - PWM4A          */
    ADCSOCCTL15_BIT_TRIGSEL_PWM4B        = 14,  /*!< ADCTRIG14 - PWM4B          */
    ADCSOCCTL15_BIT_TRIGSEL_PWM5A        = 15,  /*!< ADCTRIG15 - PWM5A          */
    ADCSOCCTL15_BIT_TRIGSEL_PWM5B        = 16,  /*!< ADCTRIG16 - PWM5B          */
    ADCSOCCTL15_BIT_TRIGSEL_PWM6A        = 17,  /*!< ADCTRIG17 - PWM6A          */
    ADCSOCCTL15_BIT_TRIGSEL_PWM6B        = 18,  /*!< ADCTRIG18 - PWM6B          */
} ADCSOCCTL15_BIT_TRIGSEL;

#define ADCSOCCTL15_ALL_TRIGSEL_SOFTWARE     ((0x00UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_TIMER0       ((0x01UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_TIMER1       ((0x02UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_TIMER2       ((0x03UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_XINT2        ((0x04UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM0A        ((0x05UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM0B        ((0x06UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM1A        ((0x07UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM1B        ((0x08UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM2A        ((0x09UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM2B        ((0x0AUL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM3A        ((0x0BUL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM3B        ((0x0CUL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM4A        ((0x0DUL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM4B        ((0x0EUL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM5A        ((0x0FUL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM5B        ((0x10UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM6A        ((0x11UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)
#define ADCSOCCTL15_ALL_TRIGSEL_PWM6B        ((0x12UL) << ADCSOCCTL15_ALL_TRIGSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     SHBEN
 *  @access     ADC->ADCSOCCTL15.bit.SHBEN
 *  @brief      Enable Sample and Hold B(SHB) to sample input of CHSELBP and CHSELBN
 */
#define ADCSOCCTL15_ALL_SHBEN_Pos (30)
#define ADCSOCCTL15_ALL_SHBEN_Msk (0x1UL << ADCSOCCTL15_ALL_SHBEN_Pos)

typedef enum
{
    ADCSOCCTL15_BIT_SHBEN_DISABLE     = 0,  /*!< Disable SHB to sample    */
    ADCSOCCTL15_BIT_SHBEN_ENABLE      = 1,  /*!< Enable SHB to sample     */
} ADCSOCCTL15_BIT_SHBEN;

#define ADCSOCCTL15_ALL_SHBEN_DISABLE     ((0x0UL) << ADCSOCCTL15_ALL_SHBEN_Pos)
#define ADCSOCCTL15_ALL_SHBEN_ENABLE      ((0x1UL) << ADCSOCCTL15_ALL_SHBEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSOCCTL15     SHAEN
 *  @access     ADC->ADCSOCCTL15.bit.SHAEN
 *  @brief      Enable Sample and Hold A(SHA) to sample input of CHSELAP and CHSELAN
 */
#define ADCSOCCTL15_ALL_SHAEN_Pos (31)
#define ADCSOCCTL15_ALL_SHAEN_Msk (0x1UL << ADCSOCCTL15_ALL_SHAEN_Pos)

typedef enum
{
    ADCSOCCTL15_BIT_SHAEN_DISABLE     = 0,  /*!< Disable SHA to sample    */
    ADCSOCCTL15_BIT_SHAEN_ENABLE      = 1,  /*!< Enable SHA to sample     */
} ADCSOCCTL15_BIT_SHAEN;

#define ADCSOCCTL15_ALL_SHAEN_DISABLE     ((0x0UL) << ADCSOCCTL15_ALL_SHAEN_Pos)
#define ADCSOCCTL15_ALL_SHAEN_ENABLE      ((0x1UL) << ADCSOCCTL15_ALL_SHAEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCGAINTRIM     SHAGAIN
 *  @access     ADC->ADCGAINTRIM.bit.SHAGAIN
 *  @brief      Gain Error Register 0. It will store the gain-error of SHA and ADC core.
 */
#define ADCGAINTRIM_ALL_SHAGAIN_Pos (0)
#define ADCGAINTRIM_ALL_SHAGAIN_Msk (0xFFFFUL << ADCGAINTRIM_ALL_SHAGAIN_Pos)

#define ADCGAINTRIM_BIT_SHAGAIN

#define ADCGAINTRIM_ALL_SHAGAIN_(x) ((x) << ADCGAINTRIM_ALL_SHAGAIN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCGAINTRIM     SHBGAIN
 *  @access     ADC->ADCGAINTRIM.bit.SHBGAIN
 *  @brief      Gain Error Register 1. It will store the gain-error of SHB and ADC core.
 */
#define ADCGAINTRIM_ALL_SHBGAIN_Pos (16)
#define ADCGAINTRIM_ALL_SHBGAIN_Msk (0xFFFFUL << ADCGAINTRIM_ALL_SHBGAIN_Pos)

#define ADCGAINTRIM_BIT_SHBGAIN

#define ADCGAINTRIM_ALL_SHBGAIN_(x) ((x) << ADCGAINTRIM_ALL_SHBGAIN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCOFFSETTRIM   SHAOFFSET
 *  @access     ADC->ADCOFFSETTRIM.bit.SHAOFFSET
 *  @brief      Offset Error Register 0. It will store the offset-error of SHA and ADC core.
 */
#define ADCOFFSETTRIM_ALL_SHAOFFSET_Pos (0)
#define ADCOFFSETTRIM_ALL_SHAOFFSET_Msk (0x1FFUL << ADCOFFSETTRIM_ALL_SHAOFFSET_Pos)

#define ADCOFFSETTRIM_BIT_SHAOFFSET

#define ADCOFFSETTRIM_ALL_SHAOFFSET_(x) ((x) << ADCOFFSETTRIM_ALL_SHAOFFSET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCOFFSETTRIM   SHBOFFSET
 *  @access     ADC->ADCOFFSETTRIM.bit.SHBOFFSET
 *  @brief      Offset Error Register 1. It will store the offset-error of SHB and ADC core.
 */
#define ADCOFFSETTRIM_ALL_SHBOFFSET_Pos (9)
#define ADCOFFSETTRIM_ALL_SHBOFFSET_Msk (0x1FFUL << ADCOFFSETTRIM_ALL_SHBOFFSET_Pos)

#define ADCOFFSETTRIM_BIT_SHBOFFSET

#define ADCOFFSETTRIM_ALL_SHBOFFSET_(x) ((x) << ADCOFFSETTRIM_ALL_SHBOFFSET_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT0      VAL
 *  @access     ADC->ADCRESULT0.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC0, the digital result is placed in the corresponding ADCRESULT0 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC0, the completed results of those conversions will be placed in ADCRESULT0 and ADCRESULT1.
 */
#define ADCRESULT0_ALL_VAL_Pos (0)
#define ADCRESULT0_ALL_VAL_Msk (0x1FFFUL << ADCRESULT0_ALL_VAL_Pos)

#define ADCRESULT0_BIT_VAL

#define ADCRESULT0_ALL_VAL_(x) ((x) << ADCRESULT0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT1      VAL
 *  @access     ADC->ADCRESULT1.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC1, the digital result is placed in the corresponding ADCRESULT1 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC0, the completed results of those conversions will be placed in ADCRESULT0 and ADCRESULT1.
 */
#define ADCRESULT1_ALL_VAL_Pos (0)
#define ADCRESULT1_ALL_VAL_Msk (0x1FFFUL << ADCRESULT1_ALL_VAL_Pos)

#define ADCRESULT1_BIT_VAL

#define ADCRESULT1_ALL_VAL_(x) ((x) << ADCRESULT1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT2      VAL
 *  @access     ADC->ADCRESULT2.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC2, the digital result is placed in the corresponding ADCRESULT2 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC2, the completed results of those conversions will be placed in ADCRESULT2 and ADCRESULT3.
 */
#define ADCRESULT2_ALL_VAL_Pos (0)
#define ADCRESULT2_ALL_VAL_Msk (0x1FFFUL << ADCRESULT2_ALL_VAL_Pos)

#define ADCRESULT2_BIT_VAL

#define ADCRESULT2_ALL_VAL_(x) ((x) << ADCRESULT2_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT3      VAL
 *  @access     ADC->ADCRESULT3.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC3, the digital result is placed in the corresponding ADCRESULT3 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC2, the completed results of those conversions will be placed in ADCRESULT2 and ADCRESULT3.
 */
#define ADCRESULT3_ALL_VAL_Pos (0)
#define ADCRESULT3_ALL_VAL_Msk (0x1FFFUL << ADCRESULT3_ALL_VAL_Pos)

#define ADCRESULT3_BIT_VAL

#define ADCRESULT3_ALL_VAL_(x) ((x) << ADCRESULT3_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT4      VAL
 *  @access     ADC->ADCRESULT4.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC4, the digital result is placed in the corresponding ADCRESULT4 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC4, the completed results of those conversions will be placed in ADCRESULT4 and ADCRESULT5.
 */
#define ADCRESULT4_ALL_VAL_Pos (0)
#define ADCRESULT4_ALL_VAL_Msk (0x1FFFUL << ADCRESULT4_ALL_VAL_Pos)

#define ADCRESULT4_BIT_VAL

#define ADCRESULT4_ALL_VAL_(x) ((x) << ADCRESULT4_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT5      VAL
 *  @access     ADC->ADCRESULT5.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC5, the digital result is placed in the corresponding ADCRESULT5 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC4, the completed results of those conversions will be placed in ADCRESULT4 and ADCRESULT5.
 */
#define ADCRESULT5_ALL_VAL_Pos (0)
#define ADCRESULT5_ALL_VAL_Msk (0x1FFFUL << ADCRESULT5_ALL_VAL_Pos)

#define ADCRESULT5_BIT_VAL

#define ADCRESULT5_ALL_VAL_(x) ((x) << ADCRESULT5_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT6      VAL
 *  @access     ADC->ADCRESULT6.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC6, the digital result is placed in the corresponding ADCRESULT6 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC6, the completed results of those conversions will be placed in ADCRESULT6 and ADCRESULT7.
 */
#define ADCRESULT6_ALL_VAL_Pos (0)
#define ADCRESULT6_ALL_VAL_Msk (0x1FFFUL << ADCRESULT6_ALL_VAL_Pos)

#define ADCRESULT6_BIT_VAL

#define ADCRESULT6_ALL_VAL_(x) ((x) << ADCRESULT6_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT7      VAL
 *  @access     ADC->ADCRESULT7.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC7, the digital result is placed in the corresponding ADCRESULT7 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC6, the completed results of those conversions will be placed in ADCRESULT6 and ADCRESULT7.
 */
#define ADCRESULT7_ALL_VAL_Pos (0)
#define ADCRESULT7_ALL_VAL_Msk (0x1FFFUL << ADCRESULT7_ALL_VAL_Pos)

#define ADCRESULT7_BIT_VAL

#define ADCRESULT7_ALL_VAL_(x) ((x) << ADCRESULT7_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT8      VAL
 *  @access     ADC->ADCRESULT8.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC8, the digital result is placed in the corresponding ADCRESULT8 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC8, the completed results of those conversions will be placed in ADCRESULT8 and ADCRESULT9.
 */
#define ADCRESULT8_ALL_VAL_Pos (0)
#define ADCRESULT8_ALL_VAL_Msk (0x1FFFUL << ADCRESULT8_ALL_VAL_Pos)

#define ADCRESULT8_BIT_VAL

#define ADCRESULT8_ALL_VAL_(x) ((x) << ADCRESULT8_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT9      VAL
 *  @access     ADC->ADCRESULT9.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC9, the digital result is placed in the corresponding ADCRESULT9 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC8, the completed results of those conversions will be placed in ADCRESULT8 and ADCRESULT9.
 */
#define ADCRESULT9_ALL_VAL_Pos (0)
#define ADCRESULT9_ALL_VAL_Msk (0x1FFFUL << ADCRESULT9_ALL_VAL_Pos)

#define ADCRESULT9_BIT_VAL

#define ADCRESULT9_ALL_VAL_(x) ((x) << ADCRESULT9_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT10     VAL
 *  @access     ADC->ADCRESULT10.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC10, the digital result is placed in the corresponding ADCRESULT10 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC10, the completed results of those conversions will be placed in ADCRESULT10 and ADCRESULT11.
 */
#define ADCRESULT10_ALL_VAL_Pos (0)
#define ADCRESULT10_ALL_VAL_Msk (0x1FFFUL << ADCRESULT10_ALL_VAL_Pos)

#define ADCRESULT10_BIT_VAL

#define ADCRESULT10_ALL_VAL_(x) ((x) << ADCRESULT10_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT11     VAL
 *  @access     ADC->ADCRESULT11.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC11, the digital result is placed in the corresponding ADCRESULT11 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC10, the completed results of those conversions will be placed in ADCRESULT10 and ADCRESULT11.
 */
#define ADCRESULT11_ALL_VAL_Pos (0)
#define ADCRESULT11_ALL_VAL_Msk (0x1FFFUL << ADCRESULT11_ALL_VAL_Pos)

#define ADCRESULT11_BIT_VAL

#define ADCRESULT11_ALL_VAL_(x) ((x) << ADCRESULT11_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT12     VAL
 *  @access     ADC->ADCRESULT12.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC12, the digital result is placed in the corresponding ADCRESULT12 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC12, the completed results of those conversions will be placed in ADCRESULT12 and ADCRESULT13.
 */
#define ADCRESULT12_ALL_VAL_Pos (0)
#define ADCRESULT12_ALL_VAL_Msk (0x1FFFUL << ADCRESULT12_ALL_VAL_Pos)

#define ADCRESULT12_BIT_VAL

#define ADCRESULT12_ALL_VAL_(x) ((x) << ADCRESULT12_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT13     VAL
 *  @access     ADC->ADCRESULT13.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC13, the digital result is placed in the corresponding ADCRESULT13 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC12, the completed results of those conversions will be placed in ADCRESULT12 and ADCRESULT13.
 */
#define ADCRESULT13_ALL_VAL_Pos (0)
#define ADCRESULT13_ALL_VAL_Msk (0x1FFFUL << ADCRESULT13_ALL_VAL_Pos)

#define ADCRESULT13_BIT_VAL

#define ADCRESULT13_ALL_VAL_(x) ((x) << ADCRESULT13_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT14     VAL
 *  @access     ADC->ADCRESULT14.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC14, the digital result is placed in the corresponding ADCRESULT14 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC14, the completed results of those conversions will be placed in ADCRESULT14 and ADCRESULT15.
 */
#define ADCRESULT14_ALL_VAL_Pos (0)
#define ADCRESULT14_ALL_VAL_Msk (0x1FFFUL << ADCRESULT14_ALL_VAL_Pos)

#define ADCRESULT14_BIT_VAL

#define ADCRESULT14_ALL_VAL_(x) ((x) << ADCRESULT14_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCRESULT15     VAL
 *  @access     ADC->ADCRESULT15.bit.VAL
 *  @brief      13-bit ADC result
 *              - Sequential Sampling Mode
 *              After the ADC completes a conversion of an SOC15, the digital result is placed in the corresponding ADCRESULT15 Register.
 *              - Simultaneous Sampling Mode
 *              After the ADC completes a conversion of a channel pair, the digital results are found in the corresponding ADCRESULTx and ADCRESULTx+1 registers
 *              (assuming x is even). For example, for SOC14, the completed results of those conversions will be placed in ADCRESULT14 and ADCRESULT15.
 */
#define ADCRESULT15_ALL_VAL_Pos (0)
#define ADCRESULT15_ALL_VAL_Msk (0x1FFFUL << ADCRESULT15_ALL_VAL_Pos)

#define ADCRESULT15_BIT_VAL

#define ADCRESULT15_ALL_VAL_(x) ((x) << ADCRESULT15_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSTS          COMP0L
 *  @access     ADC->ADCSTS.bit.COMP0L
 *  @brief      The output of comparator for low-voltage protection in PGA 0
 */
#define ADCSTS_ALL_COMP0L_Pos (0)
#define ADCSTS_ALL_COMP0L_Msk (0x1UL << ADCSTS_ALL_COMP0L_Pos)

typedef enum
{
    ADCSTS_BIT_COMP0L_LOW      = 0,  /*!< The output of comparator for low-voltage protection in PGA 0 is low    */
    ADCSTS_BIT_COMP0L_HIGH     = 1,  /*!< The output of comparator for low-voltage protection in PGA 0 is high   */
} ADCSTS_BIT_COMP0L;

#define ADCSTS_ALL_COMP0L_LOW      ((0x0UL) << ADCSTS_ALL_COMP0L_Pos)
#define ADCSTS_ALL_COMP0L_HIGH     ((0x1UL) << ADCSTS_ALL_COMP0L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSTS          COMP1L
 *  @access     ADC->ADCSTS.bit.COMP1L
 *  @brief      The output of comparator for low-voltage protection in PGA 1
 */
#define ADCSTS_ALL_COMP1L_Pos (1)
#define ADCSTS_ALL_COMP1L_Msk (0x1UL << ADCSTS_ALL_COMP1L_Pos)

typedef enum
{
    ADCSTS_BIT_COMP1L_LOW      = 0,  /*!< The output of comparator for low-voltage protection in PGA 1 is low    */
    ADCSTS_BIT_COMP1L_HIGH     = 1,  /*!< The output of comparator for low-voltage protection in PGA 1 is high   */
} ADCSTS_BIT_COMP1L;

#define ADCSTS_ALL_COMP1L_LOW      ((0x0UL) << ADCSTS_ALL_COMP1L_Pos)
#define ADCSTS_ALL_COMP1L_HIGH     ((0x1UL) << ADCSTS_ALL_COMP1L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSTS          COMP2L
 *  @access     ADC->ADCSTS.bit.COMP2L
 *  @brief      The output of comparator for low-voltage protection in PGA 2
 */
#define ADCSTS_ALL_COMP2L_Pos (2)
#define ADCSTS_ALL_COMP2L_Msk (0x1UL << ADCSTS_ALL_COMP2L_Pos)

typedef enum
{
    ADCSTS_BIT_COMP2L_LOW      = 0,  /*!< The output of comparator for low-voltage protection in PGA 2 is low    */
    ADCSTS_BIT_COMP2L_HIGH     = 1,  /*!< The output of comparator for low-voltage protection in PGA 2 is high   */
} ADCSTS_BIT_COMP2L;

#define ADCSTS_ALL_COMP2L_LOW      ((0x0UL) << ADCSTS_ALL_COMP2L_Pos)
#define ADCSTS_ALL_COMP2L_HIGH     ((0x1UL) << ADCSTS_ALL_COMP2L_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSTS          COMP0H
 *  @access     ADC->ADCSTS.bit.COMP0H
 *  @brief      The output of comparator for high-voltage protection in PGA 0
 */
#define ADCSTS_ALL_COMP0H_Pos (3)
#define ADCSTS_ALL_COMP0H_Msk (0x1UL << ADCSTS_ALL_COMP0H_Pos)

typedef enum
{
    ADCSTS_BIT_COMP0H_LOW      = 0,  /*!< The output of comparator for high-voltage protection in PGA 0 is low    */
    ADCSTS_BIT_COMP0H_HIGH     = 1,  /*!< The output of comparator for high-voltage protection in PGA 0 is high   */
} ADCSTS_BIT_COMP0H;

#define ADCSTS_ALL_COMP0H_LOW      ((0x0UL) << ADCSTS_ALL_COMP0H_Pos)
#define ADCSTS_ALL_COMP0H_HIGH     ((0x1UL) << ADCSTS_ALL_COMP0H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSTS          COMP1H
 *  @access     ADC->ADCSTS.bit.COMP1H
 *  @brief      The output of comparator for high-voltage protection in PGA 1
 */
#define ADCSTS_ALL_COMP1H_Pos (4)
#define ADCSTS_ALL_COMP1H_Msk (0x1UL << ADCSTS_ALL_COMP1H_Pos)

typedef enum
{
    ADCSTS_BIT_COMP1H_LOW      = 0,  /*!< The output of comparator for high-voltage protection in PGA 1 is low    */
    ADCSTS_BIT_COMP1H_HIGH     = 1,  /*!< The output of comparator for high-voltage protection in PGA 1 is high   */
} ADCSTS_BIT_COMP1H;

#define ADCSTS_ALL_COMP1H_LOW      ((0x0UL) << ADCSTS_ALL_COMP1H_Pos)
#define ADCSTS_ALL_COMP1H_HIGH     ((0x1UL) << ADCSTS_ALL_COMP1H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSTS          COMP2H
 *  @access     ADC->ADCSTS.bit.COMP2H
 *  @brief      The output of comparator for high-voltage protection in PGA 2
 */
#define ADCSTS_ALL_COMP2H_Pos (5)
#define ADCSTS_ALL_COMP2H_Msk (0x1UL << ADCSTS_ALL_COMP2H_Pos)

typedef enum
{
    ADCSTS_BIT_COMP2H_LOW      = 0,  /*!< The output of comparator for high-voltage protection in PGA 2 is low    */
    ADCSTS_BIT_COMP2H_HIGH     = 1,  /*!< The output of comparator for high-voltage protection in PGA 2 is high   */
} ADCSTS_BIT_COMP2H;

#define ADCSTS_ALL_COMP2H_LOW      ((0x0UL) << ADCSTS_ALL_COMP2H_Pos)
#define ADCSTS_ALL_COMP2H_HIGH     ((0x1UL) << ADCSTS_ALL_COMP2H_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCSTS          COMPSTSCLR
 *  @access     ADC->ADCSTS.bit.COMPSTSCLR
 *  @brief      Write 1 to clear latched comparator status(self-clear)
 */
#define ADCSTS_ALL_COMPSTSCLR_Pos (31)
#define ADCSTS_ALL_COMPSTSCLR_Msk (0x1UL << ADCSTS_ALL_COMPSTSCLR_Pos)

typedef enum
{
    ADCSTS_BIT_COMPSTSCLR_NO_EFFECT     = 0,  /*!< Has no effect                     */
    ADCSTS_BIT_COMPSTSCLR_CLEAR         = 1,  /*!< Clear latched comparator status   */
} ADCSTS_BIT_COMPSTSCLR;

#define ADCSTS_ALL_COMPSTSCLR_NO_EFFECT     ((0x0UL) << ADCSTS_ALL_COMPSTSCLR_Pos)
#define ADCSTS_ALL_COMPSTSCLR_CLEAR         ((0x1UL) << ADCSTS_ALL_COMPSTSCLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             TSENSCTL        EN
 *  @access     ADC->TSENSCTL.bit.EN
 *  @brief      T-sensor enable
 */
#define TSENSCTL_ALL_EN_Pos (6)
#define TSENSCTL_ALL_EN_Msk (0x1UL << TSENSCTL_ALL_EN_Pos)

typedef enum
{
    TSENSCTL_BIT_EN_DISABLE     = 0,  /*!< Disable T-sensor    */
    TSENSCTL_BIT_EN_ENABLE      = 1,  /*!< Enable T-sensor     */
} TSENSCTL_BIT_EN;

#define TSENSCTL_ALL_EN_DISABLE     ((0x0UL) << TSENSCTL_ALL_EN_Pos)
#define TSENSCTL_ALL_EN_ENABLE      ((0x1UL) << TSENSCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCTRIM         VREGTRIM
 *  @access     ADC->ADCTRIM.bit.VREGTRIM
 *  @brief      Trimming option (coarse) for ADC 1.2V Regulator output
 */
#define ADCTRIM_ALL_VREGTRIM_Pos (10)
#define ADCTRIM_ALL_VREGTRIM_Msk (0xFUL << ADCTRIM_ALL_VREGTRIM_Pos)

#define ADCTRIM_BIT_VREGTRIM

#define ADCTRIM_ALL_VREGTRIM_(x) ((x) << ADCTRIM_ALL_VREGTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCTRIM         VREFTRIM
 *  @access     ADC->ADCTRIM.bit.VREFTRIM
 *  @brief      Trimming option of ADC 1.2V Reference
 */
#define ADCTRIM_ALL_VREFTRIM_Pos (14)
#define ADCTRIM_ALL_VREFTRIM_Msk (0x1FUL << ADCTRIM_ALL_VREFTRIM_Pos)

#define ADCTRIM_BIT_VREFTRIM

#define ADCTRIM_ALL_VREFTRIM_(x) ((x) << ADCTRIM_ALL_VREFTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCTRIM         VREGBLEEDTRIM
 *  @access     ADC->ADCTRIM.bit.VREGBLEEDTRIM
 *  @brief      Trimming option (fine) for ADC 1.2V Regulator output
 */
#define ADCTRIM_ALL_VREGBLEEDTRIM_Pos (19)
#define ADCTRIM_ALL_VREGBLEEDTRIM_Msk (0xFUL << ADCTRIM_ALL_VREGBLEEDTRIM_Pos)

#define ADCTRIM_BIT_VREGBLEEDTRIM

#define ADCTRIM_ALL_VREGBLEEDTRIM_(x) ((x) << ADCTRIM_ALL_VREGBLEEDTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL2   SOC12
 *  @access     ADC->ADCINTSOCSEL2.bit.SOC12
 *  @brief      Select ADC interrupt source for SOC12. This Field will overrides the TRIGSEL Field in the ADCSOC12CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC12.
 */
#define ADCINTSOCSEL2_ALL_SOC12_Pos (0)
#define ADCINTSOCSEL2_ALL_SOC12_Msk (0x1FUL << ADCINTSOCSEL2_ALL_SOC12_Pos)

typedef enum
{
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC12    */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC12   */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC12   */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC12   */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC12   */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC12   */
    ADCINTSOCSEL2_BIT_SOC12_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC12   */
} ADCINTSOCSEL2_BIT_SOC12;

#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL2_ALL_SOC12_Pos)
#define ADCINTSOCSEL2_ALL_SOC12_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL2_ALL_SOC12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL2   SOC13
 *  @access     ADC->ADCINTSOCSEL2.bit.SOC13
 *  @brief      Select ADC interrupt source for SOC13. This Field will overrides the TRIGSEL Field in the ADCSOC13CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC13.
 */
#define ADCINTSOCSEL2_ALL_SOC13_Pos (5)
#define ADCINTSOCSEL2_ALL_SOC13_Msk (0x1FUL << ADCINTSOCSEL2_ALL_SOC13_Pos)

typedef enum
{
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC13    */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC13   */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC13   */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC13   */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC13   */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC13   */
    ADCINTSOCSEL2_BIT_SOC13_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC13   */
} ADCINTSOCSEL2_BIT_SOC13;

#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL2_ALL_SOC13_Pos)
#define ADCINTSOCSEL2_ALL_SOC13_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL2_ALL_SOC13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL2   SOC14
 *  @access     ADC->ADCINTSOCSEL2.bit.SOC14
 *  @brief      Select ADC interrupt source for SOC14. This Field will overrides the TRIGSEL Field in the ADCSOC14CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC14.
 */
#define ADCINTSOCSEL2_ALL_SOC14_Pos (10)
#define ADCINTSOCSEL2_ALL_SOC14_Msk (0x1FUL << ADCINTSOCSEL2_ALL_SOC14_Pos)

typedef enum
{
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC14    */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC14   */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC14   */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC14   */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC14   */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC14   */
    ADCINTSOCSEL2_BIT_SOC14_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC14   */
} ADCINTSOCSEL2_BIT_SOC14;

#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL2_ALL_SOC14_Pos)
#define ADCINTSOCSEL2_ALL_SOC14_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL2_ALL_SOC14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ADC             ADCINTSOCSEL2   SOC15
 *  @access     ADC->ADCINTSOCSEL2.bit.SOC15
 *  @brief      Select ADC interrupt source for SOC15. This Field will overrides the TRIGSEL Field in the ADCSOC15CTL Register.
 *              TRIGSEL Field will determine trigger source for SOC15.
 */
#define ADCINTSOCSEL2_ALL_SOC15_Pos (15)
#define ADCINTSOCSEL2_ALL_SOC15_Msk (0x1FUL << ADCINTSOCSEL2_ALL_SOC15_Pos)

typedef enum
{
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT0      = 16,  /*!< Select ADCINT0 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT1      = 17,  /*!< Select ADCINT1 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT2      = 18,  /*!< Select ADCINT2 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT3      = 19,  /*!< Select ADCINT3 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT4      = 20,  /*!< Select ADCINT4 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT5      = 21,  /*!< Select ADCINT5 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT6      = 22,  /*!< Select ADCINT6 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT7      = 23,  /*!< Select ADCINT7 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT8      = 24,  /*!< Select ADCINT8 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT9      = 25,  /*!< Select ADCINT9 trigger SOC15    */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT10     = 26,  /*!< Select ADCINT10 trigger SOC15   */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT11     = 27,  /*!< Select ADCINT11 trigger SOC15   */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT12     = 28,  /*!< Select ADCINT12 trigger SOC15   */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT13     = 29,  /*!< Select ADCINT13 trigger SOC15   */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT14     = 30,  /*!< Select ADCINT14 trigger SOC15   */
    ADCINTSOCSEL2_BIT_SOC15_TRIG_BY_INT15     = 31,  /*!< Select ADCINT15 trigger SOC15   */
} ADCINTSOCSEL2_BIT_SOC15;

#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT0      ((0x10UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT1      ((0x11UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT2      ((0x12UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT3      ((0x13UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT4      ((0x14UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT5      ((0x15UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT6      ((0x16UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT7      ((0x17UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT8      ((0x18UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT9      ((0x19UL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT10     ((0x1AUL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT11     ((0x1BUL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT12     ((0x1CUL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT13     ((0x1DUL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT14     ((0x1EUL) << ADCINTSOCSEL2_ALL_SOC15_Pos)
#define ADCINTSOCSEL2_ALL_SOC15_TRIG_BY_INT15     ((0x1FUL) << ADCINTSOCSEL2_ALL_SOC15_Pos)





/********************************************************************************
*
* Module Name     CLOCK
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           HCLKCTL         DIV
 *  @access     CLOCK->HCLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define HCLKCTL_ALL_DIV_Pos (0)
#define HCLKCTL_ALL_DIV_Msk (0x3FUL << HCLKCTL_ALL_DIV_Pos)

#define HCLKCTL_BIT_DIV

#define HCLKCTL_ALL_DIV_(x) ((x) << HCLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           HCLKCTL         EN
 *  @access     CLOCK->HCLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define HCLKCTL_ALL_EN_Pos (7)
#define HCLKCTL_ALL_EN_Msk (0x1UL << HCLKCTL_ALL_EN_Pos)

typedef enum
{
    HCLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    HCLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} HCLKCTL_BIT_EN;

#define HCLKCTL_ALL_EN_DISABLE     ((0x0UL) << HCLKCTL_ALL_EN_Pos)
#define HCLKCTL_ALL_EN_ENABLE      ((0x1UL) << HCLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PCLKCTL         DIV
 *  @access     CLOCK->PCLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define PCLKCTL_ALL_DIV_Pos (0)
#define PCLKCTL_ALL_DIV_Msk (0x3FUL << PCLKCTL_ALL_DIV_Pos)

#define PCLKCTL_BIT_DIV

#define PCLKCTL_ALL_DIV_(x) ((x) << PCLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PCLKCTL         EN
 *  @access     CLOCK->PCLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define PCLKCTL_ALL_EN_Pos (7)
#define PCLKCTL_ALL_EN_Msk (0x1UL << PCLKCTL_ALL_EN_Pos)

typedef enum
{
    PCLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    PCLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} PCLKCTL_BIT_EN;

#define PCLKCTL_ALL_EN_DISABLE     ((0x0UL) << PCLKCTL_ALL_EN_Pos)
#define PCLKCTL_ALL_EN_ENABLE      ((0x1UL) << PCLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           UARTCLKCTL      DIV
 *  @access     CLOCK->UARTCLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define UARTCLKCTL_ALL_DIV_Pos (0)
#define UARTCLKCTL_ALL_DIV_Msk (0x3FUL << UARTCLKCTL_ALL_DIV_Pos)

#define UARTCLKCTL_BIT_DIV

#define UARTCLKCTL_ALL_DIV_(x) ((x) << UARTCLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           UARTCLKCTL      EN
 *  @access     CLOCK->UARTCLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define UARTCLKCTL_ALL_EN_Pos (7)
#define UARTCLKCTL_ALL_EN_Msk (0x1UL << UARTCLKCTL_ALL_EN_Pos)

typedef enum
{
    UARTCLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    UARTCLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} UARTCLKCTL_BIT_EN;

#define UARTCLKCTL_ALL_EN_DISABLE     ((0x0UL) << UARTCLKCTL_ALL_EN_Pos)
#define UARTCLKCTL_ALL_EN_ENABLE      ((0x1UL) << UARTCLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           SSPCLKCTL       DIV0
 *  @access     CLOCK->SSPCLKCTL.bit.DIV0
 *  @brief      Clock dividing ratio for the 1st divider
 */
#define SSPCLKCTL_ALL_DIV0_Pos (0)
#define SSPCLKCTL_ALL_DIV0_Msk (0x3FUL << SSPCLKCTL_ALL_DIV0_Pos)

#define SSPCLKCTL_BIT_DIV0

#define SSPCLKCTL_ALL_DIV0_(x) ((x) << SSPCLKCTL_ALL_DIV0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           SSPCLKCTL       EN
 *  @access     CLOCK->SSPCLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define SSPCLKCTL_ALL_EN_Pos (7)
#define SSPCLKCTL_ALL_EN_Msk (0x1UL << SSPCLKCTL_ALL_EN_Pos)

typedef enum
{
    SSPCLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    SSPCLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} SSPCLKCTL_BIT_EN;

#define SSPCLKCTL_ALL_EN_DISABLE     ((0x0UL) << SSPCLKCTL_ALL_EN_Pos)
#define SSPCLKCTL_ALL_EN_ENABLE      ((0x1UL) << SSPCLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           SSPCLKCTL       DIV1
 *  @access     CLOCK->SSPCLKCTL.bit.DIV1
 *  @brief      Clock dividing ratio for the 2nd divider
 */
#define SSPCLKCTL_ALL_DIV1_Pos (8)
#define SSPCLKCTL_ALL_DIV1_Msk (0x3FUL << SSPCLKCTL_ALL_DIV1_Pos)

#define SSPCLKCTL_BIT_DIV1

#define SSPCLKCTL_ALL_DIV1_(x) ((x) << SSPCLKCTL_ALL_DIV1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           QSPICLKCTL      DIV
 *  @access     CLOCK->QSPICLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define QSPICLKCTL_ALL_DIV_Pos (0)
#define QSPICLKCTL_ALL_DIV_Msk (0x3FUL << QSPICLKCTL_ALL_DIV_Pos)

#define QSPICLKCTL_BIT_DIV

#define QSPICLKCTL_ALL_DIV_(x) ((x) << QSPICLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           QSPICLKCTL      EN
 *  @access     CLOCK->QSPICLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define QSPICLKCTL_ALL_EN_Pos (7)
#define QSPICLKCTL_ALL_EN_Msk (0x1UL << QSPICLKCTL_ALL_EN_Pos)

typedef enum
{
    QSPICLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    QSPICLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} QSPICLKCTL_BIT_EN;

#define QSPICLKCTL_ALL_EN_DISABLE     ((0x0UL) << QSPICLKCTL_ALL_EN_Pos)
#define QSPICLKCTL_ALL_EN_ENABLE      ((0x1UL) << QSPICLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           I2CCLKCTL       DIV
 *  @access     CLOCK->I2CCLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define I2CCLKCTL_ALL_DIV_Pos (0)
#define I2CCLKCTL_ALL_DIV_Msk (0x3FUL << I2CCLKCTL_ALL_DIV_Pos)

#define I2CCLKCTL_BIT_DIV

#define I2CCLKCTL_ALL_DIV_(x) ((x) << I2CCLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           I2CCLKCTL       EN
 *  @access     CLOCK->I2CCLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define I2CCLKCTL_ALL_EN_Pos (7)
#define I2CCLKCTL_ALL_EN_Msk (0x1UL << I2CCLKCTL_ALL_EN_Pos)

typedef enum
{
    I2CCLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    I2CCLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} I2CCLKCTL_BIT_EN;

#define I2CCLKCTL_ALL_EN_DISABLE     ((0x0UL) << I2CCLKCTL_ALL_EN_Pos)
#define I2CCLKCTL_ALL_EN_ENABLE      ((0x1UL) << I2CCLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           ADCCLKCTL       DIV
 *  @access     CLOCK->ADCCLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define ADCCLKCTL_ALL_DIV_Pos (0)
#define ADCCLKCTL_ALL_DIV_Msk (0x3FUL << ADCCLKCTL_ALL_DIV_Pos)

#define ADCCLKCTL_BIT_DIV

#define ADCCLKCTL_ALL_DIV_(x) ((x) << ADCCLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           ADCCLKCTL       EN
 *  @access     CLOCK->ADCCLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define ADCCLKCTL_ALL_EN_Pos (7)
#define ADCCLKCTL_ALL_EN_Msk (0x1UL << ADCCLKCTL_ALL_EN_Pos)

typedef enum
{
    ADCCLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    ADCCLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} ADCCLKCTL_BIT_EN;

#define ADCCLKCTL_ALL_EN_DISABLE     ((0x0UL) << ADCCLKCTL_ALL_EN_Pos)
#define ADCCLKCTL_ALL_EN_ENABLE      ((0x1UL) << ADCCLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM0CLKCTL      DIV
 *  @access     CLOCK->PWM0CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define PWM0CLKCTL_ALL_DIV_Pos (0)
#define PWM0CLKCTL_ALL_DIV_Msk (0x3FUL << PWM0CLKCTL_ALL_DIV_Pos)

#define PWM0CLKCTL_BIT_DIV

#define PWM0CLKCTL_ALL_DIV_(x) ((x) << PWM0CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM0CLKCTL      EN
 *  @access     CLOCK->PWM0CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define PWM0CLKCTL_ALL_EN_Pos (7)
#define PWM0CLKCTL_ALL_EN_Msk (0x1UL << PWM0CLKCTL_ALL_EN_Pos)

typedef enum
{
    PWM0CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    PWM0CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} PWM0CLKCTL_BIT_EN;

#define PWM0CLKCTL_ALL_EN_DISABLE     ((0x0UL) << PWM0CLKCTL_ALL_EN_Pos)
#define PWM0CLKCTL_ALL_EN_ENABLE      ((0x1UL) << PWM0CLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       CLK0GATEBYP
 *  @access     CLOCK->GLBCLKCTL.bit.CLK0GATEBYP
 *  @brief      Bypass CLK0 gating
 */
#define GLBCLKCTL_ALL_CLK0GATEBYP_Pos (0)
#define GLBCLKCTL_ALL_CLK0GATEBYP_Msk (0x1UL << GLBCLKCTL_ALL_CLK0GATEBYP_Pos)

typedef enum
{
    GLBCLKCTL_BIT_CLK0GATEBYP_DISABLE     = 0,  /*!< Activate the CLK0 gating logic so CLK0 can be on/off by writing 1 to CLK0GATEDIS or CLK0GATEEN   */
    GLBCLKCTL_BIT_CLK0GATEBYP_ENABLE      = 1,  /*!< Bypass the CLK0 gating logic so that CLK0 is always on                                           */
} GLBCLKCTL_BIT_CLK0GATEBYP;

#define GLBCLKCTL_ALL_CLK0GATEBYP_DISABLE     ((0x0UL) << GLBCLKCTL_ALL_CLK0GATEBYP_Pos)
#define GLBCLKCTL_ALL_CLK0GATEBYP_ENABLE      ((0x1UL) << GLBCLKCTL_ALL_CLK0GATEBYP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       CLK0GATEEN
 *  @access     CLOCK->GLBCLKCTL.bit.CLK0GATEEN
 *  @brief      Enable CLK0 gating
 */
#define GLBCLKCTL_ALL_CLK0GATEEN_Pos (1)
#define GLBCLKCTL_ALL_CLK0GATEEN_Msk (0x1UL << GLBCLKCTL_ALL_CLK0GATEEN_Pos)

typedef enum
{
    GLBCLKCTL_BIT_CLK0GATEEN_NO_EFFECT            = 0,  /*!< Write a 0 has no effect                                                                                 */
    GLBCLKCTL_BIT_CLK0GATEEN_ENABLE_CLK0_GATE     = 1,  /*!< Write a 1 will issue a pulse to enable CLK0 gating so that CLK0 will be off. This bit is self-cleared   */
} GLBCLKCTL_BIT_CLK0GATEEN;

#define GLBCLKCTL_ALL_CLK0GATEEN_NO_EFFECT            ((0x0UL) << GLBCLKCTL_ALL_CLK0GATEEN_Pos)
#define GLBCLKCTL_ALL_CLK0GATEEN_ENABLE_CLK0_GATE     ((0x1UL) << GLBCLKCTL_ALL_CLK0GATEEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       CLK0GATEDIS
 *  @access     CLOCK->GLBCLKCTL.bit.CLK0GATEDIS
 *  @brief      Disable CLK0 gating
 */
#define GLBCLKCTL_ALL_CLK0GATEDIS_Pos (2)
#define GLBCLKCTL_ALL_CLK0GATEDIS_Msk (0x1UL << GLBCLKCTL_ALL_CLK0GATEDIS_Pos)

typedef enum
{
    GLBCLKCTL_BIT_CLK0GATEDIS_NO_EFFECT             = 0,  /*!< Write a 0 has no effect                                                                                 */
    GLBCLKCTL_BIT_CLK0GATEDIS_DISABLE_CLK0_GATE     = 1,  /*!< Write a 1 will issue a pulse to disable CLK0 gating so that CLK0 will be on. This bit is self-cleared   */
} GLBCLKCTL_BIT_CLK0GATEDIS;

#define GLBCLKCTL_ALL_CLK0GATEDIS_NO_EFFECT             ((0x0UL) << GLBCLKCTL_ALL_CLK0GATEDIS_Pos)
#define GLBCLKCTL_ALL_CLK0GATEDIS_DISABLE_CLK0_GATE     ((0x1UL) << GLBCLKCTL_ALL_CLK0GATEDIS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       CLK1GATEBYP
 *  @access     CLOCK->GLBCLKCTL.bit.CLK1GATEBYP
 *  @brief      Bypass CLK1 gating
 */
#define GLBCLKCTL_ALL_CLK1GATEBYP_Pos (3)
#define GLBCLKCTL_ALL_CLK1GATEBYP_Msk (0x1UL << GLBCLKCTL_ALL_CLK1GATEBYP_Pos)

typedef enum
{
    GLBCLKCTL_BIT_CLK1GATEBYP_DISABLE     = 0,  /*!< Activate the CLK1 gating logic so CLK1 can be on/off by writing 1 to CLK1GATEDIS or CLK1GATEEN   */
    GLBCLKCTL_BIT_CLK1GATEBYP_ENABLE      = 1,  /*!< Bypass the CLK1 gating logic so that CLK1 is always on                                           */
} GLBCLKCTL_BIT_CLK1GATEBYP;

#define GLBCLKCTL_ALL_CLK1GATEBYP_DISABLE     ((0x0UL) << GLBCLKCTL_ALL_CLK1GATEBYP_Pos)
#define GLBCLKCTL_ALL_CLK1GATEBYP_ENABLE      ((0x1UL) << GLBCLKCTL_ALL_CLK1GATEBYP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       CLK1GATEEN
 *  @access     CLOCK->GLBCLKCTL.bit.CLK1GATEEN
 *  @brief      Enable CLK1 gating
 */
#define GLBCLKCTL_ALL_CLK1GATEEN_Pos (4)
#define GLBCLKCTL_ALL_CLK1GATEEN_Msk (0x1UL << GLBCLKCTL_ALL_CLK1GATEEN_Pos)

typedef enum
{
    GLBCLKCTL_BIT_CLK1GATEEN_NO_EFFECT            = 0,  /*!< Write a 0 has no effect                                                                                 */
    GLBCLKCTL_BIT_CLK1GATEEN_ENABLE_CLK1_GATE     = 1,  /*!< Write a 1 will issue a pulse to enable CLK1 gating so that CLK1 will be off. This bit is self-cleared   */
} GLBCLKCTL_BIT_CLK1GATEEN;

#define GLBCLKCTL_ALL_CLK1GATEEN_NO_EFFECT            ((0x0UL) << GLBCLKCTL_ALL_CLK1GATEEN_Pos)
#define GLBCLKCTL_ALL_CLK1GATEEN_ENABLE_CLK1_GATE     ((0x1UL) << GLBCLKCTL_ALL_CLK1GATEEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       CLK1GATEDIS
 *  @access     CLOCK->GLBCLKCTL.bit.CLK1GATEDIS
 *  @brief      Disable CLK1 gating
 */
#define GLBCLKCTL_ALL_CLK1GATEDIS_Pos (5)
#define GLBCLKCTL_ALL_CLK1GATEDIS_Msk (0x1UL << GLBCLKCTL_ALL_CLK1GATEDIS_Pos)

typedef enum
{
    GLBCLKCTL_BIT_CLK1GATEDIS_NO_EFFECT             = 0,  /*!< Write a 0 has no effect                                                                                 */
    GLBCLKCTL_BIT_CLK1GATEDIS_DISABLE_CLK1_GATE     = 1,  /*!< Write a 1 will issue a pulse to disable CLK1 gating so that CLK1 will be on. This bit is self-cleared   */
} GLBCLKCTL_BIT_CLK1GATEDIS;

#define GLBCLKCTL_ALL_CLK1GATEDIS_NO_EFFECT             ((0x0UL) << GLBCLKCTL_ALL_CLK1GATEDIS_Pos)
#define GLBCLKCTL_ALL_CLK1GATEDIS_DISABLE_CLK1_GATE     ((0x1UL) << GLBCLKCTL_ALL_CLK1GATEDIS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       CLK0SEL
 *  @access     CLOCK->GLBCLKCTL.bit.CLK0SEL
 *  @brief      CLK0 selection
 */
#define GLBCLKCTL_ALL_CLK0SEL_Pos (6)
#define GLBCLKCTL_ALL_CLK0SEL_Msk (0x3UL << GLBCLKCTL_ALL_CLK0SEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_CLK0SEL_XO       = 0,  /*!< CLK_XO     */
    GLBCLKCTL_BIT_CLK0SEL_PLL      = 2,  /*!< CLK_PLL    */
    GLBCLKCTL_BIT_CLK0SEL_RCO0     = 3,  /*!< CLK_RCO0   */
} GLBCLKCTL_BIT_CLK0SEL;

#define GLBCLKCTL_ALL_CLK0SEL_XO       ((0x0UL) << GLBCLKCTL_ALL_CLK0SEL_Pos)
#define GLBCLKCTL_ALL_CLK0SEL_PLL      ((0x2UL) << GLBCLKCTL_ALL_CLK0SEL_Pos)
#define GLBCLKCTL_ALL_CLK0SEL_RCO0     ((0x3UL) << GLBCLKCTL_ALL_CLK0SEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       CLK1SEL
 *  @access     CLOCK->GLBCLKCTL.bit.CLK1SEL
 *  @brief      CLK1 selection
 */
#define GLBCLKCTL_ALL_CLK1SEL_Pos (8)
#define GLBCLKCTL_ALL_CLK1SEL_Msk (0x3UL << GLBCLKCTL_ALL_CLK1SEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_CLK1SEL_XO       = 0,  /*!< CLK_XO     */
    GLBCLKCTL_BIT_CLK1SEL_PLL      = 2,  /*!< CLK_PLL    */
    GLBCLKCTL_BIT_CLK1SEL_RCO1     = 3,  /*!< CLK_RCO1   */
} GLBCLKCTL_BIT_CLK1SEL;

#define GLBCLKCTL_ALL_CLK1SEL_XO       ((0x0UL) << GLBCLKCTL_ALL_CLK1SEL_Pos)
#define GLBCLKCTL_ALL_CLK1SEL_PLL      ((0x2UL) << GLBCLKCTL_ALL_CLK1SEL_Pos)
#define GLBCLKCTL_ALL_CLK1SEL_RCO1     ((0x3UL) << GLBCLKCTL_ALL_CLK1SEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       PWM0CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.PWM0CLKSEL
 *  @brief      PWM0CLK selection
 */
#define GLBCLKCTL_ALL_PWM0CLKSEL_Pos (10)
#define GLBCLKCTL_ALL_PWM0CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_PWM0CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_PWM0CLKSEL_CLK1     = 0,  /*!< CLK1      */
    GLBCLKCTL_BIT_PWM0CLKSEL_PWM      = 1,  /*!< CLK_PWM   */
    GLBCLKCTL_BIT_PWM0CLKSEL_CLK0     = 2,  /*!< CLK0      */
} GLBCLKCTL_BIT_PWM0CLKSEL;

#define GLBCLKCTL_ALL_PWM0CLKSEL_CLK1     ((0x0UL) << GLBCLKCTL_ALL_PWM0CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM0CLKSEL_PWM      ((0x1UL) << GLBCLKCTL_ALL_PWM0CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM0CLKSEL_CLK0     ((0x2UL) << GLBCLKCTL_ALL_PWM0CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       PWM1CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.PWM1CLKSEL
 *  @brief      PWM1CLK selection
 */
#define GLBCLKCTL_ALL_PWM1CLKSEL_Pos (12)
#define GLBCLKCTL_ALL_PWM1CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_PWM1CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_PWM1CLKSEL_CLK1     = 0,  /*!< CLK1      */
    GLBCLKCTL_BIT_PWM1CLKSEL_PWM      = 1,  /*!< CLK_PWM   */
    GLBCLKCTL_BIT_PWM1CLKSEL_CLK0     = 2,  /*!< CLK0      */
} GLBCLKCTL_BIT_PWM1CLKSEL;

#define GLBCLKCTL_ALL_PWM1CLKSEL_CLK1     ((0x0UL) << GLBCLKCTL_ALL_PWM1CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM1CLKSEL_PWM      ((0x1UL) << GLBCLKCTL_ALL_PWM1CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM1CLKSEL_CLK0     ((0x2UL) << GLBCLKCTL_ALL_PWM1CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       PWM2CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.PWM2CLKSEL
 *  @brief      PWM2CLK selection
 */
#define GLBCLKCTL_ALL_PWM2CLKSEL_Pos (14)
#define GLBCLKCTL_ALL_PWM2CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_PWM2CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_PWM2CLKSEL_CLK1     = 0,  /*!< CLK1      */
    GLBCLKCTL_BIT_PWM2CLKSEL_PWM      = 1,  /*!< CLK_PWM   */
    GLBCLKCTL_BIT_PWM2CLKSEL_CLK0     = 2,  /*!< CLK0      */
} GLBCLKCTL_BIT_PWM2CLKSEL;

#define GLBCLKCTL_ALL_PWM2CLKSEL_CLK1     ((0x0UL) << GLBCLKCTL_ALL_PWM2CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM2CLKSEL_PWM      ((0x1UL) << GLBCLKCTL_ALL_PWM2CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM2CLKSEL_CLK0     ((0x2UL) << GLBCLKCTL_ALL_PWM2CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       PWM3CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.PWM3CLKSEL
 *  @brief      PWM3CLK selection
 */
#define GLBCLKCTL_ALL_PWM3CLKSEL_Pos (16)
#define GLBCLKCTL_ALL_PWM3CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_PWM3CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_PWM3CLKSEL_CLK1     = 0,  /*!< CLK1      */
    GLBCLKCTL_BIT_PWM3CLKSEL_PWM      = 1,  /*!< CLK_PWM   */
    GLBCLKCTL_BIT_PWM3CLKSEL_CLK0     = 2,  /*!< CLK0      */
} GLBCLKCTL_BIT_PWM3CLKSEL;

#define GLBCLKCTL_ALL_PWM3CLKSEL_CLK1     ((0x0UL) << GLBCLKCTL_ALL_PWM3CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM3CLKSEL_PWM      ((0x1UL) << GLBCLKCTL_ALL_PWM3CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM3CLKSEL_CLK0     ((0x2UL) << GLBCLKCTL_ALL_PWM3CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       PWM4CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.PWM4CLKSEL
 *  @brief      PWM4CLK selection
 */
#define GLBCLKCTL_ALL_PWM4CLKSEL_Pos (18)
#define GLBCLKCTL_ALL_PWM4CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_PWM4CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_PWM4CLKSEL_CLK1     = 0,  /*!< CLK1      */
    GLBCLKCTL_BIT_PWM4CLKSEL_PWM      = 1,  /*!< CLK_PWM   */
    GLBCLKCTL_BIT_PWM4CLKSEL_CLK0     = 2,  /*!< CLK0      */
} GLBCLKCTL_BIT_PWM4CLKSEL;

#define GLBCLKCTL_ALL_PWM4CLKSEL_CLK1     ((0x0UL) << GLBCLKCTL_ALL_PWM4CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM4CLKSEL_PWM      ((0x1UL) << GLBCLKCTL_ALL_PWM4CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM4CLKSEL_CLK0     ((0x2UL) << GLBCLKCTL_ALL_PWM4CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       PWM5CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.PWM5CLKSEL
 *  @brief      PWM5CLK selection
 */
#define GLBCLKCTL_ALL_PWM5CLKSEL_Pos (20)
#define GLBCLKCTL_ALL_PWM5CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_PWM5CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_PWM5CLKSEL_CLK1     = 0,  /*!< CLK1      */
    GLBCLKCTL_BIT_PWM5CLKSEL_PWM      = 1,  /*!< CLK_PWM   */
    GLBCLKCTL_BIT_PWM5CLKSEL_CLK0     = 2,  /*!< CLK0      */
} GLBCLKCTL_BIT_PWM5CLKSEL;

#define GLBCLKCTL_ALL_PWM5CLKSEL_CLK1     ((0x0UL) << GLBCLKCTL_ALL_PWM5CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM5CLKSEL_PWM      ((0x1UL) << GLBCLKCTL_ALL_PWM5CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM5CLKSEL_CLK0     ((0x2UL) << GLBCLKCTL_ALL_PWM5CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       PWM6CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.PWM6CLKSEL
 *  @brief      PWM6CLK selection
 */
#define GLBCLKCTL_ALL_PWM6CLKSEL_Pos (22)
#define GLBCLKCTL_ALL_PWM6CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_PWM6CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_PWM6CLKSEL_CLK1     = 0,  /*!< CLK1      */
    GLBCLKCTL_BIT_PWM6CLKSEL_PWM      = 1,  /*!< CLK_PWM   */
    GLBCLKCTL_BIT_PWM6CLKSEL_CLK0     = 2,  /*!< CLK0      */
} GLBCLKCTL_BIT_PWM6CLKSEL;

#define GLBCLKCTL_ALL_PWM6CLKSEL_CLK1     ((0x0UL) << GLBCLKCTL_ALL_PWM6CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM6CLKSEL_PWM      ((0x1UL) << GLBCLKCTL_ALL_PWM6CLKSEL_Pos)
#define GLBCLKCTL_ALL_PWM6CLKSEL_CLK0     ((0x2UL) << GLBCLKCTL_ALL_PWM6CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       ECAPCLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.ECAPCLKSEL
 *  @brief      ECAPCLK selection
 */
#define GLBCLKCTL_ALL_ECAPCLKSEL_Pos (24)
#define GLBCLKCTL_ALL_ECAPCLKSEL_Msk (0x1UL << GLBCLKCTL_ALL_ECAPCLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_ECAPCLKSEL_CLK1     = 0,  /*!< CLK1   */
    GLBCLKCTL_BIT_ECAPCLKSEL_CLK0     = 1,  /*!< CLK0   */
} GLBCLKCTL_BIT_ECAPCLKSEL;

#define GLBCLKCTL_ALL_ECAPCLKSEL_CLK1     ((0x0UL) << GLBCLKCTL_ALL_ECAPCLKSEL_Pos)
#define GLBCLKCTL_ALL_ECAPCLKSEL_CLK0     ((0x1UL) << GLBCLKCTL_ALL_ECAPCLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       WDT0CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.WDT0CLKSEL
 *  @brief      WDT0CLK selection
 */
#define GLBCLKCTL_ALL_WDT0CLKSEL_Pos (25)
#define GLBCLKCTL_ALL_WDT0CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_WDT0CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_WDT0CLKSEL_RCO0     = 0,  /*!< CLK_RCO0   */
    GLBCLKCTL_BIT_WDT0CLKSEL_RCO1     = 1,  /*!< CLK_RCO1   */
    GLBCLKCTL_BIT_WDT0CLKSEL_PLL      = 2,  /*!< CLK_PLL    */
    GLBCLKCTL_BIT_WDT0CLKSEL_XO       = 3,  /*!< CLK_XO     */
} GLBCLKCTL_BIT_WDT0CLKSEL;

#define GLBCLKCTL_ALL_WDT0CLKSEL_RCO0     ((0x0UL) << GLBCLKCTL_ALL_WDT0CLKSEL_Pos)
#define GLBCLKCTL_ALL_WDT0CLKSEL_RCO1     ((0x1UL) << GLBCLKCTL_ALL_WDT0CLKSEL_Pos)
#define GLBCLKCTL_ALL_WDT0CLKSEL_PLL      ((0x2UL) << GLBCLKCTL_ALL_WDT0CLKSEL_Pos)
#define GLBCLKCTL_ALL_WDT0CLKSEL_XO       ((0x3UL) << GLBCLKCTL_ALL_WDT0CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       WDT1CLKSEL
 *  @access     CLOCK->GLBCLKCTL.bit.WDT1CLKSEL
 *  @brief      WDT1CLK selection
 */
#define GLBCLKCTL_ALL_WDT1CLKSEL_Pos (27)
#define GLBCLKCTL_ALL_WDT1CLKSEL_Msk (0x3UL << GLBCLKCTL_ALL_WDT1CLKSEL_Pos)

typedef enum
{
    GLBCLKCTL_BIT_WDT1CLKSEL_RCO0     = 0,  /*!< CLK_RCO0   */
    GLBCLKCTL_BIT_WDT1CLKSEL_RCO1     = 1,  /*!< CLK_RCO1   */
    GLBCLKCTL_BIT_WDT1CLKSEL_PLL      = 2,  /*!< CLK_PLL    */
    GLBCLKCTL_BIT_WDT1CLKSEL_XO       = 3,  /*!< CLK_XO     */
} GLBCLKCTL_BIT_WDT1CLKSEL;

#define GLBCLKCTL_ALL_WDT1CLKSEL_RCO0     ((0x0UL) << GLBCLKCTL_ALL_WDT1CLKSEL_Pos)
#define GLBCLKCTL_ALL_WDT1CLKSEL_RCO1     ((0x1UL) << GLBCLKCTL_ALL_WDT1CLKSEL_Pos)
#define GLBCLKCTL_ALL_WDT1CLKSEL_PLL      ((0x2UL) << GLBCLKCTL_ALL_WDT1CLKSEL_Pos)
#define GLBCLKCTL_ALL_WDT1CLKSEL_XO       ((0x3UL) << GLBCLKCTL_ALL_WDT1CLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           GLBCLKCTL       PWMCLKSYNC
 *  @access     CLOCK->GLBCLKCTL.bit.PWMCLKSYNC
 *  @brief      PWM clock synchronization
 */
#define GLBCLKCTL_ALL_PWMCLKSYNC_Pos (29)
#define GLBCLKCTL_ALL_PWMCLKSYNC_Msk (0x1UL << GLBCLKCTL_ALL_PWMCLKSYNC_Pos)

typedef enum
{
    GLBCLKCTL_BIT_PWMCLKSYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect                                                       */
    GLBCLKCTL_BIT_PWMCLKSYNC_ENABLE        = 1,  /*!< Write a 1 will issue a PWM clock synchronization. This bit is self-cleared.   */
} GLBCLKCTL_BIT_PWMCLKSYNC;

#define GLBCLKCTL_ALL_PWMCLKSYNC_NO_EFFECT     ((0x0UL) << GLBCLKCTL_ALL_PWMCLKSYNC_Pos)
#define GLBCLKCTL_ALL_PWMCLKSYNC_ENABLE        ((0x1UL) << GLBCLKCTL_ALL_PWMCLKSYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           ECAPCLKCTL      DIV
 *  @access     CLOCK->ECAPCLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define ECAPCLKCTL_ALL_DIV_Pos (0)
#define ECAPCLKCTL_ALL_DIV_Msk (0x3FUL << ECAPCLKCTL_ALL_DIV_Pos)

#define ECAPCLKCTL_BIT_DIV

#define ECAPCLKCTL_ALL_DIV_(x) ((x) << ECAPCLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           ECAPCLKCTL      EN
 *  @access     CLOCK->ECAPCLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define ECAPCLKCTL_ALL_EN_Pos (7)
#define ECAPCLKCTL_ALL_EN_Msk (0x1UL << ECAPCLKCTL_ALL_EN_Pos)

typedef enum
{
    ECAPCLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    ECAPCLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} ECAPCLKCTL_BIT_EN;

#define ECAPCLKCTL_ALL_EN_DISABLE     ((0x0UL) << ECAPCLKCTL_ALL_EN_Pos)
#define ECAPCLKCTL_ALL_EN_ENABLE      ((0x1UL) << ECAPCLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           DGCLKCTL        DIV
 *  @access     CLOCK->DGCLKCTL.bit.DIV
 *  @brief      De-glitch clock dividing ratio from PCLK
 */
#define DGCLKCTL_ALL_DIV_Pos (0)
#define DGCLKCTL_ALL_DIV_Msk (0x7UL << DGCLKCTL_ALL_DIV_Pos)

typedef enum
{
    DGCLKCTL_BIT_DIV_1       = 0,  /*!< Divide by 1     */
    DGCLKCTL_BIT_DIV_2       = 1,  /*!< Divide by 2     */
    DGCLKCTL_BIT_DIV_4       = 2,  /*!< Divide by 4     */
    DGCLKCTL_BIT_DIV_8       = 3,  /*!< Divide by 8     */
    DGCLKCTL_BIT_DIV_16      = 4,  /*!< Divide by 16    */
    DGCLKCTL_BIT_DIV_32      = 5,  /*!< Divide by 32    */
    DGCLKCTL_BIT_DIV_64      = 6,  /*!< Divide by 64    */
    DGCLKCTL_BIT_DIV_128     = 7,  /*!< Divide by 128   */
} DGCLKCTL_BIT_DIV;

#define DGCLKCTL_ALL_DIV_1       ((0x0UL) << DGCLKCTL_ALL_DIV_Pos)
#define DGCLKCTL_ALL_DIV_2       ((0x1UL) << DGCLKCTL_ALL_DIV_Pos)
#define DGCLKCTL_ALL_DIV_4       ((0x2UL) << DGCLKCTL_ALL_DIV_Pos)
#define DGCLKCTL_ALL_DIV_8       ((0x3UL) << DGCLKCTL_ALL_DIV_Pos)
#define DGCLKCTL_ALL_DIV_16      ((0x4UL) << DGCLKCTL_ALL_DIV_Pos)
#define DGCLKCTL_ALL_DIV_32      ((0x5UL) << DGCLKCTL_ALL_DIV_Pos)
#define DGCLKCTL_ALL_DIV_64      ((0x6UL) << DGCLKCTL_ALL_DIV_Pos)
#define DGCLKCTL_ALL_DIV_128     ((0x7UL) << DGCLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM1CLKCTL      DIV
 *  @access     CLOCK->PWM1CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define PWM1CLKCTL_ALL_DIV_Pos (0)
#define PWM1CLKCTL_ALL_DIV_Msk (0x3FUL << PWM1CLKCTL_ALL_DIV_Pos)

#define PWM1CLKCTL_BIT_DIV

#define PWM1CLKCTL_ALL_DIV_(x) ((x) << PWM1CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM1CLKCTL      EN
 *  @access     CLOCK->PWM1CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define PWM1CLKCTL_ALL_EN_Pos (7)
#define PWM1CLKCTL_ALL_EN_Msk (0x1UL << PWM1CLKCTL_ALL_EN_Pos)

typedef enum
{
    PWM1CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    PWM1CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} PWM1CLKCTL_BIT_EN;

#define PWM1CLKCTL_ALL_EN_DISABLE     ((0x0UL) << PWM1CLKCTL_ALL_EN_Pos)
#define PWM1CLKCTL_ALL_EN_ENABLE      ((0x1UL) << PWM1CLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM2CLKCTL      DIV
 *  @access     CLOCK->PWM2CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define PWM2CLKCTL_ALL_DIV_Pos (0)
#define PWM2CLKCTL_ALL_DIV_Msk (0x3FUL << PWM2CLKCTL_ALL_DIV_Pos)

#define PWM2CLKCTL_BIT_DIV

#define PWM2CLKCTL_ALL_DIV_(x) ((x) << PWM2CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM2CLKCTL      EN
 *  @access     CLOCK->PWM2CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define PWM2CLKCTL_ALL_EN_Pos (7)
#define PWM2CLKCTL_ALL_EN_Msk (0x1UL << PWM2CLKCTL_ALL_EN_Pos)

typedef enum
{
    PWM2CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    PWM2CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} PWM2CLKCTL_BIT_EN;

#define PWM2CLKCTL_ALL_EN_DISABLE     ((0x0UL) << PWM2CLKCTL_ALL_EN_Pos)
#define PWM2CLKCTL_ALL_EN_ENABLE      ((0x1UL) << PWM2CLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM3CLKCTL      DIV
 *  @access     CLOCK->PWM3CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define PWM3CLKCTL_ALL_DIV_Pos (0)
#define PWM3CLKCTL_ALL_DIV_Msk (0x3FUL << PWM3CLKCTL_ALL_DIV_Pos)

#define PWM3CLKCTL_BIT_DIV

#define PWM3CLKCTL_ALL_DIV_(x) ((x) << PWM3CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM3CLKCTL      EN
 *  @access     CLOCK->PWM3CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define PWM3CLKCTL_ALL_EN_Pos (7)
#define PWM3CLKCTL_ALL_EN_Msk (0x1UL << PWM3CLKCTL_ALL_EN_Pos)

typedef enum
{
    PWM3CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    PWM3CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} PWM3CLKCTL_BIT_EN;

#define PWM3CLKCTL_ALL_EN_DISABLE     ((0x0UL) << PWM3CLKCTL_ALL_EN_Pos)
#define PWM3CLKCTL_ALL_EN_ENABLE      ((0x1UL) << PWM3CLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM4CLKCTL      DIV
 *  @access     CLOCK->PWM4CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define PWM4CLKCTL_ALL_DIV_Pos (0)
#define PWM4CLKCTL_ALL_DIV_Msk (0x3FUL << PWM4CLKCTL_ALL_DIV_Pos)

#define PWM4CLKCTL_BIT_DIV

#define PWM4CLKCTL_ALL_DIV_(x) ((x) << PWM4CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM4CLKCTL      EN
 *  @access     CLOCK->PWM4CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define PWM4CLKCTL_ALL_EN_Pos (7)
#define PWM4CLKCTL_ALL_EN_Msk (0x1UL << PWM4CLKCTL_ALL_EN_Pos)

typedef enum
{
    PWM4CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    PWM4CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} PWM4CLKCTL_BIT_EN;

#define PWM4CLKCTL_ALL_EN_DISABLE     ((0x0UL) << PWM4CLKCTL_ALL_EN_Pos)
#define PWM4CLKCTL_ALL_EN_ENABLE      ((0x1UL) << PWM4CLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM5CLKCTL      DIV
 *  @access     CLOCK->PWM5CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define PWM5CLKCTL_ALL_DIV_Pos (0)
#define PWM5CLKCTL_ALL_DIV_Msk (0x3FUL << PWM5CLKCTL_ALL_DIV_Pos)

#define PWM5CLKCTL_BIT_DIV

#define PWM5CLKCTL_ALL_DIV_(x) ((x) << PWM5CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM5CLKCTL      EN
 *  @access     CLOCK->PWM5CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define PWM5CLKCTL_ALL_EN_Pos (7)
#define PWM5CLKCTL_ALL_EN_Msk (0x1UL << PWM5CLKCTL_ALL_EN_Pos)

typedef enum
{
    PWM5CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    PWM5CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} PWM5CLKCTL_BIT_EN;

#define PWM5CLKCTL_ALL_EN_DISABLE     ((0x0UL) << PWM5CLKCTL_ALL_EN_Pos)
#define PWM5CLKCTL_ALL_EN_ENABLE      ((0x1UL) << PWM5CLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM6CLKCTL      DIV
 *  @access     CLOCK->PWM6CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define PWM6CLKCTL_ALL_DIV_Pos (0)
#define PWM6CLKCTL_ALL_DIV_Msk (0x3FUL << PWM6CLKCTL_ALL_DIV_Pos)

#define PWM6CLKCTL_BIT_DIV

#define PWM6CLKCTL_ALL_DIV_(x) ((x) << PWM6CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PWM6CLKCTL      EN
 *  @access     CLOCK->PWM6CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define PWM6CLKCTL_ALL_EN_Pos (7)
#define PWM6CLKCTL_ALL_EN_Msk (0x1UL << PWM6CLKCTL_ALL_EN_Pos)

typedef enum
{
    PWM6CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    PWM6CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} PWM6CLKCTL_BIT_EN;

#define PWM6CLKCTL_ALL_EN_DISABLE     ((0x0UL) << PWM6CLKCTL_ALL_EN_Pos)
#define PWM6CLKCTL_ALL_EN_ENABLE      ((0x1UL) << PWM6CLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTL       RCLKSEL
 *  @access     CLOCK->CLKDETCTL.bit.RCLKSEL
 *  @brief      Master clock select
 */
#define CLKDETCTL_ALL_RCLKSEL_Pos (0)
#define CLKDETCTL_ALL_RCLKSEL_Msk (0x7UL << CLKDETCTL_ALL_RCLKSEL_Pos)

typedef enum
{
    CLKDETCTL_BIT_RCLKSEL_RCO0     = 0,  /*!< CLK_RCO0   */
    CLKDETCTL_BIT_RCLKSEL_RCO1     = 1,  /*!< CLK_RCO1   */
    CLKDETCTL_BIT_RCLKSEL_XO       = 2,  /*!< CLK_XO     */
    CLKDETCTL_BIT_RCLKSEL_PLL      = 3,  /*!< CLK_PLL    */
    CLKDETCTL_BIT_RCLKSEL_PWM      = 4,  /*!< CLK_PWM    */
} CLKDETCTL_BIT_RCLKSEL;

#define CLKDETCTL_ALL_RCLKSEL_RCO0     ((0x0UL) << CLKDETCTL_ALL_RCLKSEL_Pos)
#define CLKDETCTL_ALL_RCLKSEL_RCO1     ((0x1UL) << CLKDETCTL_ALL_RCLKSEL_Pos)
#define CLKDETCTL_ALL_RCLKSEL_XO       ((0x2UL) << CLKDETCTL_ALL_RCLKSEL_Pos)
#define CLKDETCTL_ALL_RCLKSEL_PLL      ((0x3UL) << CLKDETCTL_ALL_RCLKSEL_Pos)
#define CLKDETCTL_ALL_RCLKSEL_PWM      ((0x4UL) << CLKDETCTL_ALL_RCLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTL       DCLKSEL
 *  @access     CLOCK->CLKDETCTL.bit.DCLKSEL
 *  @brief      Detected clock select
 */
#define CLKDETCTL_ALL_DCLKSEL_Pos (3)
#define CLKDETCTL_ALL_DCLKSEL_Msk (0x7UL << CLKDETCTL_ALL_DCLKSEL_Pos)

typedef enum
{
    CLKDETCTL_BIT_DCLKSEL_RCO0     = 0,  /*!< CLK_RCO0   */
    CLKDETCTL_BIT_DCLKSEL_RCO1     = 1,  /*!< CLK_RCO1   */
    CLKDETCTL_BIT_DCLKSEL_XO       = 2,  /*!< CLK_XO     */
    CLKDETCTL_BIT_DCLKSEL_PLL      = 3,  /*!< CLK_PLL    */
    CLKDETCTL_BIT_DCLKSEL_PWM      = 4,  /*!< CLK_PWM    */
} CLKDETCTL_BIT_DCLKSEL;

#define CLKDETCTL_ALL_DCLKSEL_RCO0     ((0x0UL) << CLKDETCTL_ALL_DCLKSEL_Pos)
#define CLKDETCTL_ALL_DCLKSEL_RCO1     ((0x1UL) << CLKDETCTL_ALL_DCLKSEL_Pos)
#define CLKDETCTL_ALL_DCLKSEL_XO       ((0x2UL) << CLKDETCTL_ALL_DCLKSEL_Pos)
#define CLKDETCTL_ALL_DCLKSEL_PLL      ((0x3UL) << CLKDETCTL_ALL_DCLKSEL_Pos)
#define CLKDETCTL_ALL_DCLKSEL_PWM      ((0x4UL) << CLKDETCTL_ALL_DCLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTL       RCLKDIV
 *  @access     CLOCK->CLKDETCTL.bit.RCLKDIV
 *  @brief      MCLK dividing ratio
 */
#define CLKDETCTL_ALL_RCLKDIV_Pos (6)
#define CLKDETCTL_ALL_RCLKDIV_Msk (0x7UL << CLKDETCTL_ALL_RCLKDIV_Pos)

typedef enum
{
    CLKDETCTL_BIT_RCLKDIV_1       = 0,  /*!< Divide by 1     */
    CLKDETCTL_BIT_RCLKDIV_2       = 1,  /*!< Divide by 2     */
    CLKDETCTL_BIT_RCLKDIV_4       = 2,  /*!< Divide by 4     */
    CLKDETCTL_BIT_RCLKDIV_8       = 3,  /*!< Divide by 8     */
    CLKDETCTL_BIT_RCLKDIV_16      = 4,  /*!< Divide by 16    */
    CLKDETCTL_BIT_RCLKDIV_32      = 5,  /*!< Divide by 32    */
    CLKDETCTL_BIT_RCLKDIV_64      = 6,  /*!< Divide by 64    */
    CLKDETCTL_BIT_RCLKDIV_128     = 7,  /*!< Divide by 128   */
} CLKDETCTL_BIT_RCLKDIV;

#define CLKDETCTL_ALL_RCLKDIV_1       ((0x0UL) << CLKDETCTL_ALL_RCLKDIV_Pos)
#define CLKDETCTL_ALL_RCLKDIV_2       ((0x1UL) << CLKDETCTL_ALL_RCLKDIV_Pos)
#define CLKDETCTL_ALL_RCLKDIV_4       ((0x2UL) << CLKDETCTL_ALL_RCLKDIV_Pos)
#define CLKDETCTL_ALL_RCLKDIV_8       ((0x3UL) << CLKDETCTL_ALL_RCLKDIV_Pos)
#define CLKDETCTL_ALL_RCLKDIV_16      ((0x4UL) << CLKDETCTL_ALL_RCLKDIV_Pos)
#define CLKDETCTL_ALL_RCLKDIV_32      ((0x5UL) << CLKDETCTL_ALL_RCLKDIV_Pos)
#define CLKDETCTL_ALL_RCLKDIV_64      ((0x6UL) << CLKDETCTL_ALL_RCLKDIV_Pos)
#define CLKDETCTL_ALL_RCLKDIV_128     ((0x7UL) << CLKDETCTL_ALL_RCLKDIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTL       DCLKDIV
 *  @access     CLOCK->CLKDETCTL.bit.DCLKDIV
 *  @brief      DCLK dividing ratio
 */
#define CLKDETCTL_ALL_DCLKDIV_Pos (9)
#define CLKDETCTL_ALL_DCLKDIV_Msk (0x7UL << CLKDETCTL_ALL_DCLKDIV_Pos)

typedef enum
{
    CLKDETCTL_BIT_DCLKDIV_1       = 0,  /*!< Divide by 1     */
    CLKDETCTL_BIT_DCLKDIV_2       = 1,  /*!< Divide by 2     */
    CLKDETCTL_BIT_DCLKDIV_4       = 2,  /*!< Divide by 4     */
    CLKDETCTL_BIT_DCLKDIV_8       = 3,  /*!< Divide by 8     */
    CLKDETCTL_BIT_DCLKDIV_16      = 4,  /*!< Divide by 16    */
    CLKDETCTL_BIT_DCLKDIV_32      = 5,  /*!< Divide by 32    */
    CLKDETCTL_BIT_DCLKDIV_64      = 6,  /*!< Divide by 64    */
    CLKDETCTL_BIT_DCLKDIV_128     = 7,  /*!< Divide by 128   */
} CLKDETCTL_BIT_DCLKDIV;

#define CLKDETCTL_ALL_DCLKDIV_1       ((0x0UL) << CLKDETCTL_ALL_DCLKDIV_Pos)
#define CLKDETCTL_ALL_DCLKDIV_2       ((0x1UL) << CLKDETCTL_ALL_DCLKDIV_Pos)
#define CLKDETCTL_ALL_DCLKDIV_4       ((0x2UL) << CLKDETCTL_ALL_DCLKDIV_Pos)
#define CLKDETCTL_ALL_DCLKDIV_8       ((0x3UL) << CLKDETCTL_ALL_DCLKDIV_Pos)
#define CLKDETCTL_ALL_DCLKDIV_16      ((0x4UL) << CLKDETCTL_ALL_DCLKDIV_Pos)
#define CLKDETCTL_ALL_DCLKDIV_32      ((0x5UL) << CLKDETCTL_ALL_DCLKDIV_Pos)
#define CLKDETCTL_ALL_DCLKDIV_64      ((0x6UL) << CLKDETCTL_ALL_DCLKDIV_Pos)
#define CLKDETCTL_ALL_DCLKDIV_128     ((0x7UL) << CLKDETCTL_ALL_DCLKDIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTL       IC
 *  @access     CLOCK->CLKDETCTL.bit.IC
 *  @brief      Clock detection interrupt clear
 */
#define CLKDETCTL_ALL_IC_Pos (12)
#define CLKDETCTL_ALL_IC_Msk (0x1UL << CLKDETCTL_ALL_IC_Pos)

typedef enum
{
    CLKDETCTL_BIT_IC_CLEAR     = 1,  /*!< Write 1 will clear the interrupt event. This bit is self cleared to 0   */
} CLKDETCTL_BIT_IC;

#define CLKDETCTL_ALL_IC_CLEAR     ((0x1UL) << CLKDETCTL_ALL_IC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTL       IE
 *  @access     CLOCK->CLKDETCTL.bit.IE
 *  @brief      Clock detection interrupt enable
 *              When enabled, an interrupt will be generated at the end of a clock detect cycle
 */
#define CLKDETCTL_ALL_IE_Pos (13)
#define CLKDETCTL_ALL_IE_Msk (0x1UL << CLKDETCTL_ALL_IE_Pos)

typedef enum
{
    CLKDETCTL_BIT_IE_DISABLE     = 0,  /*!< Disable clock detection interrupt   */
    CLKDETCTL_BIT_IE_ENABLE      = 1,  /*!< Enable clock detection interrupt    */
} CLKDETCTL_BIT_IE;

#define CLKDETCTL_ALL_IE_DISABLE     ((0x0UL) << CLKDETCTL_ALL_IE_Pos)
#define CLKDETCTL_ALL_IE_ENABLE      ((0x1UL) << CLKDETCTL_ALL_IE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTL       TZOE
 *  @access     CLOCK->CLKDETCTL.bit.TZOE
 *  @brief      Clock error trip-zone event enable
 *              This bit does not affect internal clock error status. If clock error happened during the period this bit is set to 0, a trip-zone event will be issued immediately when this bit is set to 1
 */
#define CLKDETCTL_ALL_TZOE_Pos (14)
#define CLKDETCTL_ALL_TZOE_Msk (0x1UL << CLKDETCTL_ALL_TZOE_Pos)

typedef enum
{
    CLKDETCTL_BIT_TZOE_DISABLE     = 0,  /*!< Disable clock error trip-zone event   */
    CLKDETCTL_BIT_TZOE_ENABLE      = 1,  /*!< Enable clock error trip-zone event    */
} CLKDETCTL_BIT_TZOE;

#define CLKDETCTL_ALL_TZOE_DISABLE     ((0x0UL) << CLKDETCTL_ALL_TZOE_Pos)
#define CLKDETCTL_ALL_TZOE_ENABLE      ((0x1UL) << CLKDETCTL_ALL_TZOE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTL       EN
 *  @access     CLOCK->CLKDETCTL.bit.EN
 *  @brief      Clock detection enable
 *              When disabled, the interrupts and the clock error events will be cleared
 */
#define CLKDETCTL_ALL_EN_Pos (15)
#define CLKDETCTL_ALL_EN_Msk (0x1UL << CLKDETCTL_ALL_EN_Pos)

typedef enum
{
    CLKDETCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock detection   */
    CLKDETCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock detection    */
} CLKDETCTL_BIT_EN;

#define CLKDETCTL_ALL_EN_DISABLE     ((0x0UL) << CLKDETCTL_ALL_EN_Pos)
#define CLKDETCTL_ALL_EN_ENABLE      ((0x1UL) << CLKDETCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTH       LO
 *  @access     CLOCK->CLKDETCTH.bit.LO
 *  @brief      Lower counter threshold for clock detect
 *              If the final counter value < LO, a trip-zone event will be generated for PWM
 */
#define CLKDETCTH_ALL_LO_Pos (0)
#define CLKDETCTH_ALL_LO_Msk (0xFFFFUL << CLKDETCTH_ALL_LO_Pos)

#define CLKDETCTH_BIT_LO

#define CLKDETCTH_ALL_LO_(x) ((x) << CLKDETCTH_ALL_LO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCTH       HI
 *  @access     CLOCK->CLKDETCTH.bit.HI
 *  @brief      Upper counter threshold for clock detect
 *              If the final counter value > HI, a trip-zone event will be generated for PWM
 */
#define CLKDETCTH_ALL_HI_Pos (16)
#define CLKDETCTH_ALL_HI_Msk (0xFFFFUL << CLKDETCTH_ALL_HI_Pos)

#define CLKDETCTH_BIT_HI

#define CLKDETCTH_ALL_HI_(x) ((x) << CLKDETCTH_ALL_HI_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKDETCNT       VAL
 *  @access     CLOCK->CLKDETCNT.bit.VAL
 *  @brief      Final counter value of the clock detect
 */
#define CLKDETCNT_ALL_VAL_Pos (0)
#define CLKDETCNT_ALL_VAL_Msk (0xFFFFUL << CLKDETCNT_ALL_VAL_Pos)

#define CLKDETCNT_BIT_VAL

#define CLKDETCNT_ALL_VAL_(x) ((x) << CLKDETCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          CPREGRDY
 *  @access     CLOCK->CLKSTS.bit.CPREGRDY
 *  @brief      CPREG ready indicator
 */
#define CLKSTS_ALL_CPREGRDY_Pos (0)
#define CLKSTS_ALL_CPREGRDY_Msk (0x1UL << CLKSTS_ALL_CPREGRDY_Pos)

typedef enum
{
    CLKSTS_BIT_CPREGRDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_CPREGRDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_CPREGRDY;

#define CLKSTS_ALL_CPREGRDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_CPREGRDY_Pos)
#define CLKSTS_ALL_CPREGRDY_READY         ((0x1UL) << CLKSTS_ALL_CPREGRDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          RCO0ARDY
 *  @access     CLOCK->CLKSTS.bit.RCO0ARDY
 *  @brief      RCO0 analog clock ready indicator
 */
#define CLKSTS_ALL_RCO0ARDY_Pos (1)
#define CLKSTS_ALL_RCO0ARDY_Msk (0x1UL << CLKSTS_ALL_RCO0ARDY_Pos)

typedef enum
{
    CLKSTS_BIT_RCO0ARDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_RCO0ARDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_RCO0ARDY;

#define CLKSTS_ALL_RCO0ARDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_RCO0ARDY_Pos)
#define CLKSTS_ALL_RCO0ARDY_READY         ((0x1UL) << CLKSTS_ALL_RCO0ARDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          RCO0DRDY
 *  @access     CLOCK->CLKSTS.bit.RCO0DRDY
 *  @brief      RCO0 digital clock ready indicator
 */
#define CLKSTS_ALL_RCO0DRDY_Pos (2)
#define CLKSTS_ALL_RCO0DRDY_Msk (0x1UL << CLKSTS_ALL_RCO0DRDY_Pos)

typedef enum
{
    CLKSTS_BIT_RCO0DRDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_RCO0DRDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_RCO0DRDY;

#define CLKSTS_ALL_RCO0DRDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_RCO0DRDY_Pos)
#define CLKSTS_ALL_RCO0DRDY_READY         ((0x1UL) << CLKSTS_ALL_RCO0DRDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          RCO1ARDY
 *  @access     CLOCK->CLKSTS.bit.RCO1ARDY
 *  @brief      RCO1 analog clock ready indicator
 */
#define CLKSTS_ALL_RCO1ARDY_Pos (3)
#define CLKSTS_ALL_RCO1ARDY_Msk (0x1UL << CLKSTS_ALL_RCO1ARDY_Pos)

typedef enum
{
    CLKSTS_BIT_RCO1ARDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_RCO1ARDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_RCO1ARDY;

#define CLKSTS_ALL_RCO1ARDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_RCO1ARDY_Pos)
#define CLKSTS_ALL_RCO1ARDY_READY         ((0x1UL) << CLKSTS_ALL_RCO1ARDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          RCO1DRDY
 *  @access     CLOCK->CLKSTS.bit.RCO1DRDY
 *  @brief      RCO1 digital clock ready indicator
 */
#define CLKSTS_ALL_RCO1DRDY_Pos (4)
#define CLKSTS_ALL_RCO1DRDY_Msk (0x1UL << CLKSTS_ALL_RCO1DRDY_Pos)

typedef enum
{
    CLKSTS_BIT_RCO1DRDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_RCO1DRDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_RCO1DRDY;

#define CLKSTS_ALL_RCO1DRDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_RCO1DRDY_Pos)
#define CLKSTS_ALL_RCO1DRDY_READY         ((0x1UL) << CLKSTS_ALL_RCO1DRDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          XORDY
 *  @access     CLOCK->CLKSTS.bit.XORDY
 *  @brief      XO clock ready indicator
 */
#define CLKSTS_ALL_XORDY_Pos (6)
#define CLKSTS_ALL_XORDY_Msk (0x1UL << CLKSTS_ALL_XORDY_Pos)

typedef enum
{
    CLKSTS_BIT_XORDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_XORDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_XORDY;

#define CLKSTS_ALL_XORDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_XORDY_Pos)
#define CLKSTS_ALL_XORDY_READY         ((0x1UL) << CLKSTS_ALL_XORDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          PLLARDY
 *  @access     CLOCK->CLKSTS.bit.PLLARDY
 *  @brief      PLL analog clock ready indicator
 */
#define CLKSTS_ALL_PLLARDY_Pos (7)
#define CLKSTS_ALL_PLLARDY_Msk (0x1UL << CLKSTS_ALL_PLLARDY_Pos)

typedef enum
{
    CLKSTS_BIT_PLLARDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_PLLARDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_PLLARDY;

#define CLKSTS_ALL_PLLARDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_PLLARDY_Pos)
#define CLKSTS_ALL_PLLARDY_READY         ((0x1UL) << CLKSTS_ALL_PLLARDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          PLLDRDY
 *  @access     CLOCK->CLKSTS.bit.PLLDRDY
 *  @brief      PLL digital clock ready indicator
 */
#define CLKSTS_ALL_PLLDRDY_Pos (8)
#define CLKSTS_ALL_PLLDRDY_Msk (0x1UL << CLKSTS_ALL_PLLDRDY_Pos)

typedef enum
{
    CLKSTS_BIT_PLLDRDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_PLLDRDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_PLLDRDY;

#define CLKSTS_ALL_PLLDRDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_PLLDRDY_Pos)
#define CLKSTS_ALL_PLLDRDY_READY         ((0x1UL) << CLKSTS_ALL_PLLDRDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          PLLPRDY
 *  @access     CLOCK->CLKSTS.bit.PLLPRDY
 *  @brief      PLL PWM clock ready indicator
 */
#define CLKSTS_ALL_PLLPRDY_Pos (9)
#define CLKSTS_ALL_PLLPRDY_Msk (0x1UL << CLKSTS_ALL_PLLPRDY_Pos)

typedef enum
{
    CLKSTS_BIT_PLLPRDY_NOT_READY     = 0,  /*!< Not ready   */
    CLKSTS_BIT_PLLPRDY_READY         = 1,  /*!< Ready       */
} CLKSTS_BIT_PLLPRDY;

#define CLKSTS_ALL_PLLPRDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_PLLPRDY_Pos)
#define CLKSTS_ALL_PLLPRDY_READY         ((0x1UL) << CLKSTS_ALL_PLLPRDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          PLLCSDUP
 *  @access     CLOCK->CLKSTS.bit.PLLCSDUP
 *  @brief      PLL up-cycle-slip detection status
 *              Once it is 1, this bit keeps as 1 until PLLCTL10.CSDEN=0 or PLLCTL0.CSDRST=1
 */
#define CLKSTS_ALL_PLLCSDUP_Pos (18)
#define CLKSTS_ALL_PLLCSDUP_Msk (0x1UL << CLKSTS_ALL_PLLCSDUP_Pos)

typedef enum
{
    CLKSTS_BIT_PLLCSDUP_NOT_DETECTED     = 0,  /*!< Up-cycle-slip is not detected                                         */
    CLKSTS_BIT_PLLCSDUP_DETECTED         = 1,  /*!< Up-cycle-slip is detected since feedback divider output is too fast   */
} CLKSTS_BIT_PLLCSDUP;

#define CLKSTS_ALL_PLLCSDUP_NOT_DETECTED     ((0x0UL) << CLKSTS_ALL_PLLCSDUP_Pos)
#define CLKSTS_ALL_PLLCSDUP_DETECTED         ((0x1UL) << CLKSTS_ALL_PLLCSDUP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          PLLCSDDN
 *  @access     CLOCK->CLKSTS.bit.PLLCSDDN
 *  @brief      PLL down-cycle-slip detection status
 *              Once it is 1, this bit keeps as 1 until PLLCTL0.CSDEN=0 or PLLCTL0.CSDRST=1
 */
#define CLKSTS_ALL_PLLCSDDN_Pos (19)
#define CLKSTS_ALL_PLLCSDDN_Msk (0x1UL << CLKSTS_ALL_PLLCSDDN_Pos)

typedef enum
{
    CLKSTS_BIT_PLLCSDDN_NOT_DETECTED     = 0,  /*!< Down-cycle-slip is not detected                                         */
    CLKSTS_BIT_PLLCSDDN_DETECTED         = 1,  /*!< Down-cycle-slip is detected since feedback divider output is too fast   */
} CLKSTS_BIT_PLLCSDDN;

#define CLKSTS_ALL_PLLCSDDN_NOT_DETECTED     ((0x0UL) << CLKSTS_ALL_PLLCSDDN_Pos)
#define CLKSTS_ALL_PLLCSDDN_DETECTED         ((0x1UL) << CLKSTS_ALL_PLLCSDDN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          PLLFLG
 *  @access     CLOCK->CLKSTS.bit.PLLFLG
 *  @brief      PLL frequency calibration flag
 */
#define CLKSTS_ALL_PLLFLG_Pos (20)
#define CLKSTS_ALL_PLLFLG_Msk (0x1UL << CLKSTS_ALL_PLLFLG_Pos)

typedef enum
{
    CLKSTS_BIT_PLLFLG_TOO_SLOW     = 0,  /*!< VCO in PLL is too slow   */
    CLKSTS_BIT_PLLFLG_TOO_FAST     = 1,  /*!< VCO in PLL is too fast   */
} CLKSTS_BIT_PLLFLG;

#define CLKSTS_ALL_PLLFLG_TOO_SLOW     ((0x0UL) << CLKSTS_ALL_PLLFLG_Pos)
#define CLKSTS_ALL_PLLFLG_TOO_FAST     ((0x1UL) << CLKSTS_ALL_PLLFLG_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          PLLFLGRDY
 *  @access     CLOCK->CLKSTS.bit.PLLFLGRDY
 *  @brief      PLL frequency calibration flag ready indicator
 */
#define CLKSTS_ALL_PLLFLGRDY_Pos (21)
#define CLKSTS_ALL_PLLFLGRDY_Msk (0x1UL << CLKSTS_ALL_PLLFLGRDY_Pos)

typedef enum
{
    CLKSTS_BIT_PLLFLGRDY_NOT_READY     = 0,  /*!< PLLFLG is invalid   */
    CLKSTS_BIT_PLLFLGRDY_READY         = 1,  /*!< PLLFLG is valid     */
} CLKSTS_BIT_PLLFLGRDY;

#define CLKSTS_ALL_PLLFLGRDY_NOT_READY     ((0x0UL) << CLKSTS_ALL_PLLFLGRDY_Pos)
#define CLKSTS_ALL_PLLFLGRDY_READY         ((0x1UL) << CLKSTS_ALL_PLLFLGRDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CLKSTS          CLKDETERR
 *  @access     CLOCK->CLKSTS.bit.CLKDETERR
 *  @brief      Clock error indicator from the clock detector
 */
#define CLKSTS_ALL_CLKDETERR_Pos (22)
#define CLKSTS_ALL_CLKDETERR_Msk (0x1UL << CLKSTS_ALL_CLKDETERR_Pos)

typedef enum
{
    CLKSTS_BIT_CLKDETERR_NOT_OCCUR     = 0,  /*!< Clock is correct for last detection   */
    CLKSTS_BIT_CLKDETERR_OCCUR         = 1,  /*!< Clock is error for last detection     */
} CLKSTS_BIT_CLKDETERR;

#define CLKSTS_ALL_CLKDETERR_NOT_OCCUR     ((0x0UL) << CLKSTS_ALL_CLKDETERR_Pos)
#define CLKSTS_ALL_CLKDETERR_OCCUR         ((0x1UL) << CLKSTS_ALL_CLKDETERR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CPREGCTL        EN
 *  @access     CLOCK->CPREGCTL.bit.EN
 *  @brief      Charge-pump regulator enable
 */
#define CPREGCTL_ALL_EN_Pos (0)
#define CPREGCTL_ALL_EN_Msk (0x1UL << CPREGCTL_ALL_EN_Pos)

typedef enum
{
    CPREGCTL_BIT_EN_DISABLE     = 0,  /*!< Disable   */
    CPREGCTL_BIT_EN_ENABLE      = 1,  /*!< Enable    */
} CPREGCTL_BIT_EN;

#define CPREGCTL_ALL_EN_DISABLE     ((0x0UL) << CPREGCTL_ALL_EN_Pos)
#define CPREGCTL_ALL_EN_ENABLE      ((0x1UL) << CPREGCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           CPREGCTL        VREFSEL
 *  @access     CLOCK->CPREGCTL.bit.VREFSEL
 *  @brief      Reference voltage select
 */
#define CPREGCTL_ALL_VREFSEL_Pos (2)
#define CPREGCTL_ALL_VREFSEL_Msk (0xFUL << CPREGCTL_ALL_VREFSEL_Pos)

typedef enum
{
    CPREGCTL_BIT_VREFSEL_1dot13_V     = 0,  /*!< 1.13V   */
    CPREGCTL_BIT_VREFSEL_1dot14_V     = 1,  /*!< 1.14V   */
    CPREGCTL_BIT_VREFSEL_1dot15_V     = 2,  /*!< 1.15V   */
    CPREGCTL_BIT_VREFSEL_1dot16_V     = 3,  /*!< 1.16V   */
    CPREGCTL_BIT_VREFSEL_1dot17_V     = 4,  /*!< 1.17V   */
    CPREGCTL_BIT_VREFSEL_1dot18_V     = 5,  /*!< 1.18V   */
    CPREGCTL_BIT_VREFSEL_1dot19_V     = 6,  /*!< 1.19V   */
    CPREGCTL_BIT_VREFSEL_1dot20_V     = 7,  /*!< 1.20V   */
    CPREGCTL_BIT_VREFSEL_1dot21_V     = 8,  /*!< 1.21V   */
    CPREGCTL_BIT_VREFSEL_1dot22_V     = 9,  /*!< 1.22V   */
    CPREGCTL_BIT_VREFSEL_1dot23_V     = 10,  /*!< 1.23V   */
    CPREGCTL_BIT_VREFSEL_1dot24_V     = 11,  /*!< 1.24V   */
    CPREGCTL_BIT_VREFSEL_1dot25_V     = 12,  /*!< 1.25V   */
    CPREGCTL_BIT_VREFSEL_1dot26_V     = 13,  /*!< 1.26V   */
    CPREGCTL_BIT_VREFSEL_1dot27_V     = 14,  /*!< 1.27V   */
    CPREGCTL_BIT_VREFSEL_1dot28_V     = 15,  /*!< 1.28V   */
} CPREGCTL_BIT_VREFSEL;

#define CPREGCTL_ALL_VREFSEL_1dot13_V     ((0x00UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot14_V     ((0x01UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot15_V     ((0x02UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot16_V     ((0x03UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot17_V     ((0x04UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot18_V     ((0x05UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot19_V     ((0x06UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot20_V     ((0x07UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot21_V     ((0x08UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot22_V     ((0x09UL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot23_V     ((0x0AUL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot24_V     ((0x0BUL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot25_V     ((0x0CUL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot26_V     ((0x0DUL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot27_V     ((0x0EUL) << CPREGCTL_ALL_VREFSEL_Pos)
#define CPREGCTL_ALL_VREFSEL_1dot28_V     ((0x0FUL) << CPREGCTL_ALL_VREFSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO0CTL         EN
 *  @access     CLOCK->RCO0CTL.bit.EN
 *  @brief      RCO0 enable
 */
#define RCO0CTL_ALL_EN_Pos (0)
#define RCO0CTL_ALL_EN_Msk (0x1UL << RCO0CTL_ALL_EN_Pos)

typedef enum
{
    RCO0CTL_BIT_EN_DISABLE     = 0,  /*!< Disable   */
    RCO0CTL_BIT_EN_ENABLE      = 1,  /*!< Enable    */
} RCO0CTL_BIT_EN;

#define RCO0CTL_ALL_EN_DISABLE     ((0x0UL) << RCO0CTL_ALL_EN_Pos)
#define RCO0CTL_ALL_EN_ENABLE      ((0x1UL) << RCO0CTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO0CTL         MODE
 *  @access     CLOCK->RCO0CTL.bit.MODE
 *  @brief      RCO0 mode
 */
#define RCO0CTL_ALL_MODE_Pos (1)
#define RCO0CTL_ALL_MODE_Msk (0x1UL << RCO0CTL_ALL_MODE_Pos)

typedef enum
{
    RCO0CTL_BIT_MODE_24MHZ     = 0,  /*!< 24MHz   */
    RCO0CTL_BIT_MODE_48MHZ     = 1,  /*!< 48MHz   */
} RCO0CTL_BIT_MODE;

#define RCO0CTL_ALL_MODE_24MHZ     ((0x0UL) << RCO0CTL_ALL_MODE_Pos)
#define RCO0CTL_ALL_MODE_48MHZ     ((0x1UL) << RCO0CTL_ALL_MODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO0CTL         CPREGBYP
 *  @access     CLOCK->RCO0CTL.bit.CPREGBYP
 *  @brief      Bypass internal 1.2V regulator
 */
#define RCO0CTL_ALL_CPREGBYP_Pos (2)
#define RCO0CTL_ALL_CPREGBYP_Msk (0x1UL << RCO0CTL_ALL_CPREGBYP_Pos)

typedef enum
{
    RCO0CTL_BIT_CPREGBYP_DISABLE     = 0,  /*!< Connect 1.2V RCO1 gates to internal 1.2V regulator   */
    RCO0CTL_BIT_CPREGBYP_ENABLE      = 1,  /*!< Connect 1.2V RCO1 gates to digital 1.2V power rail   */
} RCO0CTL_BIT_CPREGBYP;

#define RCO0CTL_ALL_CPREGBYP_DISABLE     ((0x0UL) << RCO0CTL_ALL_CPREGBYP_Pos)
#define RCO0CTL_ALL_CPREGBYP_ENABLE      ((0x1UL) << RCO0CTL_ALL_CPREGBYP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO0CTL         TEMPTRIM
 *  @access     CLOCK->RCO0CTL.bit.TEMPTRIM
 *  @brief      RCO0 frequency temperature trimming
 *              Frequency increases with temperature faster for larger trim code
 */
#define RCO0CTL_ALL_TEMPTRIM_Pos (3)
#define RCO0CTL_ALL_TEMPTRIM_Msk (0xFUL << RCO0CTL_ALL_TEMPTRIM_Pos)

#define RCO0CTL_BIT_TEMPTRIM

#define RCO0CTL_ALL_TEMPTRIM_(x) ((x) << RCO0CTL_ALL_TEMPTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO0CTL         FREQTRIM
 *  @access     CLOCK->RCO0CTL.bit.FREQTRIM
 *  @brief      RCO0 frequency trimming
 *              Frequency increases for larger code
 */
#define RCO0CTL_ALL_FREQTRIM_Pos (7)
#define RCO0CTL_ALL_FREQTRIM_Msk (0x1FFUL << RCO0CTL_ALL_FREQTRIM_Pos)

#define RCO0CTL_BIT_FREQTRIM

#define RCO0CTL_ALL_FREQTRIM_(x) ((x) << RCO0CTL_ALL_FREQTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO1CTL         EN
 *  @access     CLOCK->RCO1CTL.bit.EN
 *  @brief      RCO1 enable
 */
#define RCO1CTL_ALL_EN_Pos (0)
#define RCO1CTL_ALL_EN_Msk (0x1UL << RCO1CTL_ALL_EN_Pos)

typedef enum
{
    RCO1CTL_BIT_EN_DISABLE     = 0,  /*!< Disable   */
    RCO1CTL_BIT_EN_ENABLE      = 1,  /*!< Enable    */
} RCO1CTL_BIT_EN;

#define RCO1CTL_ALL_EN_DISABLE     ((0x0UL) << RCO1CTL_ALL_EN_Pos)
#define RCO1CTL_ALL_EN_ENABLE      ((0x1UL) << RCO1CTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO1CTL         MODE
 *  @access     CLOCK->RCO1CTL.bit.MODE
 *  @brief      RCO1 mode
 */
#define RCO1CTL_ALL_MODE_Pos (1)
#define RCO1CTL_ALL_MODE_Msk (0x1UL << RCO1CTL_ALL_MODE_Pos)

typedef enum
{
    RCO1CTL_BIT_MODE_24MHZ     = 0,  /*!< 24MHz   */
    RCO1CTL_BIT_MODE_48MHZ     = 1,  /*!< 48MHz   */
} RCO1CTL_BIT_MODE;

#define RCO1CTL_ALL_MODE_24MHZ     ((0x0UL) << RCO1CTL_ALL_MODE_Pos)
#define RCO1CTL_ALL_MODE_48MHZ     ((0x1UL) << RCO1CTL_ALL_MODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO1CTL         CPREGBYP
 *  @access     CLOCK->RCO1CTL.bit.CPREGBYP
 *  @brief      Bypass internal 1.2V regulator
 */
#define RCO1CTL_ALL_CPREGBYP_Pos (2)
#define RCO1CTL_ALL_CPREGBYP_Msk (0x1UL << RCO1CTL_ALL_CPREGBYP_Pos)

typedef enum
{
    RCO1CTL_BIT_CPREGBYP_DISABLE     = 0,  /*!< Connect 1.2V RCO1 gates to internal 1.2V regulator   */
    RCO1CTL_BIT_CPREGBYP_ENABLE      = 1,  /*!< Connect 1.2V RCO1 gates to digital 1.2V power rail   */
} RCO1CTL_BIT_CPREGBYP;

#define RCO1CTL_ALL_CPREGBYP_DISABLE     ((0x0UL) << RCO1CTL_ALL_CPREGBYP_Pos)
#define RCO1CTL_ALL_CPREGBYP_ENABLE      ((0x1UL) << RCO1CTL_ALL_CPREGBYP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO1CTL         TEMPTRIM
 *  @access     CLOCK->RCO1CTL.bit.TEMPTRIM
 *  @brief      RCO1 frequency temperature trimming
 *              Frequency increases with temperature faster for larger trim code
 */
#define RCO1CTL_ALL_TEMPTRIM_Pos (3)
#define RCO1CTL_ALL_TEMPTRIM_Msk (0xFUL << RCO1CTL_ALL_TEMPTRIM_Pos)

#define RCO1CTL_BIT_TEMPTRIM

#define RCO1CTL_ALL_TEMPTRIM_(x) ((x) << RCO1CTL_ALL_TEMPTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           RCO1CTL         FREQTRIM
 *  @access     CLOCK->RCO1CTL.bit.FREQTRIM
 *  @brief      RCO1 frequency trimming
 *              Frequency increases for larger code
 */
#define RCO1CTL_ALL_FREQTRIM_Pos (7)
#define RCO1CTL_ALL_FREQTRIM_Msk (0x1FFUL << RCO1CTL_ALL_FREQTRIM_Pos)

#define RCO1CTL_BIT_FREQTRIM

#define RCO1CTL_ALL_FREQTRIM_(x) ((x) << RCO1CTL_ALL_FREQTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           XOCTL           EN
 *  @access     CLOCK->XOCTL.bit.EN
 *  @brief      Crystal oscillator clock enable
 */
#define XOCTL_ALL_EN_Pos (0)
#define XOCTL_ALL_EN_Msk (0x1UL << XOCTL_ALL_EN_Pos)

typedef enum
{
    XOCTL_BIT_EN_DISABLE     = 0,  /*!< Disable   */
    XOCTL_BIT_EN_ENABLE      = 1,  /*!< Enable    */
} XOCTL_BIT_EN;

#define XOCTL_ALL_EN_DISABLE     ((0x0UL) << XOCTL_ALL_EN_Pos)
#define XOCTL_ALL_EN_ENABLE      ((0x1UL) << XOCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           XOCTL           FASTEN
 *  @access     CLOCK->XOCTL.bit.FASTEN
 *  @brief      Enable noise injection for fast startup
 */
#define XOCTL_ALL_FASTEN_Pos (2)
#define XOCTL_ALL_FASTEN_Msk (0x1UL << XOCTL_ALL_FASTEN_Pos)

typedef enum
{
    XOCTL_BIT_FASTEN_DISABLE     = 0,  /*!< Disable   */
    XOCTL_BIT_FASTEN_ENABLE      = 1,  /*!< Enable    */
} XOCTL_BIT_FASTEN;

#define XOCTL_ALL_FASTEN_DISABLE     ((0x0UL) << XOCTL_ALL_FASTEN_Pos)
#define XOCTL_ALL_FASTEN_ENABLE      ((0x1UL) << XOCTL_ALL_FASTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           XOCTL           PRECNT
 *  @access     CLOCK->XOCTL.bit.PRECNT
 *  @brief      Pre-counted target value before XO clock is regarded as ready: Target = 1024 * PRECNT
 */
#define XOCTL_ALL_PRECNT_Pos (8)
#define XOCTL_ALL_PRECNT_Msk (0xFFUL << XOCTL_ALL_PRECNT_Pos)

#define XOCTL_BIT_PRECNT

#define XOCTL_ALL_PRECNT_(x) ((x) << XOCTL_ALL_PRECNT_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         EN
 *  @access     CLOCK->PLLCTL0.bit.EN
 *  @brief      PLL enable
 */
#define PLLCTL0_ALL_EN_Pos (0)
#define PLLCTL0_ALL_EN_Msk (0x1UL << PLLCTL0_ALL_EN_Pos)

typedef enum
{
    PLLCTL0_BIT_EN_DISABLE     = 0,  /*!< Disable   */
    PLLCTL0_BIT_EN_ENABLE      = 1,  /*!< Enable    */
} PLLCTL0_BIT_EN;

#define PLLCTL0_ALL_EN_DISABLE     ((0x0UL) << PLLCTL0_ALL_EN_Pos)
#define PLLCTL0_ALL_EN_ENABLE      ((0x1UL) << PLLCTL0_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         ACLKEN
 *  @access     CLOCK->PLLCTL0.bit.ACLKEN
 *  @brief      PLL analog clock output enable
 */
#define PLLCTL0_ALL_ACLKEN_Pos (1)
#define PLLCTL0_ALL_ACLKEN_Msk (0x1UL << PLLCTL0_ALL_ACLKEN_Pos)

typedef enum
{
    PLLCTL0_BIT_ACLKEN_DISABLE     = 0,  /*!< Disable   */
    PLLCTL0_BIT_ACLKEN_ENABLE      = 1,  /*!< Enable    */
} PLLCTL0_BIT_ACLKEN;

#define PLLCTL0_ALL_ACLKEN_DISABLE     ((0x0UL) << PLLCTL0_ALL_ACLKEN_Pos)
#define PLLCTL0_ALL_ACLKEN_ENABLE      ((0x1UL) << PLLCTL0_ALL_ACLKEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         DCLKEN
 *  @access     CLOCK->PLLCTL0.bit.DCLKEN
 *  @brief      PLL digital clock output enable
 */
#define PLLCTL0_ALL_DCLKEN_Pos (2)
#define PLLCTL0_ALL_DCLKEN_Msk (0x1UL << PLLCTL0_ALL_DCLKEN_Pos)

typedef enum
{
    PLLCTL0_BIT_DCLKEN_DISABLE     = 0,  /*!< Disable   */
    PLLCTL0_BIT_DCLKEN_ENABLE      = 1,  /*!< Enable    */
} PLLCTL0_BIT_DCLKEN;

#define PLLCTL0_ALL_DCLKEN_DISABLE     ((0x0UL) << PLLCTL0_ALL_DCLKEN_Pos)
#define PLLCTL0_ALL_DCLKEN_ENABLE      ((0x1UL) << PLLCTL0_ALL_DCLKEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         PWMCLKEN
 *  @access     CLOCK->PLLCTL0.bit.PWMCLKEN
 *  @brief      PLL PWM clock output enable
 */
#define PLLCTL0_ALL_PWMCLKEN_Pos (3)
#define PLLCTL0_ALL_PWMCLKEN_Msk (0x1UL << PLLCTL0_ALL_PWMCLKEN_Pos)

typedef enum
{
    PLLCTL0_BIT_PWMCLKEN_DISABLE     = 0,  /*!< Disable   */
    PLLCTL0_BIT_PWMCLKEN_ENABLE      = 1,  /*!< Enable    */
} PLLCTL0_BIT_PWMCLKEN;

#define PLLCTL0_ALL_PWMCLKEN_DISABLE     ((0x0UL) << PLLCTL0_ALL_PWMCLKEN_Pos)
#define PLLCTL0_ALL_PWMCLKEN_ENABLE      ((0x1UL) << PLLCTL0_ALL_PWMCLKEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         CSDEN
 *  @access     CLOCK->PLLCTL0.bit.CSDEN
 *  @brief      PLL cycle slip detection enable
 */
#define PLLCTL0_ALL_CSDEN_Pos (4)
#define PLLCTL0_ALL_CSDEN_Msk (0x1UL << PLLCTL0_ALL_CSDEN_Pos)

typedef enum
{
    PLLCTL0_BIT_CSDEN_DISABLE     = 0,  /*!< Disable   */
    PLLCTL0_BIT_CSDEN_ENABLE      = 1,  /*!< Enable    */
} PLLCTL0_BIT_CSDEN;

#define PLLCTL0_ALL_CSDEN_DISABLE     ((0x0UL) << PLLCTL0_ALL_CSDEN_Pos)
#define PLLCTL0_ALL_CSDEN_ENABLE      ((0x1UL) << PLLCTL0_ALL_CSDEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         CSDRST
 *  @access     CLOCK->PLLCTL0.bit.CSDRST
 *  @brief      Reset PLL cycle slip detection output
 */
#define PLLCTL0_ALL_CSDRST_Pos (5)
#define PLLCTL0_ALL_CSDRST_Msk (0x1UL << PLLCTL0_ALL_CSDRST_Pos)

typedef enum
{
    PLLCTL0_BIT_CSDRST_RELEASE     = 0,  /*!< Release the reset   */
    PLLCTL0_BIT_CSDRST_RESET       = 1,  /*!< Reset               */
} PLLCTL0_BIT_CSDRST;

#define PLLCTL0_ALL_CSDRST_RELEASE     ((0x0UL) << PLLCTL0_ALL_CSDRST_Pos)
#define PLLCTL0_ALL_CSDRST_RESET       ((0x1UL) << PLLCTL0_ALL_CSDRST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         DSMLSB
 *  @access     CLOCK->PLLCTL0.bit.DSMLSB
 *  @brief      LSB dithering method for delta-sigma divider
 */
#define PLLCTL0_ALL_DSMLSB_Pos (6)
#define PLLCTL0_ALL_DSMLSB_Msk (0x1UL << PLLCTL0_ALL_DSMLSB_Pos)

typedef enum
{
    PLLCTL0_BIT_DSMLSB_KEEP_1                = 0,  /*!< Keep as 1                                      */
    PLLCTL0_BIT_DSMLSB_USE_RANDOM_BINARY     = 1,  /*!< Use 7-th order pseudo-random binary sequence   */
} PLLCTL0_BIT_DSMLSB;

#define PLLCTL0_ALL_DSMLSB_KEEP_1                ((0x0UL) << PLLCTL0_ALL_DSMLSB_Pos)
#define PLLCTL0_ALL_DSMLSB_USE_RANDOM_BINARY     ((0x1UL) << PLLCTL0_ALL_DSMLSB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         FCALEN
 *  @access     CLOCK->PLLCTL0.bit.FCALEN
 *  @brief      PLL frequency calibration enable
 */
#define PLLCTL0_ALL_FCALEN_Pos (7)
#define PLLCTL0_ALL_FCALEN_Msk (0x1UL << PLLCTL0_ALL_FCALEN_Pos)

typedef enum
{
    PLLCTL0_BIT_FCALEN_DISABLE     = 0,  /*!< Disable   */
    PLLCTL0_BIT_FCALEN_ENABLE      = 1,  /*!< Enable    */
} PLLCTL0_BIT_FCALEN;

#define PLLCTL0_ALL_FCALEN_DISABLE     ((0x0UL) << PLLCTL0_ALL_FCALEN_Pos)
#define PLLCTL0_ALL_FCALEN_ENABLE      ((0x1UL) << PLLCTL0_ALL_FCALEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         FCALWIN
 *  @access     CLOCK->PLLCTL0.bit.FCALWIN
 *  @brief      PLL frequency calibration time window
 *              For each calibration cycle, keep it as 1 until FCALRDY=1 and release it as 0
 */
#define PLLCTL0_ALL_FCALWIN_Pos (8)
#define PLLCTL0_ALL_FCALWIN_Msk (0x1UL << PLLCTL0_ALL_FCALWIN_Pos)

typedef enum
{
    PLLCTL0_BIT_FCALWIN_DISABLE     = 0,  /*!< Window is disabled   */
    PLLCTL0_BIT_FCALWIN_ENABLE      = 1,  /*!< Window is enabled    */
} PLLCTL0_BIT_FCALWIN;

#define PLLCTL0_ALL_FCALWIN_DISABLE     ((0x0UL) << PLLCTL0_ALL_FCALWIN_Pos)
#define PLLCTL0_ALL_FCALWIN_ENABLE      ((0x1UL) << PLLCTL0_ALL_FCALWIN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         FREQTRIM
 *  @access     CLOCK->PLLCTL0.bit.FREQTRIM
 *  @brief      PLL frequency trimming
 *              VCO free-run frequency increases with larger code
 */
#define PLLCTL0_ALL_FREQTRIM_Pos (9)
#define PLLCTL0_ALL_FREQTRIM_Msk (0x7UL << PLLCTL0_ALL_FREQTRIM_Pos)

#define PLLCTL0_BIT_FREQTRIM

#define PLLCTL0_ALL_FREQTRIM_(x) ((x) << PLLCTL0_ALL_FREQTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         RCLKSEL
 *  @access     CLOCK->PLLCTL0.bit.RCLKSEL
 *  @brief      PLL reference clock select
 */
#define PLLCTL0_ALL_RCLKSEL_Pos (12)
#define PLLCTL0_ALL_RCLKSEL_Msk (0x1UL << PLLCTL0_ALL_RCLKSEL_Pos)

typedef enum
{
    PLLCTL0_BIT_RCLKSEL_RCO0     = 0,  /*!< CLK_RCO0 (RC oscillator 0)    */
    PLLCTL0_BIT_RCLKSEL_XO       = 1,  /*!< CLK_XO (Crystal oscillator)   */
} PLLCTL0_BIT_RCLKSEL;

#define PLLCTL0_ALL_RCLKSEL_RCO0     ((0x0UL) << PLLCTL0_ALL_RCLKSEL_Pos)
#define PLLCTL0_ALL_RCLKSEL_XO       ((0x1UL) << PLLCTL0_ALL_RCLKSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         ICP
 *  @access     CLOCK->PLLCTL0.bit.ICP
 *  @brief      PLL charge pump setting
 *              Must be set to NFB/(12-FREQTRIM), where NFB is the PLL feedback factor
 */
#define PLLCTL0_ALL_ICP_Pos (13)
#define PLLCTL0_ALL_ICP_Msk (0x1FUL << PLLCTL0_ALL_ICP_Pos)

#define PLLCTL0_BIT_ICP

#define PLLCTL0_ALL_ICP_(x) ((x) << PLLCTL0_ALL_ICP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         LOOPCLOSE
 *  @access     CLOCK->PLLCTL0.bit.LOOPCLOSE
 *  @brief      PLL mode
 */
#define PLLCTL0_ALL_LOOPCLOSE_Pos (18)
#define PLLCTL0_ALL_LOOPCLOSE_Msk (0x1UL << PLLCTL0_ALL_LOOPCLOSE_Pos)

typedef enum
{
    PLLCTL0_BIT_LOOPCLOSE_OPEN_LOOP      = 0,  /*!< Open loop    */
    PLLCTL0_BIT_LOOPCLOSE_CLOSE_LOOP     = 1,  /*!< Close loop   */
} PLLCTL0_BIT_LOOPCLOSE;

#define PLLCTL0_ALL_LOOPCLOSE_OPEN_LOOP      ((0x0UL) << PLLCTL0_ALL_LOOPCLOSE_Pos)
#define PLLCTL0_ALL_LOOPCLOSE_CLOSE_LOOP     ((0x1UL) << PLLCTL0_ALL_LOOPCLOSE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         NIN
 *  @access     CLOCK->PLLCTL0.bit.NIN
 *  @brief      PLL input clock dividing ratio (Fin/Fpfd)
 */
#define PLLCTL0_ALL_NIN_Pos (25)
#define PLLCTL0_ALL_NIN_Msk (0x7UL << PLLCTL0_ALL_NIN_Pos)

typedef enum
{
    PLLCTL0_BIT_NIN_1     = 1,  /*!< Set to 1 if Fin(MHz) is in [4, 8]:   Fin/Fpfd=1     */
    PLLCTL0_BIT_NIN_2     = 2,  /*!< Set to 2 if Fin(MHz) is in (8, 16]:   Fin/Fpfd=2    */
    PLLCTL0_BIT_NIN_3     = 3,  /*!< Set to 3 if Fin(MHz) is in (16, 24]:   Fin/Fpfd=3   */
    PLLCTL0_BIT_NIN_4     = 4,  /*!< Set to 4 if Fin(MHz) is in (24, 32]:   Fin/Fpfd=4   */
    PLLCTL0_BIT_NIN_5     = 5,  /*!< Set to 5 if Fin(MHz) is in (32, 40]:   Fin/Fpfd=5   */
    PLLCTL0_BIT_NIN_6     = 6,  /*!< Set to 6 if Fin(MHz) is in (40, 48]:   Fin/Fpfd=6   */
    PLLCTL0_BIT_NIN_7     = 7,  /*!< Set to 1 if Fin(MHz) is in (48, 56]:   Fin/Fpfd=7   */
} PLLCTL0_BIT_NIN;

#define PLLCTL0_ALL_NIN_1     ((0x1UL) << PLLCTL0_ALL_NIN_Pos)
#define PLLCTL0_ALL_NIN_2     ((0x2UL) << PLLCTL0_ALL_NIN_Pos)
#define PLLCTL0_ALL_NIN_3     ((0x3UL) << PLLCTL0_ALL_NIN_Pos)
#define PLLCTL0_ALL_NIN_4     ((0x4UL) << PLLCTL0_ALL_NIN_Pos)
#define PLLCTL0_ALL_NIN_5     ((0x5UL) << PLLCTL0_ALL_NIN_Pos)
#define PLLCTL0_ALL_NIN_6     ((0x6UL) << PLLCTL0_ALL_NIN_Pos)
#define PLLCTL0_ALL_NIN_7     ((0x7UL) << PLLCTL0_ALL_NIN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL0         CPREGBYP
 *  @access     CLOCK->PLLCTL0.bit.CPREGBYP
 *  @brief      Bypass internal 1.2V regulator for PLL
 */
#define PLLCTL0_ALL_CPREGBYP_Pos (28)
#define PLLCTL0_ALL_CPREGBYP_Msk (0x1UL << PLLCTL0_ALL_CPREGBYP_Pos)

typedef enum
{
    PLLCTL0_BIT_CPREGBYP_DISABLE     = 0,  /*!< Connect 1.2V RCO1 gates to internal 1.2V regulator   */
    PLLCTL0_BIT_CPREGBYP_ENABLE      = 1,  /*!< Connect 1.2V RCO1 gates to digital 1.2V power rail   */
} PLLCTL0_BIT_CPREGBYP;

#define PLLCTL0_ALL_CPREGBYP_DISABLE     ((0x0UL) << PLLCTL0_ALL_CPREGBYP_Pos)
#define PLLCTL0_ALL_CPREGBYP_ENABLE      ((0x1UL) << PLLCTL0_ALL_CPREGBYP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL1         NFBFRAC
 *  @access     CLOCK->PLLCTL1.bit.NFBFRAC
 *  @brief      Fractional part of feedback dividing ratio
 *              NFB (Feedback dividing ratio) = NFBINTG + NFBFRAC/65536
 */
#define PLLCTL1_ALL_NFBFRAC_Pos (0)
#define PLLCTL1_ALL_NFBFRAC_Msk (0xFFFFUL << PLLCTL1_ALL_NFBFRAC_Pos)

#define PLLCTL1_BIT_NFBFRAC

#define PLLCTL1_ALL_NFBFRAC_(x) ((x) << PLLCTL1_ALL_NFBFRAC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL1         NFBINTG
 *  @access     CLOCK->PLLCTL1.bit.NFBINTG
 *  @brief      Integral part of feedback dividing ratio
 *              NFB (Feedback dividing ratio) = NFBINTG + NFBFRAC/65536
 */
#define PLLCTL1_ALL_NFBINTG_Pos (16)
#define PLLCTL1_ALL_NFBINTG_Msk (0xFFUL << PLLCTL1_ALL_NFBINTG_Pos)

#define PLLCTL1_BIT_NFBINTG

#define PLLCTL1_ALL_NFBINTG_(x) ((x) << PLLCTL1_ALL_NFBINTG_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL1         NDIG
 *  @access     CLOCK->PLLCTL1.bit.NDIG
 *  @brief      VCO to digital clock dividing ratio (FVCO/FDIG)
 */
#define PLLCTL1_ALL_NDIG_Pos (24)
#define PLLCTL1_ALL_NDIG_Msk (0x3UL << PLLCTL1_ALL_NDIG_Pos)

typedef enum
{
    PLLCTL1_BIT_NDIG_1     = 0,  /*!< Divide by 1   */
    PLLCTL1_BIT_NDIG_2     = 1,  /*!< Divide by 2   */
    PLLCTL1_BIT_NDIG_3     = 2,  /*!< Divide by 3   */
    PLLCTL1_BIT_NDIG_4     = 3,  /*!< Divide by 4   */
} PLLCTL1_BIT_NDIG;

#define PLLCTL1_ALL_NDIG_1     ((0x0UL) << PLLCTL1_ALL_NDIG_Pos)
#define PLLCTL1_ALL_NDIG_2     ((0x1UL) << PLLCTL1_ALL_NDIG_Pos)
#define PLLCTL1_ALL_NDIG_3     ((0x2UL) << PLLCTL1_ALL_NDIG_Pos)
#define PLLCTL1_ALL_NDIG_4     ((0x3UL) << PLLCTL1_ALL_NDIG_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL1         NPWM
 *  @access     CLOCK->PLLCTL1.bit.NPWM
 *  @brief      VCO to PWM clock dividing ratio (FVCO/FPWM)
 */
#define PLLCTL1_ALL_NPWM_Pos (26)
#define PLLCTL1_ALL_NPWM_Msk (0x3UL << PLLCTL1_ALL_NPWM_Pos)

typedef enum
{
    PLLCTL1_BIT_NPWM_1     = 0,  /*!< Divide by 1   */
    PLLCTL1_BIT_NPWM_2     = 1,  /*!< Divide by 2   */
    PLLCTL1_BIT_NPWM_3     = 2,  /*!< Divide by 3   */
    PLLCTL1_BIT_NPWM_4     = 3,  /*!< Divide by 4   */
} PLLCTL1_BIT_NPWM;

#define PLLCTL1_ALL_NPWM_1     ((0x0UL) << PLLCTL1_ALL_NPWM_Pos)
#define PLLCTL1_ALL_NPWM_2     ((0x1UL) << PLLCTL1_ALL_NPWM_Pos)
#define PLLCTL1_ALL_NPWM_3     ((0x2UL) << PLLCTL1_ALL_NPWM_Pos)
#define PLLCTL1_ALL_NPWM_4     ((0x3UL) << PLLCTL1_ALL_NPWM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           PLLCTL1         ND2A
 *  @access     CLOCK->PLLCTL1.bit.ND2A
 *  @brief      Digital clock to analog clock dividing ratio (FDIG/FANA)
 */
#define PLLCTL1_ALL_ND2A_Pos (28)
#define PLLCTL1_ALL_ND2A_Msk (0x7UL << PLLCTL1_ALL_ND2A_Pos)

typedef enum
{
    PLLCTL1_BIT_ND2A_4       = 0,  /*!< Divide by 4     */
    PLLCTL1_BIT_ND2A_8       = 1,  /*!< Divide by 8     */
    PLLCTL1_BIT_ND2A_16      = 2,  /*!< Divide by 16    */
    PLLCTL1_BIT_ND2A_32      = 3,  /*!< Divide by 32    */
    PLLCTL1_BIT_ND2A_64      = 4,  /*!< Divide by 64    */
    PLLCTL1_BIT_ND2A_128     = 5,  /*!< Divide by 128   */
    PLLCTL1_BIT_ND2A_256     = 6,  /*!< Divide by 256   */
    PLLCTL1_BIT_ND2A_512     = 7,  /*!< Divide by 512   */
} PLLCTL1_BIT_ND2A;

#define PLLCTL1_ALL_ND2A_4       ((0x0UL) << PLLCTL1_ALL_ND2A_Pos)
#define PLLCTL1_ALL_ND2A_8       ((0x1UL) << PLLCTL1_ALL_ND2A_Pos)
#define PLLCTL1_ALL_ND2A_16      ((0x2UL) << PLLCTL1_ALL_ND2A_Pos)
#define PLLCTL1_ALL_ND2A_32      ((0x3UL) << PLLCTL1_ALL_ND2A_Pos)
#define PLLCTL1_ALL_ND2A_64      ((0x4UL) << PLLCTL1_ALL_ND2A_Pos)
#define PLLCTL1_ALL_ND2A_128     ((0x5UL) << PLLCTL1_ALL_ND2A_Pos)
#define PLLCTL1_ALL_ND2A_256     ((0x6UL) << PLLCTL1_ALL_ND2A_Pos)
#define PLLCTL1_ALL_ND2A_512     ((0x7UL) << PLLCTL1_ALL_ND2A_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           WDT0CLKCTL      DIV
 *  @access     CLOCK->WDT0CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define WDT0CLKCTL_ALL_DIV_Pos (0)
#define WDT0CLKCTL_ALL_DIV_Msk (0x3FUL << WDT0CLKCTL_ALL_DIV_Pos)

#define WDT0CLKCTL_BIT_DIV

#define WDT0CLKCTL_ALL_DIV_(x) ((x) << WDT0CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           WDT0CLKCTL      DBGRUN
 *  @access     CLOCK->WDT0CLKCTL.bit.DBGRUN
 *  @brief      WDT0 clock keeps running when CPU is halted
 *              Recommend setting this bit to 0 only when in debug and setting this bit to 1 in normal operation.
 *              
 *              Note: Debug operation and CPU fault exceptions both can cause CPU halted.
 */
#define WDT0CLKCTL_ALL_DBGRUN_Pos (6)
#define WDT0CLKCTL_ALL_DBGRUN_Msk (0x1UL << WDT0CLKCTL_ALL_DBGRUN_Pos)

typedef enum
{
    WDT0CLKCTL_BIT_DBGRUN_DISABLE     = 0,  /*!< WDT0 clock does not run when CPU is halted   */
    WDT0CLKCTL_BIT_DBGRUN_ENABLE      = 1,  /*!< WDT0 clock runs even when CPU is halted      */
} WDT0CLKCTL_BIT_DBGRUN;

#define WDT0CLKCTL_ALL_DBGRUN_DISABLE     ((0x0UL) << WDT0CLKCTL_ALL_DBGRUN_Pos)
#define WDT0CLKCTL_ALL_DBGRUN_ENABLE      ((0x1UL) << WDT0CLKCTL_ALL_DBGRUN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           WDT0CLKCTL      EN
 *  @access     CLOCK->WDT0CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define WDT0CLKCTL_ALL_EN_Pos (7)
#define WDT0CLKCTL_ALL_EN_Msk (0x1UL << WDT0CLKCTL_ALL_EN_Pos)

typedef enum
{
    WDT0CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    WDT0CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} WDT0CLKCTL_BIT_EN;

#define WDT0CLKCTL_ALL_EN_DISABLE     ((0x0UL) << WDT0CLKCTL_ALL_EN_Pos)
#define WDT0CLKCTL_ALL_EN_ENABLE      ((0x1UL) << WDT0CLKCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           WDT1CLKCTL      DIV
 *  @access     CLOCK->WDT1CLKCTL.bit.DIV
 *  @brief      Clock dividing ratio
 */
#define WDT1CLKCTL_ALL_DIV_Pos (0)
#define WDT1CLKCTL_ALL_DIV_Msk (0x3FUL << WDT1CLKCTL_ALL_DIV_Pos)

#define WDT1CLKCTL_BIT_DIV

#define WDT1CLKCTL_ALL_DIV_(x) ((x) << WDT1CLKCTL_ALL_DIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           WDT1CLKCTL      DBGRUN
 *  @access     CLOCK->WDT1CLKCTL.bit.DBGRUN
 *  @brief      WDT1 clock keeps running when CPU is halted
 *              Recommend setting this bit to 0 only when in debug and setting this bit to 1 in normal operation.
 *              
 *              Note: Debug operation and CPU fault exceptions both can cause CPU halted.
 */
#define WDT1CLKCTL_ALL_DBGRUN_Pos (6)
#define WDT1CLKCTL_ALL_DBGRUN_Msk (0x1UL << WDT1CLKCTL_ALL_DBGRUN_Pos)

typedef enum
{
    WDT1CLKCTL_BIT_DBGRUN_DISABLE     = 0,  /*!< WDT1 clock does not run when CPU is halted   */
    WDT1CLKCTL_BIT_DBGRUN_ENABLE      = 1,  /*!< WDT1 clock runs even when CPU is halted      */
} WDT1CLKCTL_BIT_DBGRUN;

#define WDT1CLKCTL_ALL_DBGRUN_DISABLE     ((0x0UL) << WDT1CLKCTL_ALL_DBGRUN_Pos)
#define WDT1CLKCTL_ALL_DBGRUN_ENABLE      ((0x1UL) << WDT1CLKCTL_ALL_DBGRUN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CLOCK           WDT1CLKCTL      EN
 *  @access     CLOCK->WDT1CLKCTL.bit.EN
 *  @brief      Clock output enable
 */
#define WDT1CLKCTL_ALL_EN_Pos (7)
#define WDT1CLKCTL_ALL_EN_Msk (0x1UL << WDT1CLKCTL_ALL_EN_Pos)

typedef enum
{
    WDT1CLKCTL_BIT_EN_DISABLE     = 0,  /*!< Disable clock output   */
    WDT1CLKCTL_BIT_EN_ENABLE      = 1,  /*!< Enable clock output    */
} WDT1CLKCTL_BIT_EN;

#define WDT1CLKCTL_ALL_EN_DISABLE     ((0x0UL) << WDT1CLKCTL_ALL_EN_Pos)
#define WDT1CLKCTL_ALL_EN_ENABLE      ((0x1UL) << WDT1CLKCTL_ALL_EN_Pos)





/********************************************************************************
*
* Module Name     GLOBAL
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          MEMPCE          ROMPCE
 *  @access     GLOBAL->MEMPCE.bit.ROMPCE
 *  @brief      ROM parity check enable
 */
#define MEMPCE_ALL_ROMPCE_Pos (0)
#define MEMPCE_ALL_ROMPCE_Msk (0x1UL << MEMPCE_ALL_ROMPCE_Pos)

typedef enum
{
    MEMPCE_BIT_ROMPCE_DISABLE     = 0,  /*!< Disable parity check for ROM                */
    MEMPCE_BIT_ROMPCE_ENABLE      = 1,  /*!< Enable parity check for ROM when GLBPCE=1   */
} MEMPCE_BIT_ROMPCE;

#define MEMPCE_ALL_ROMPCE_DISABLE     ((0x0UL) << MEMPCE_ALL_ROMPCE_Pos)
#define MEMPCE_ALL_ROMPCE_ENABLE      ((0x1UL) << MEMPCE_ALL_ROMPCE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          MEMPCE          RAM32KPCE
 *  @access     GLOBAL->MEMPCE.bit.RAM32KPCE
 *  @brief      32K RAM parity check enable
 */
#define MEMPCE_ALL_RAM32KPCE_Pos (1)
#define MEMPCE_ALL_RAM32KPCE_Msk (0x1UL << MEMPCE_ALL_RAM32KPCE_Pos)

typedef enum
{
    MEMPCE_BIT_RAM32KPCE_DISABLE     = 0,  /*!< Disable parity check for 32K RAM                */
    MEMPCE_BIT_RAM32KPCE_ENABLE      = 1,  /*!< Enable parity check for 32K RAM when GLBPCE=1   */
} MEMPCE_BIT_RAM32KPCE;

#define MEMPCE_ALL_RAM32KPCE_DISABLE     ((0x0UL) << MEMPCE_ALL_RAM32KPCE_Pos)
#define MEMPCE_ALL_RAM32KPCE_ENABLE      ((0x1UL) << MEMPCE_ALL_RAM32KPCE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          MEMPCE          RAM16KPCE
 *  @access     GLOBAL->MEMPCE.bit.RAM16KPCE
 *  @brief      16K RAM parity check enable
 */
#define MEMPCE_ALL_RAM16KPCE_Pos (2)
#define MEMPCE_ALL_RAM16KPCE_Msk (0x1UL << MEMPCE_ALL_RAM16KPCE_Pos)

typedef enum
{
    MEMPCE_BIT_RAM16KPCE_DISABLE     = 0,  /*!< Disable parity check for 16K RAM                */
    MEMPCE_BIT_RAM16KPCE_ENABLE      = 1,  /*!< Enable parity check for 16K RAM when GLBPCE=1   */
} MEMPCE_BIT_RAM16KPCE;

#define MEMPCE_ALL_RAM16KPCE_DISABLE     ((0x0UL) << MEMPCE_ALL_RAM16KPCE_Pos)
#define MEMPCE_ALL_RAM16KPCE_ENABLE      ((0x1UL) << MEMPCE_ALL_RAM16KPCE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          MEMPCE          GLBPCE
 *  @access     GLOBAL->MEMPCE.bit.GLBPCE
 *  @brief      Global parity check enable
 */
#define MEMPCE_ALL_GLBPCE_Pos (3)
#define MEMPCE_ALL_GLBPCE_Msk (0x1UL << MEMPCE_ALL_GLBPCE_Pos)

typedef enum
{
    MEMPCE_BIT_GLBPCE_DISABLE     = 0,  /*!< Disable parity check for all memories                  */
    MEMPCE_BIT_GLBPCE_ENABLE      = 1,  /*!< Prerequisite to enable parity check for all memories   */
} MEMPCE_BIT_GLBPCE;

#define MEMPCE_ALL_GLBPCE_DISABLE     ((0x0UL) << MEMPCE_ALL_GLBPCE_Pos)
#define MEMPCE_ALL_GLBPCE_ENABLE      ((0x1UL) << MEMPCE_ALL_GLBPCE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO0
 *  @access     GLOBAL->GPIOIE0.bit.GPIO0
 *  @brief      GPIO0 interrupt enable
 */
#define GPIOIE0_ALL_GPIO0_Pos (0)
#define GPIOIE0_ALL_GPIO0_Msk (0x1UL << GPIOIE0_ALL_GPIO0_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO0_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO0_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO0;

#define GPIOIE0_ALL_GPIO0_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO0_Pos)
#define GPIOIE0_ALL_GPIO0_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO1
 *  @access     GLOBAL->GPIOIE0.bit.GPIO1
 *  @brief      GPIO1 interrupt enable
 */
#define GPIOIE0_ALL_GPIO1_Pos (1)
#define GPIOIE0_ALL_GPIO1_Msk (0x1UL << GPIOIE0_ALL_GPIO1_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO1_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO1_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO1;

#define GPIOIE0_ALL_GPIO1_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO1_Pos)
#define GPIOIE0_ALL_GPIO1_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO2
 *  @access     GLOBAL->GPIOIE0.bit.GPIO2
 *  @brief      GPIO2 interrupt enable
 */
#define GPIOIE0_ALL_GPIO2_Pos (2)
#define GPIOIE0_ALL_GPIO2_Msk (0x1UL << GPIOIE0_ALL_GPIO2_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO2_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO2_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO2;

#define GPIOIE0_ALL_GPIO2_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO2_Pos)
#define GPIOIE0_ALL_GPIO2_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO3
 *  @access     GLOBAL->GPIOIE0.bit.GPIO3
 *  @brief      GPIO3 interrupt enable
 */
#define GPIOIE0_ALL_GPIO3_Pos (3)
#define GPIOIE0_ALL_GPIO3_Msk (0x1UL << GPIOIE0_ALL_GPIO3_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO3_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO3_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO3;

#define GPIOIE0_ALL_GPIO3_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO3_Pos)
#define GPIOIE0_ALL_GPIO3_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO4
 *  @access     GLOBAL->GPIOIE0.bit.GPIO4
 *  @brief      GPIO4 interrupt enable
 */
#define GPIOIE0_ALL_GPIO4_Pos (4)
#define GPIOIE0_ALL_GPIO4_Msk (0x1UL << GPIOIE0_ALL_GPIO4_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO4_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO4_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO4;

#define GPIOIE0_ALL_GPIO4_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO4_Pos)
#define GPIOIE0_ALL_GPIO4_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO5
 *  @access     GLOBAL->GPIOIE0.bit.GPIO5
 *  @brief      GPIO5 interrupt enable
 */
#define GPIOIE0_ALL_GPIO5_Pos (5)
#define GPIOIE0_ALL_GPIO5_Msk (0x1UL << GPIOIE0_ALL_GPIO5_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO5_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO5_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO5;

#define GPIOIE0_ALL_GPIO5_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO5_Pos)
#define GPIOIE0_ALL_GPIO5_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO6
 *  @access     GLOBAL->GPIOIE0.bit.GPIO6
 *  @brief      GPIO6 interrupt enable
 */
#define GPIOIE0_ALL_GPIO6_Pos (6)
#define GPIOIE0_ALL_GPIO6_Msk (0x1UL << GPIOIE0_ALL_GPIO6_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO6_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO6_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO6;

#define GPIOIE0_ALL_GPIO6_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO6_Pos)
#define GPIOIE0_ALL_GPIO6_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO7
 *  @access     GLOBAL->GPIOIE0.bit.GPIO7
 *  @brief      GPIO7 interrupt enable
 */
#define GPIOIE0_ALL_GPIO7_Pos (7)
#define GPIOIE0_ALL_GPIO7_Msk (0x1UL << GPIOIE0_ALL_GPIO7_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO7_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO7_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO7;

#define GPIOIE0_ALL_GPIO7_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO7_Pos)
#define GPIOIE0_ALL_GPIO7_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO8
 *  @access     GLOBAL->GPIOIE0.bit.GPIO8
 *  @brief      GPIO8 interrupt enable
 */
#define GPIOIE0_ALL_GPIO8_Pos (8)
#define GPIOIE0_ALL_GPIO8_Msk (0x1UL << GPIOIE0_ALL_GPIO8_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO8_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO8_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO8;

#define GPIOIE0_ALL_GPIO8_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO8_Pos)
#define GPIOIE0_ALL_GPIO8_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO9
 *  @access     GLOBAL->GPIOIE0.bit.GPIO9
 *  @brief      GPIO9 interrupt enable
 */
#define GPIOIE0_ALL_GPIO9_Pos (9)
#define GPIOIE0_ALL_GPIO9_Msk (0x1UL << GPIOIE0_ALL_GPIO9_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO9_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO9_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO9;

#define GPIOIE0_ALL_GPIO9_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO9_Pos)
#define GPIOIE0_ALL_GPIO9_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO10
 *  @access     GLOBAL->GPIOIE0.bit.GPIO10
 *  @brief      GPIO10 interrupt enable
 */
#define GPIOIE0_ALL_GPIO10_Pos (10)
#define GPIOIE0_ALL_GPIO10_Msk (0x1UL << GPIOIE0_ALL_GPIO10_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO10_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO10_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO10;

#define GPIOIE0_ALL_GPIO10_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO10_Pos)
#define GPIOIE0_ALL_GPIO10_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO11
 *  @access     GLOBAL->GPIOIE0.bit.GPIO11
 *  @brief      GPIO11 interrupt enable
 */
#define GPIOIE0_ALL_GPIO11_Pos (11)
#define GPIOIE0_ALL_GPIO11_Msk (0x1UL << GPIOIE0_ALL_GPIO11_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO11_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO11_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO11;

#define GPIOIE0_ALL_GPIO11_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO11_Pos)
#define GPIOIE0_ALL_GPIO11_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO12
 *  @access     GLOBAL->GPIOIE0.bit.GPIO12
 *  @brief      GPIO12 interrupt enable
 */
#define GPIOIE0_ALL_GPIO12_Pos (12)
#define GPIOIE0_ALL_GPIO12_Msk (0x1UL << GPIOIE0_ALL_GPIO12_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO12_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO12_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO12;

#define GPIOIE0_ALL_GPIO12_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO12_Pos)
#define GPIOIE0_ALL_GPIO12_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO13
 *  @access     GLOBAL->GPIOIE0.bit.GPIO13
 *  @brief      GPIO13 interrupt enable
 */
#define GPIOIE0_ALL_GPIO13_Pos (13)
#define GPIOIE0_ALL_GPIO13_Msk (0x1UL << GPIOIE0_ALL_GPIO13_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO13_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO13_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO13;

#define GPIOIE0_ALL_GPIO13_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO13_Pos)
#define GPIOIE0_ALL_GPIO13_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO14
 *  @access     GLOBAL->GPIOIE0.bit.GPIO14
 *  @brief      GPIO14 interrupt enable
 */
#define GPIOIE0_ALL_GPIO14_Pos (14)
#define GPIOIE0_ALL_GPIO14_Msk (0x1UL << GPIOIE0_ALL_GPIO14_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO14_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO14_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO14;

#define GPIOIE0_ALL_GPIO14_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO14_Pos)
#define GPIOIE0_ALL_GPIO14_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO15
 *  @access     GLOBAL->GPIOIE0.bit.GPIO15
 *  @brief      GPIO15 interrupt enable
 */
#define GPIOIE0_ALL_GPIO15_Pos (15)
#define GPIOIE0_ALL_GPIO15_Msk (0x1UL << GPIOIE0_ALL_GPIO15_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO15_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO15_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO15;

#define GPIOIE0_ALL_GPIO15_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO15_Pos)
#define GPIOIE0_ALL_GPIO15_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO16
 *  @access     GLOBAL->GPIOIE0.bit.GPIO16
 *  @brief      GPIO16 interrupt enable
 */
#define GPIOIE0_ALL_GPIO16_Pos (16)
#define GPIOIE0_ALL_GPIO16_Msk (0x1UL << GPIOIE0_ALL_GPIO16_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO16_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO16_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO16;

#define GPIOIE0_ALL_GPIO16_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO16_Pos)
#define GPIOIE0_ALL_GPIO16_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO16_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE0         GPIO17
 *  @access     GLOBAL->GPIOIE0.bit.GPIO17
 *  @brief      GPIO17 interrupt enable
 */
#define GPIOIE0_ALL_GPIO17_Pos (17)
#define GPIOIE0_ALL_GPIO17_Msk (0x1UL << GPIOIE0_ALL_GPIO17_Pos)

typedef enum
{
    GPIOIE0_BIT_GPIO17_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE0_BIT_GPIO17_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE0_BIT_GPIO17;

#define GPIOIE0_ALL_GPIO17_DISABLE     ((0x0UL) << GPIOIE0_ALL_GPIO17_Pos)
#define GPIOIE0_ALL_GPIO17_ENABLE      ((0x1UL) << GPIOIE0_ALL_GPIO17_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO18
 *  @access     GLOBAL->GPIOIE1.bit.GPIO18
 *  @brief      GPIO18 interrupt enable
 */
#define GPIOIE1_ALL_GPIO18_Pos (0)
#define GPIOIE1_ALL_GPIO18_Msk (0x1UL << GPIOIE1_ALL_GPIO18_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO18_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO18_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO18;

#define GPIOIE1_ALL_GPIO18_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO18_Pos)
#define GPIOIE1_ALL_GPIO18_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO18_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO19
 *  @access     GLOBAL->GPIOIE1.bit.GPIO19
 *  @brief      GPIO19 interrupt enable
 */
#define GPIOIE1_ALL_GPIO19_Pos (1)
#define GPIOIE1_ALL_GPIO19_Msk (0x1UL << GPIOIE1_ALL_GPIO19_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO19_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO19_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO19;

#define GPIOIE1_ALL_GPIO19_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO19_Pos)
#define GPIOIE1_ALL_GPIO19_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO19_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO20
 *  @access     GLOBAL->GPIOIE1.bit.GPIO20
 *  @brief      GPIO20 interrupt enable
 */
#define GPIOIE1_ALL_GPIO20_Pos (2)
#define GPIOIE1_ALL_GPIO20_Msk (0x1UL << GPIOIE1_ALL_GPIO20_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO20_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO20_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO20;

#define GPIOIE1_ALL_GPIO20_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO20_Pos)
#define GPIOIE1_ALL_GPIO20_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO20_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO21
 *  @access     GLOBAL->GPIOIE1.bit.GPIO21
 *  @brief      GPIO21 interrupt enable
 */
#define GPIOIE1_ALL_GPIO21_Pos (3)
#define GPIOIE1_ALL_GPIO21_Msk (0x1UL << GPIOIE1_ALL_GPIO21_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO21_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO21_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO21;

#define GPIOIE1_ALL_GPIO21_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO21_Pos)
#define GPIOIE1_ALL_GPIO21_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO21_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO22
 *  @access     GLOBAL->GPIOIE1.bit.GPIO22
 *  @brief      GPIO22 interrupt enable
 */
#define GPIOIE1_ALL_GPIO22_Pos (4)
#define GPIOIE1_ALL_GPIO22_Msk (0x1UL << GPIOIE1_ALL_GPIO22_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO22_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO22_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO22;

#define GPIOIE1_ALL_GPIO22_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO22_Pos)
#define GPIOIE1_ALL_GPIO22_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO22_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO23
 *  @access     GLOBAL->GPIOIE1.bit.GPIO23
 *  @brief      GPIO23 interrupt enable
 */
#define GPIOIE1_ALL_GPIO23_Pos (5)
#define GPIOIE1_ALL_GPIO23_Msk (0x1UL << GPIOIE1_ALL_GPIO23_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO23_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO23_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO23;

#define GPIOIE1_ALL_GPIO23_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO23_Pos)
#define GPIOIE1_ALL_GPIO23_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO23_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO24
 *  @access     GLOBAL->GPIOIE1.bit.GPIO24
 *  @brief      GPIO24 interrupt enable
 */
#define GPIOIE1_ALL_GPIO24_Pos (6)
#define GPIOIE1_ALL_GPIO24_Msk (0x1UL << GPIOIE1_ALL_GPIO24_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO24_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO24_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO24;

#define GPIOIE1_ALL_GPIO24_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO24_Pos)
#define GPIOIE1_ALL_GPIO24_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO24_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO25
 *  @access     GLOBAL->GPIOIE1.bit.GPIO25
 *  @brief      GPIO25 interrupt enable
 */
#define GPIOIE1_ALL_GPIO25_Pos (7)
#define GPIOIE1_ALL_GPIO25_Msk (0x1UL << GPIOIE1_ALL_GPIO25_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO25_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO25_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO25;

#define GPIOIE1_ALL_GPIO25_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO25_Pos)
#define GPIOIE1_ALL_GPIO25_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO25_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO26
 *  @access     GLOBAL->GPIOIE1.bit.GPIO26
 *  @brief      GPIO26 interrupt enable
 */
#define GPIOIE1_ALL_GPIO26_Pos (8)
#define GPIOIE1_ALL_GPIO26_Msk (0x1UL << GPIOIE1_ALL_GPIO26_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO26_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO26_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO26;

#define GPIOIE1_ALL_GPIO26_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO26_Pos)
#define GPIOIE1_ALL_GPIO26_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO26_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO27
 *  @access     GLOBAL->GPIOIE1.bit.GPIO27
 *  @brief      GPIO27 interrupt enable
 */
#define GPIOIE1_ALL_GPIO27_Pos (9)
#define GPIOIE1_ALL_GPIO27_Msk (0x1UL << GPIOIE1_ALL_GPIO27_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO27_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO27_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO27;

#define GPIOIE1_ALL_GPIO27_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO27_Pos)
#define GPIOIE1_ALL_GPIO27_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO27_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO28
 *  @access     GLOBAL->GPIOIE1.bit.GPIO28
 *  @brief      GPIO28 interrupt enable
 */
#define GPIOIE1_ALL_GPIO28_Pos (10)
#define GPIOIE1_ALL_GPIO28_Msk (0x1UL << GPIOIE1_ALL_GPIO28_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO28_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO28_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO28;

#define GPIOIE1_ALL_GPIO28_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO28_Pos)
#define GPIOIE1_ALL_GPIO28_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO28_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO29
 *  @access     GLOBAL->GPIOIE1.bit.GPIO29
 *  @brief      GPIO29 interrupt enable
 */
#define GPIOIE1_ALL_GPIO29_Pos (11)
#define GPIOIE1_ALL_GPIO29_Msk (0x1UL << GPIOIE1_ALL_GPIO29_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO29_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO29_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO29;

#define GPIOIE1_ALL_GPIO29_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO29_Pos)
#define GPIOIE1_ALL_GPIO29_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO29_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO30
 *  @access     GLOBAL->GPIOIE1.bit.GPIO30
 *  @brief      GPIO30 interrupt enable
 */
#define GPIOIE1_ALL_GPIO30_Pos (12)
#define GPIOIE1_ALL_GPIO30_Msk (0x1UL << GPIOIE1_ALL_GPIO30_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO30_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO30_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO30;

#define GPIOIE1_ALL_GPIO30_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO30_Pos)
#define GPIOIE1_ALL_GPIO30_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO30_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO31
 *  @access     GLOBAL->GPIOIE1.bit.GPIO31
 *  @brief      GPIO31 interrupt enable
 */
#define GPIOIE1_ALL_GPIO31_Pos (13)
#define GPIOIE1_ALL_GPIO31_Msk (0x1UL << GPIOIE1_ALL_GPIO31_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO31_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO31_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO31;

#define GPIOIE1_ALL_GPIO31_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO31_Pos)
#define GPIOIE1_ALL_GPIO31_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO31_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO32
 *  @access     GLOBAL->GPIOIE1.bit.GPIO32
 *  @brief      GPIO32 interrupt enable
 */
#define GPIOIE1_ALL_GPIO32_Pos (14)
#define GPIOIE1_ALL_GPIO32_Msk (0x1UL << GPIOIE1_ALL_GPIO32_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO32_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO32_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO32;

#define GPIOIE1_ALL_GPIO32_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO32_Pos)
#define GPIOIE1_ALL_GPIO32_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO32_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO33
 *  @access     GLOBAL->GPIOIE1.bit.GPIO33
 *  @brief      GPIO33 interrupt enable
 */
#define GPIOIE1_ALL_GPIO33_Pos (15)
#define GPIOIE1_ALL_GPIO33_Msk (0x1UL << GPIOIE1_ALL_GPIO33_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO33_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO33_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO33;

#define GPIOIE1_ALL_GPIO33_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO33_Pos)
#define GPIOIE1_ALL_GPIO33_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO33_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO34
 *  @access     GLOBAL->GPIOIE1.bit.GPIO34
 *  @brief      GPIO34 interrupt enable
 */
#define GPIOIE1_ALL_GPIO34_Pos (16)
#define GPIOIE1_ALL_GPIO34_Msk (0x1UL << GPIOIE1_ALL_GPIO34_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO34_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO34_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO34;

#define GPIOIE1_ALL_GPIO34_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO34_Pos)
#define GPIOIE1_ALL_GPIO34_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO34_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIE1         GPIO35
 *  @access     GLOBAL->GPIOIE1.bit.GPIO35
 *  @brief      GPIO35 interrupt enable
 */
#define GPIOIE1_ALL_GPIO35_Pos (17)
#define GPIOIE1_ALL_GPIO35_Msk (0x1UL << GPIOIE1_ALL_GPIO35_Pos)

typedef enum
{
    GPIOIE1_BIT_GPIO35_DISABLE     = 0,  /*!< Disable interrupt   */
    GPIOIE1_BIT_GPIO35_ENABLE      = 1,  /*!< Enable interrupt    */
} GPIOIE1_BIT_GPIO35;

#define GPIOIE1_ALL_GPIO35_DISABLE     ((0x0UL) << GPIOIE1_ALL_GPIO35_Pos)
#define GPIOIE1_ALL_GPIO35_ENABLE      ((0x1UL) << GPIOIE1_ALL_GPIO35_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO0
 *  @access     GLOBAL->GPIOIC0.bit.GPIO0
 *  @brief      GPIO0 interrupt clear
 */
#define GPIOIC0_ALL_GPIO0_Pos (0)
#define GPIOIC0_ALL_GPIO0_Msk (0x1UL << GPIOIC0_ALL_GPIO0_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO0_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO0_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO0;

#define GPIOIC0_ALL_GPIO0_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO0_Pos)
#define GPIOIC0_ALL_GPIO0_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO1
 *  @access     GLOBAL->GPIOIC0.bit.GPIO1
 *  @brief      GPIO1 interrupt clear
 */
#define GPIOIC0_ALL_GPIO1_Pos (1)
#define GPIOIC0_ALL_GPIO1_Msk (0x1UL << GPIOIC0_ALL_GPIO1_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO1_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO1_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO1;

#define GPIOIC0_ALL_GPIO1_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO1_Pos)
#define GPIOIC0_ALL_GPIO1_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO2
 *  @access     GLOBAL->GPIOIC0.bit.GPIO2
 *  @brief      GPIO2 interrupt clear
 */
#define GPIOIC0_ALL_GPIO2_Pos (2)
#define GPIOIC0_ALL_GPIO2_Msk (0x1UL << GPIOIC0_ALL_GPIO2_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO2_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO2_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO2;

#define GPIOIC0_ALL_GPIO2_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO2_Pos)
#define GPIOIC0_ALL_GPIO2_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO3
 *  @access     GLOBAL->GPIOIC0.bit.GPIO3
 *  @brief      GPIO3 interrupt clear
 */
#define GPIOIC0_ALL_GPIO3_Pos (3)
#define GPIOIC0_ALL_GPIO3_Msk (0x1UL << GPIOIC0_ALL_GPIO3_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO3_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO3_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO3;

#define GPIOIC0_ALL_GPIO3_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO3_Pos)
#define GPIOIC0_ALL_GPIO3_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO4
 *  @access     GLOBAL->GPIOIC0.bit.GPIO4
 *  @brief      GPIO4 interrupt clear
 */
#define GPIOIC0_ALL_GPIO4_Pos (4)
#define GPIOIC0_ALL_GPIO4_Msk (0x1UL << GPIOIC0_ALL_GPIO4_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO4_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO4_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO4;

#define GPIOIC0_ALL_GPIO4_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO4_Pos)
#define GPIOIC0_ALL_GPIO4_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO5
 *  @access     GLOBAL->GPIOIC0.bit.GPIO5
 *  @brief      GPIO5 interrupt clear
 */
#define GPIOIC0_ALL_GPIO5_Pos (5)
#define GPIOIC0_ALL_GPIO5_Msk (0x1UL << GPIOIC0_ALL_GPIO5_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO5_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO5_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO5;

#define GPIOIC0_ALL_GPIO5_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO5_Pos)
#define GPIOIC0_ALL_GPIO5_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO6
 *  @access     GLOBAL->GPIOIC0.bit.GPIO6
 *  @brief      GPIO6 interrupt clear
 */
#define GPIOIC0_ALL_GPIO6_Pos (6)
#define GPIOIC0_ALL_GPIO6_Msk (0x1UL << GPIOIC0_ALL_GPIO6_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO6_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO6_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO6;

#define GPIOIC0_ALL_GPIO6_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO6_Pos)
#define GPIOIC0_ALL_GPIO6_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO7
 *  @access     GLOBAL->GPIOIC0.bit.GPIO7
 *  @brief      GPIO7 interrupt clear
 */
#define GPIOIC0_ALL_GPIO7_Pos (7)
#define GPIOIC0_ALL_GPIO7_Msk (0x1UL << GPIOIC0_ALL_GPIO7_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO7_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO7_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO7;

#define GPIOIC0_ALL_GPIO7_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO7_Pos)
#define GPIOIC0_ALL_GPIO7_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO8
 *  @access     GLOBAL->GPIOIC0.bit.GPIO8
 *  @brief      GPIO8 interrupt clear
 */
#define GPIOIC0_ALL_GPIO8_Pos (8)
#define GPIOIC0_ALL_GPIO8_Msk (0x1UL << GPIOIC0_ALL_GPIO8_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO8_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO8_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO8;

#define GPIOIC0_ALL_GPIO8_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO8_Pos)
#define GPIOIC0_ALL_GPIO8_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO9
 *  @access     GLOBAL->GPIOIC0.bit.GPIO9
 *  @brief      GPIO9 interrupt clear
 */
#define GPIOIC0_ALL_GPIO9_Pos (9)
#define GPIOIC0_ALL_GPIO9_Msk (0x1UL << GPIOIC0_ALL_GPIO9_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO9_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO9_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO9;

#define GPIOIC0_ALL_GPIO9_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO9_Pos)
#define GPIOIC0_ALL_GPIO9_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO10
 *  @access     GLOBAL->GPIOIC0.bit.GPIO10
 *  @brief      GPIO10 interrupt clear
 */
#define GPIOIC0_ALL_GPIO10_Pos (10)
#define GPIOIC0_ALL_GPIO10_Msk (0x1UL << GPIOIC0_ALL_GPIO10_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO10_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO10_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO10;

#define GPIOIC0_ALL_GPIO10_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO10_Pos)
#define GPIOIC0_ALL_GPIO10_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO11
 *  @access     GLOBAL->GPIOIC0.bit.GPIO11
 *  @brief      GPIO11 interrupt clear
 */
#define GPIOIC0_ALL_GPIO11_Pos (11)
#define GPIOIC0_ALL_GPIO11_Msk (0x1UL << GPIOIC0_ALL_GPIO11_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO11_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO11_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO11;

#define GPIOIC0_ALL_GPIO11_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO11_Pos)
#define GPIOIC0_ALL_GPIO11_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO12
 *  @access     GLOBAL->GPIOIC0.bit.GPIO12
 *  @brief      GPIO12 interrupt clear
 */
#define GPIOIC0_ALL_GPIO12_Pos (12)
#define GPIOIC0_ALL_GPIO12_Msk (0x1UL << GPIOIC0_ALL_GPIO12_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO12_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO12_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO12;

#define GPIOIC0_ALL_GPIO12_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO12_Pos)
#define GPIOIC0_ALL_GPIO12_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO13
 *  @access     GLOBAL->GPIOIC0.bit.GPIO13
 *  @brief      GPIO13 interrupt clear
 */
#define GPIOIC0_ALL_GPIO13_Pos (13)
#define GPIOIC0_ALL_GPIO13_Msk (0x1UL << GPIOIC0_ALL_GPIO13_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO13_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO13_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO13;

#define GPIOIC0_ALL_GPIO13_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO13_Pos)
#define GPIOIC0_ALL_GPIO13_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO14
 *  @access     GLOBAL->GPIOIC0.bit.GPIO14
 *  @brief      GPIO14 interrupt clear
 */
#define GPIOIC0_ALL_GPIO14_Pos (14)
#define GPIOIC0_ALL_GPIO14_Msk (0x1UL << GPIOIC0_ALL_GPIO14_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO14_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO14_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO14;

#define GPIOIC0_ALL_GPIO14_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO14_Pos)
#define GPIOIC0_ALL_GPIO14_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO15
 *  @access     GLOBAL->GPIOIC0.bit.GPIO15
 *  @brief      GPIO15 interrupt clear
 */
#define GPIOIC0_ALL_GPIO15_Pos (15)
#define GPIOIC0_ALL_GPIO15_Msk (0x1UL << GPIOIC0_ALL_GPIO15_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO15_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO15_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO15;

#define GPIOIC0_ALL_GPIO15_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO15_Pos)
#define GPIOIC0_ALL_GPIO15_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO16
 *  @access     GLOBAL->GPIOIC0.bit.GPIO16
 *  @brief      GPIO16 interrupt clear
 */
#define GPIOIC0_ALL_GPIO16_Pos (16)
#define GPIOIC0_ALL_GPIO16_Msk (0x1UL << GPIOIC0_ALL_GPIO16_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO16_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO16_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO16;

#define GPIOIC0_ALL_GPIO16_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO16_Pos)
#define GPIOIC0_ALL_GPIO16_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO16_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC0         GPIO17
 *  @access     GLOBAL->GPIOIC0.bit.GPIO17
 *  @brief      GPIO17 interrupt clear
 */
#define GPIOIC0_ALL_GPIO17_Pos (17)
#define GPIOIC0_ALL_GPIO17_Msk (0x1UL << GPIOIC0_ALL_GPIO17_Pos)

typedef enum
{
    GPIOIC0_BIT_GPIO17_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC0_BIT_GPIO17_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC0_BIT_GPIO17;

#define GPIOIC0_ALL_GPIO17_RELEASE     ((0x0UL) << GPIOIC0_ALL_GPIO17_Pos)
#define GPIOIC0_ALL_GPIO17_CLEAR       ((0x1UL) << GPIOIC0_ALL_GPIO17_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO18
 *  @access     GLOBAL->GPIOIC1.bit.GPIO18
 *  @brief      GPIO18 interrupt clear
 */
#define GPIOIC1_ALL_GPIO18_Pos (0)
#define GPIOIC1_ALL_GPIO18_Msk (0x1UL << GPIOIC1_ALL_GPIO18_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO18_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO18_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO18;

#define GPIOIC1_ALL_GPIO18_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO18_Pos)
#define GPIOIC1_ALL_GPIO18_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO18_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO19
 *  @access     GLOBAL->GPIOIC1.bit.GPIO19
 *  @brief      GPIO19 interrupt clear
 */
#define GPIOIC1_ALL_GPIO19_Pos (1)
#define GPIOIC1_ALL_GPIO19_Msk (0x1UL << GPIOIC1_ALL_GPIO19_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO19_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO19_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO19;

#define GPIOIC1_ALL_GPIO19_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO19_Pos)
#define GPIOIC1_ALL_GPIO19_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO19_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO20
 *  @access     GLOBAL->GPIOIC1.bit.GPIO20
 *  @brief      GPIO20 interrupt clear
 */
#define GPIOIC1_ALL_GPIO20_Pos (2)
#define GPIOIC1_ALL_GPIO20_Msk (0x1UL << GPIOIC1_ALL_GPIO20_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO20_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO20_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO20;

#define GPIOIC1_ALL_GPIO20_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO20_Pos)
#define GPIOIC1_ALL_GPIO20_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO20_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO21
 *  @access     GLOBAL->GPIOIC1.bit.GPIO21
 *  @brief      GPIO21 interrupt clear
 */
#define GPIOIC1_ALL_GPIO21_Pos (3)
#define GPIOIC1_ALL_GPIO21_Msk (0x1UL << GPIOIC1_ALL_GPIO21_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO21_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO21_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO21;

#define GPIOIC1_ALL_GPIO21_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO21_Pos)
#define GPIOIC1_ALL_GPIO21_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO21_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO22
 *  @access     GLOBAL->GPIOIC1.bit.GPIO22
 *  @brief      GPIO22 interrupt clear
 */
#define GPIOIC1_ALL_GPIO22_Pos (4)
#define GPIOIC1_ALL_GPIO22_Msk (0x1UL << GPIOIC1_ALL_GPIO22_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO22_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO22_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO22;

#define GPIOIC1_ALL_GPIO22_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO22_Pos)
#define GPIOIC1_ALL_GPIO22_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO22_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO23
 *  @access     GLOBAL->GPIOIC1.bit.GPIO23
 *  @brief      GPIO23 interrupt clear
 */
#define GPIOIC1_ALL_GPIO23_Pos (5)
#define GPIOIC1_ALL_GPIO23_Msk (0x1UL << GPIOIC1_ALL_GPIO23_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO23_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO23_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO23;

#define GPIOIC1_ALL_GPIO23_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO23_Pos)
#define GPIOIC1_ALL_GPIO23_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO23_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO24
 *  @access     GLOBAL->GPIOIC1.bit.GPIO24
 *  @brief      GPIO24 interrupt clear
 */
#define GPIOIC1_ALL_GPIO24_Pos (6)
#define GPIOIC1_ALL_GPIO24_Msk (0x1UL << GPIOIC1_ALL_GPIO24_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO24_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO24_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO24;

#define GPIOIC1_ALL_GPIO24_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO24_Pos)
#define GPIOIC1_ALL_GPIO24_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO24_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO25
 *  @access     GLOBAL->GPIOIC1.bit.GPIO25
 *  @brief      GPIO25 interrupt clear
 */
#define GPIOIC1_ALL_GPIO25_Pos (7)
#define GPIOIC1_ALL_GPIO25_Msk (0x1UL << GPIOIC1_ALL_GPIO25_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO25_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO25_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO25;

#define GPIOIC1_ALL_GPIO25_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO25_Pos)
#define GPIOIC1_ALL_GPIO25_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO25_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO26
 *  @access     GLOBAL->GPIOIC1.bit.GPIO26
 *  @brief      GPIO26 interrupt clear
 */
#define GPIOIC1_ALL_GPIO26_Pos (8)
#define GPIOIC1_ALL_GPIO26_Msk (0x1UL << GPIOIC1_ALL_GPIO26_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO26_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO26_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO26;

#define GPIOIC1_ALL_GPIO26_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO26_Pos)
#define GPIOIC1_ALL_GPIO26_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO26_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO27
 *  @access     GLOBAL->GPIOIC1.bit.GPIO27
 *  @brief      GPIO27 interrupt clear
 */
#define GPIOIC1_ALL_GPIO27_Pos (9)
#define GPIOIC1_ALL_GPIO27_Msk (0x1UL << GPIOIC1_ALL_GPIO27_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO27_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO27_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO27;

#define GPIOIC1_ALL_GPIO27_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO27_Pos)
#define GPIOIC1_ALL_GPIO27_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO27_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO28
 *  @access     GLOBAL->GPIOIC1.bit.GPIO28
 *  @brief      GPIO28 interrupt clear
 */
#define GPIOIC1_ALL_GPIO28_Pos (10)
#define GPIOIC1_ALL_GPIO28_Msk (0x1UL << GPIOIC1_ALL_GPIO28_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO28_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO28_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO28;

#define GPIOIC1_ALL_GPIO28_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO28_Pos)
#define GPIOIC1_ALL_GPIO28_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO28_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO29
 *  @access     GLOBAL->GPIOIC1.bit.GPIO29
 *  @brief      GPIO29 interrupt clear
 */
#define GPIOIC1_ALL_GPIO29_Pos (11)
#define GPIOIC1_ALL_GPIO29_Msk (0x1UL << GPIOIC1_ALL_GPIO29_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO29_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO29_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO29;

#define GPIOIC1_ALL_GPIO29_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO29_Pos)
#define GPIOIC1_ALL_GPIO29_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO29_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO30
 *  @access     GLOBAL->GPIOIC1.bit.GPIO30
 *  @brief      GPIO30 interrupt clear
 */
#define GPIOIC1_ALL_GPIO30_Pos (12)
#define GPIOIC1_ALL_GPIO30_Msk (0x1UL << GPIOIC1_ALL_GPIO30_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO30_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO30_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO30;

#define GPIOIC1_ALL_GPIO30_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO30_Pos)
#define GPIOIC1_ALL_GPIO30_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO30_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO31
 *  @access     GLOBAL->GPIOIC1.bit.GPIO31
 *  @brief      GPIO31 interrupt clear
 */
#define GPIOIC1_ALL_GPIO31_Pos (13)
#define GPIOIC1_ALL_GPIO31_Msk (0x1UL << GPIOIC1_ALL_GPIO31_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO31_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO31_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO31;

#define GPIOIC1_ALL_GPIO31_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO31_Pos)
#define GPIOIC1_ALL_GPIO31_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO31_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO32
 *  @access     GLOBAL->GPIOIC1.bit.GPIO32
 *  @brief      GPIO32 interrupt clear
 */
#define GPIOIC1_ALL_GPIO32_Pos (14)
#define GPIOIC1_ALL_GPIO32_Msk (0x1UL << GPIOIC1_ALL_GPIO32_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO32_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO32_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO32;

#define GPIOIC1_ALL_GPIO32_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO32_Pos)
#define GPIOIC1_ALL_GPIO32_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO32_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO33
 *  @access     GLOBAL->GPIOIC1.bit.GPIO33
 *  @brief      GPIO33 interrupt clear
 */
#define GPIOIC1_ALL_GPIO33_Pos (15)
#define GPIOIC1_ALL_GPIO33_Msk (0x1UL << GPIOIC1_ALL_GPIO33_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO33_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO33_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO33;

#define GPIOIC1_ALL_GPIO33_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO33_Pos)
#define GPIOIC1_ALL_GPIO33_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO33_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO34
 *  @access     GLOBAL->GPIOIC1.bit.GPIO34
 *  @brief      GPIO34 interrupt clear
 */
#define GPIOIC1_ALL_GPIO34_Pos (16)
#define GPIOIC1_ALL_GPIO34_Msk (0x1UL << GPIOIC1_ALL_GPIO34_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO34_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO34_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO34;

#define GPIOIC1_ALL_GPIO34_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO34_Pos)
#define GPIOIC1_ALL_GPIO34_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO34_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIC1         GPIO35
 *  @access     GLOBAL->GPIOIC1.bit.GPIO35
 *  @brief      GPIO35 interrupt clear
 */
#define GPIOIC1_ALL_GPIO35_Pos (17)
#define GPIOIC1_ALL_GPIO35_Msk (0x1UL << GPIOIC1_ALL_GPIO35_Pos)

typedef enum
{
    GPIOIC1_BIT_GPIO35_RELEASE     = 0,  /*!< Release the clear     */
    GPIOIC1_BIT_GPIO35_CLEAR       = 1,  /*!< Clear the interrupt   */
} GPIOIC1_BIT_GPIO35;

#define GPIOIC1_ALL_GPIO35_RELEASE     ((0x0UL) << GPIOIC1_ALL_GPIO35_Pos)
#define GPIOIC1_ALL_GPIO35_CLEAR       ((0x1UL) << GPIOIC1_ALL_GPIO35_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO0
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO0
 *  @brief      GPIO0 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO0_Pos (0)
#define GPIOIFRC0_ALL_GPIO0_Msk (0x1UL << GPIOIFRC0_ALL_GPIO0_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO0_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO0_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO0;

#define GPIOIFRC0_ALL_GPIO0_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO0_Pos)
#define GPIOIFRC0_ALL_GPIO0_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO1
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO1
 *  @brief      GPIO1 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO1_Pos (1)
#define GPIOIFRC0_ALL_GPIO1_Msk (0x1UL << GPIOIFRC0_ALL_GPIO1_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO1_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO1_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO1;

#define GPIOIFRC0_ALL_GPIO1_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO1_Pos)
#define GPIOIFRC0_ALL_GPIO1_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO2
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO2
 *  @brief      GPIO2 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO2_Pos (2)
#define GPIOIFRC0_ALL_GPIO2_Msk (0x1UL << GPIOIFRC0_ALL_GPIO2_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO2_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO2_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO2;

#define GPIOIFRC0_ALL_GPIO2_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO2_Pos)
#define GPIOIFRC0_ALL_GPIO2_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO3
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO3
 *  @brief      GPIO3 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO3_Pos (3)
#define GPIOIFRC0_ALL_GPIO3_Msk (0x1UL << GPIOIFRC0_ALL_GPIO3_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO3_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO3_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO3;

#define GPIOIFRC0_ALL_GPIO3_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO3_Pos)
#define GPIOIFRC0_ALL_GPIO3_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO4
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO4
 *  @brief      GPIO4 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO4_Pos (4)
#define GPIOIFRC0_ALL_GPIO4_Msk (0x1UL << GPIOIFRC0_ALL_GPIO4_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO4_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO4_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO4;

#define GPIOIFRC0_ALL_GPIO4_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO4_Pos)
#define GPIOIFRC0_ALL_GPIO4_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO5
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO5
 *  @brief      GPIO5 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO5_Pos (5)
#define GPIOIFRC0_ALL_GPIO5_Msk (0x1UL << GPIOIFRC0_ALL_GPIO5_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO5_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO5_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO5;

#define GPIOIFRC0_ALL_GPIO5_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO5_Pos)
#define GPIOIFRC0_ALL_GPIO5_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO6
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO6
 *  @brief      GPIO6 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO6_Pos (6)
#define GPIOIFRC0_ALL_GPIO6_Msk (0x1UL << GPIOIFRC0_ALL_GPIO6_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO6_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO6_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO6;

#define GPIOIFRC0_ALL_GPIO6_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO6_Pos)
#define GPIOIFRC0_ALL_GPIO6_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO7
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO7
 *  @brief      GPIO7 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO7_Pos (7)
#define GPIOIFRC0_ALL_GPIO7_Msk (0x1UL << GPIOIFRC0_ALL_GPIO7_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO7_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO7_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO7;

#define GPIOIFRC0_ALL_GPIO7_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO7_Pos)
#define GPIOIFRC0_ALL_GPIO7_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO8
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO8
 *  @brief      GPIO8 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO8_Pos (8)
#define GPIOIFRC0_ALL_GPIO8_Msk (0x1UL << GPIOIFRC0_ALL_GPIO8_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO8_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO8_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO8;

#define GPIOIFRC0_ALL_GPIO8_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO8_Pos)
#define GPIOIFRC0_ALL_GPIO8_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO9
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO9
 *  @brief      GPIO9 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO9_Pos (9)
#define GPIOIFRC0_ALL_GPIO9_Msk (0x1UL << GPIOIFRC0_ALL_GPIO9_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO9_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO9_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO9;

#define GPIOIFRC0_ALL_GPIO9_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO9_Pos)
#define GPIOIFRC0_ALL_GPIO9_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO10
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO10
 *  @brief      GPIO10 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO10_Pos (10)
#define GPIOIFRC0_ALL_GPIO10_Msk (0x1UL << GPIOIFRC0_ALL_GPIO10_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO10_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO10_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO10;

#define GPIOIFRC0_ALL_GPIO10_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO10_Pos)
#define GPIOIFRC0_ALL_GPIO10_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO11
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO11
 *  @brief      GPIO11 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO11_Pos (11)
#define GPIOIFRC0_ALL_GPIO11_Msk (0x1UL << GPIOIFRC0_ALL_GPIO11_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO11_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO11_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO11;

#define GPIOIFRC0_ALL_GPIO11_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO11_Pos)
#define GPIOIFRC0_ALL_GPIO11_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO12
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO12
 *  @brief      GPIO12 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO12_Pos (12)
#define GPIOIFRC0_ALL_GPIO12_Msk (0x1UL << GPIOIFRC0_ALL_GPIO12_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO12_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO12_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO12;

#define GPIOIFRC0_ALL_GPIO12_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO12_Pos)
#define GPIOIFRC0_ALL_GPIO12_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO13
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO13
 *  @brief      GPIO13 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO13_Pos (13)
#define GPIOIFRC0_ALL_GPIO13_Msk (0x1UL << GPIOIFRC0_ALL_GPIO13_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO13_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO13_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO13;

#define GPIOIFRC0_ALL_GPIO13_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO13_Pos)
#define GPIOIFRC0_ALL_GPIO13_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO14
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO14
 *  @brief      GPIO14 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO14_Pos (14)
#define GPIOIFRC0_ALL_GPIO14_Msk (0x1UL << GPIOIFRC0_ALL_GPIO14_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO14_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO14_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO14;

#define GPIOIFRC0_ALL_GPIO14_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO14_Pos)
#define GPIOIFRC0_ALL_GPIO14_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO15
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO15
 *  @brief      GPIO15 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO15_Pos (15)
#define GPIOIFRC0_ALL_GPIO15_Msk (0x1UL << GPIOIFRC0_ALL_GPIO15_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO15_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO15_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO15;

#define GPIOIFRC0_ALL_GPIO15_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO15_Pos)
#define GPIOIFRC0_ALL_GPIO15_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO16
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO16
 *  @brief      GPIO16 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO16_Pos (16)
#define GPIOIFRC0_ALL_GPIO16_Msk (0x1UL << GPIOIFRC0_ALL_GPIO16_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO16_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO16_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO16;

#define GPIOIFRC0_ALL_GPIO16_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO16_Pos)
#define GPIOIFRC0_ALL_GPIO16_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO16_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC0       GPIO17
 *  @access     GLOBAL->GPIOIFRC0.bit.GPIO17
 *  @brief      GPIO17 interrupt force
 */
#define GPIOIFRC0_ALL_GPIO17_Pos (17)
#define GPIOIFRC0_ALL_GPIO17_Msk (0x1UL << GPIOIFRC0_ALL_GPIO17_Pos)

typedef enum
{
    GPIOIFRC0_BIT_GPIO17_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC0_BIT_GPIO17_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC0_BIT_GPIO17;

#define GPIOIFRC0_ALL_GPIO17_RELEASE     ((0x0UL) << GPIOIFRC0_ALL_GPIO17_Pos)
#define GPIOIFRC0_ALL_GPIO17_FORCE       ((0x1UL) << GPIOIFRC0_ALL_GPIO17_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO18
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO18
 *  @brief      GPIO18 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO18_Pos (0)
#define GPIOIFRC1_ALL_GPIO18_Msk (0x1UL << GPIOIFRC1_ALL_GPIO18_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO18_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO18_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO18;

#define GPIOIFRC1_ALL_GPIO18_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO18_Pos)
#define GPIOIFRC1_ALL_GPIO18_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO18_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO19
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO19
 *  @brief      GPIO19 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO19_Pos (1)
#define GPIOIFRC1_ALL_GPIO19_Msk (0x1UL << GPIOIFRC1_ALL_GPIO19_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO19_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO19_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO19;

#define GPIOIFRC1_ALL_GPIO19_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO19_Pos)
#define GPIOIFRC1_ALL_GPIO19_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO19_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO20
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO20
 *  @brief      GPIO20 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO20_Pos (2)
#define GPIOIFRC1_ALL_GPIO20_Msk (0x1UL << GPIOIFRC1_ALL_GPIO20_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO20_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO20_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO20;

#define GPIOIFRC1_ALL_GPIO20_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO20_Pos)
#define GPIOIFRC1_ALL_GPIO20_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO20_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO21
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO21
 *  @brief      GPIO21 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO21_Pos (3)
#define GPIOIFRC1_ALL_GPIO21_Msk (0x1UL << GPIOIFRC1_ALL_GPIO21_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO21_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO21_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO21;

#define GPIOIFRC1_ALL_GPIO21_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO21_Pos)
#define GPIOIFRC1_ALL_GPIO21_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO21_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO22
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO22
 *  @brief      GPIO22 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO22_Pos (4)
#define GPIOIFRC1_ALL_GPIO22_Msk (0x1UL << GPIOIFRC1_ALL_GPIO22_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO22_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO22_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO22;

#define GPIOIFRC1_ALL_GPIO22_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO22_Pos)
#define GPIOIFRC1_ALL_GPIO22_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO22_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO23
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO23
 *  @brief      GPIO23 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO23_Pos (5)
#define GPIOIFRC1_ALL_GPIO23_Msk (0x1UL << GPIOIFRC1_ALL_GPIO23_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO23_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO23_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO23;

#define GPIOIFRC1_ALL_GPIO23_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO23_Pos)
#define GPIOIFRC1_ALL_GPIO23_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO23_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO24
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO24
 *  @brief      GPIO24 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO24_Pos (6)
#define GPIOIFRC1_ALL_GPIO24_Msk (0x1UL << GPIOIFRC1_ALL_GPIO24_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO24_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO24_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO24;

#define GPIOIFRC1_ALL_GPIO24_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO24_Pos)
#define GPIOIFRC1_ALL_GPIO24_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO24_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO25
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO25
 *  @brief      GPIO25 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO25_Pos (7)
#define GPIOIFRC1_ALL_GPIO25_Msk (0x1UL << GPIOIFRC1_ALL_GPIO25_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO25_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO25_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO25;

#define GPIOIFRC1_ALL_GPIO25_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO25_Pos)
#define GPIOIFRC1_ALL_GPIO25_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO25_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO26
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO26
 *  @brief      GPIO26 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO26_Pos (8)
#define GPIOIFRC1_ALL_GPIO26_Msk (0x1UL << GPIOIFRC1_ALL_GPIO26_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO26_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO26_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO26;

#define GPIOIFRC1_ALL_GPIO26_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO26_Pos)
#define GPIOIFRC1_ALL_GPIO26_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO26_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO27
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO27
 *  @brief      GPIO27 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO27_Pos (9)
#define GPIOIFRC1_ALL_GPIO27_Msk (0x1UL << GPIOIFRC1_ALL_GPIO27_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO27_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO27_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO27;

#define GPIOIFRC1_ALL_GPIO27_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO27_Pos)
#define GPIOIFRC1_ALL_GPIO27_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO27_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO28
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO28
 *  @brief      GPIO28 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO28_Pos (10)
#define GPIOIFRC1_ALL_GPIO28_Msk (0x1UL << GPIOIFRC1_ALL_GPIO28_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO28_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO28_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO28;

#define GPIOIFRC1_ALL_GPIO28_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO28_Pos)
#define GPIOIFRC1_ALL_GPIO28_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO28_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO29
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO29
 *  @brief      GPIO29 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO29_Pos (11)
#define GPIOIFRC1_ALL_GPIO29_Msk (0x1UL << GPIOIFRC1_ALL_GPIO29_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO29_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO29_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO29;

#define GPIOIFRC1_ALL_GPIO29_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO29_Pos)
#define GPIOIFRC1_ALL_GPIO29_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO29_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO30
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO30
 *  @brief      GPIO30 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO30_Pos (12)
#define GPIOIFRC1_ALL_GPIO30_Msk (0x1UL << GPIOIFRC1_ALL_GPIO30_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO30_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO30_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO30;

#define GPIOIFRC1_ALL_GPIO30_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO30_Pos)
#define GPIOIFRC1_ALL_GPIO30_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO30_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO31
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO31
 *  @brief      GPIO31 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO31_Pos (13)
#define GPIOIFRC1_ALL_GPIO31_Msk (0x1UL << GPIOIFRC1_ALL_GPIO31_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO31_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO31_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO31;

#define GPIOIFRC1_ALL_GPIO31_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO31_Pos)
#define GPIOIFRC1_ALL_GPIO31_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO31_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO32
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO32
 *  @brief      GPIO32 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO32_Pos (14)
#define GPIOIFRC1_ALL_GPIO32_Msk (0x1UL << GPIOIFRC1_ALL_GPIO32_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO32_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO32_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO32;

#define GPIOIFRC1_ALL_GPIO32_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO32_Pos)
#define GPIOIFRC1_ALL_GPIO32_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO32_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO33
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO33
 *  @brief      GPIO33 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO33_Pos (15)
#define GPIOIFRC1_ALL_GPIO33_Msk (0x1UL << GPIOIFRC1_ALL_GPIO33_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO33_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO33_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO33;

#define GPIOIFRC1_ALL_GPIO33_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO33_Pos)
#define GPIOIFRC1_ALL_GPIO33_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO33_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO34
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO34
 *  @brief      GPIO34 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO34_Pos (16)
#define GPIOIFRC1_ALL_GPIO34_Msk (0x1UL << GPIOIFRC1_ALL_GPIO34_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO34_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO34_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO34;

#define GPIOIFRC1_ALL_GPIO34_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO34_Pos)
#define GPIOIFRC1_ALL_GPIO34_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO34_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOIFRC1       GPIO35
 *  @access     GLOBAL->GPIOIFRC1.bit.GPIO35
 *  @brief      GPIO35 interrupt force
 */
#define GPIOIFRC1_ALL_GPIO35_Pos (17)
#define GPIOIFRC1_ALL_GPIO35_Msk (0x1UL << GPIOIFRC1_ALL_GPIO35_Pos)

typedef enum
{
    GPIOIFRC1_BIT_GPIO35_RELEASE     = 0,  /*!< Release the force    */
    GPIOIFRC1_BIT_GPIO35_FORCE       = 1,  /*!< Force an interrupt   */
} GPIOIFRC1_BIT_GPIO35;

#define GPIOIFRC1_ALL_GPIO35_RELEASE     ((0x0UL) << GPIOIFRC1_ALL_GPIO35_Pos)
#define GPIOIFRC1_ALL_GPIO35_FORCE       ((0x1UL) << GPIOIFRC1_ALL_GPIO35_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO0
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO0
 *  @brief      GPIO0 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO0_Pos (0)
#define GPIOINTINV0_ALL_GPIO0_Msk (0x1UL << GPIOINTINV0_ALL_GPIO0_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO0_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO0_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO0;

#define GPIOINTINV0_ALL_GPIO0_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO0_Pos)
#define GPIOINTINV0_ALL_GPIO0_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO1
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO1
 *  @brief      GPIO1 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO1_Pos (1)
#define GPIOINTINV0_ALL_GPIO1_Msk (0x1UL << GPIOINTINV0_ALL_GPIO1_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO1_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO1_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO1;

#define GPIOINTINV0_ALL_GPIO1_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO1_Pos)
#define GPIOINTINV0_ALL_GPIO1_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO2
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO2
 *  @brief      GPIO2 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO2_Pos (2)
#define GPIOINTINV0_ALL_GPIO2_Msk (0x1UL << GPIOINTINV0_ALL_GPIO2_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO2_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO2_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO2;

#define GPIOINTINV0_ALL_GPIO2_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO2_Pos)
#define GPIOINTINV0_ALL_GPIO2_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO3
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO3
 *  @brief      GPIO3 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO3_Pos (3)
#define GPIOINTINV0_ALL_GPIO3_Msk (0x1UL << GPIOINTINV0_ALL_GPIO3_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO3_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO3_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO3;

#define GPIOINTINV0_ALL_GPIO3_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO3_Pos)
#define GPIOINTINV0_ALL_GPIO3_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO4
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO4
 *  @brief      GPIO4 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO4_Pos (4)
#define GPIOINTINV0_ALL_GPIO4_Msk (0x1UL << GPIOINTINV0_ALL_GPIO4_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO4_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO4_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO4;

#define GPIOINTINV0_ALL_GPIO4_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO4_Pos)
#define GPIOINTINV0_ALL_GPIO4_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO4_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO5
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO5
 *  @brief      GPIO5 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO5_Pos (5)
#define GPIOINTINV0_ALL_GPIO5_Msk (0x1UL << GPIOINTINV0_ALL_GPIO5_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO5_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO5_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO5;

#define GPIOINTINV0_ALL_GPIO5_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO5_Pos)
#define GPIOINTINV0_ALL_GPIO5_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO5_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO6
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO6
 *  @brief      GPIO6 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO6_Pos (6)
#define GPIOINTINV0_ALL_GPIO6_Msk (0x1UL << GPIOINTINV0_ALL_GPIO6_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO6_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO6_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO6;

#define GPIOINTINV0_ALL_GPIO6_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO6_Pos)
#define GPIOINTINV0_ALL_GPIO6_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO6_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO7
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO7
 *  @brief      GPIO7 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO7_Pos (7)
#define GPIOINTINV0_ALL_GPIO7_Msk (0x1UL << GPIOINTINV0_ALL_GPIO7_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO7_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO7_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO7;

#define GPIOINTINV0_ALL_GPIO7_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO7_Pos)
#define GPIOINTINV0_ALL_GPIO7_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO7_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO8
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO8
 *  @brief      GPIO8 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO8_Pos (8)
#define GPIOINTINV0_ALL_GPIO8_Msk (0x1UL << GPIOINTINV0_ALL_GPIO8_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO8_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO8_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO8;

#define GPIOINTINV0_ALL_GPIO8_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO8_Pos)
#define GPIOINTINV0_ALL_GPIO8_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO8_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO9
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO9
 *  @brief      GPIO9 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO9_Pos (9)
#define GPIOINTINV0_ALL_GPIO9_Msk (0x1UL << GPIOINTINV0_ALL_GPIO9_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO9_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO9_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO9;

#define GPIOINTINV0_ALL_GPIO9_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO9_Pos)
#define GPIOINTINV0_ALL_GPIO9_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO9_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO10
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO10
 *  @brief      GPIO10 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO10_Pos (10)
#define GPIOINTINV0_ALL_GPIO10_Msk (0x1UL << GPIOINTINV0_ALL_GPIO10_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO10_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO10_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO10;

#define GPIOINTINV0_ALL_GPIO10_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO10_Pos)
#define GPIOINTINV0_ALL_GPIO10_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO10_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO11
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO11
 *  @brief      GPIO11 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO11_Pos (11)
#define GPIOINTINV0_ALL_GPIO11_Msk (0x1UL << GPIOINTINV0_ALL_GPIO11_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO11_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO11_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO11;

#define GPIOINTINV0_ALL_GPIO11_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO11_Pos)
#define GPIOINTINV0_ALL_GPIO11_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO11_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO12
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO12
 *  @brief      GPIO12 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO12_Pos (12)
#define GPIOINTINV0_ALL_GPIO12_Msk (0x1UL << GPIOINTINV0_ALL_GPIO12_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO12_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO12_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO12;

#define GPIOINTINV0_ALL_GPIO12_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO12_Pos)
#define GPIOINTINV0_ALL_GPIO12_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO12_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO13
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO13
 *  @brief      GPIO13 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO13_Pos (13)
#define GPIOINTINV0_ALL_GPIO13_Msk (0x1UL << GPIOINTINV0_ALL_GPIO13_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO13_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO13_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO13;

#define GPIOINTINV0_ALL_GPIO13_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO13_Pos)
#define GPIOINTINV0_ALL_GPIO13_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO13_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO14
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO14
 *  @brief      GPIO14 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO14_Pos (14)
#define GPIOINTINV0_ALL_GPIO14_Msk (0x1UL << GPIOINTINV0_ALL_GPIO14_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO14_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO14_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO14;

#define GPIOINTINV0_ALL_GPIO14_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO14_Pos)
#define GPIOINTINV0_ALL_GPIO14_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO14_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO15
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO15
 *  @brief      GPIO15 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO15_Pos (15)
#define GPIOINTINV0_ALL_GPIO15_Msk (0x1UL << GPIOINTINV0_ALL_GPIO15_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO15_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO15_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO15;

#define GPIOINTINV0_ALL_GPIO15_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO15_Pos)
#define GPIOINTINV0_ALL_GPIO15_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO15_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO16
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO16
 *  @brief      GPIO16 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO16_Pos (16)
#define GPIOINTINV0_ALL_GPIO16_Msk (0x1UL << GPIOINTINV0_ALL_GPIO16_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO16_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO16_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO16;

#define GPIOINTINV0_ALL_GPIO16_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO16_Pos)
#define GPIOINTINV0_ALL_GPIO16_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO16_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV0     GPIO17
 *  @access     GLOBAL->GPIOINTINV0.bit.GPIO17
 *  @brief      GPIO17 interrupt polarity inversion
 */
#define GPIOINTINV0_ALL_GPIO17_Pos (17)
#define GPIOINTINV0_ALL_GPIO17_Msk (0x1UL << GPIOINTINV0_ALL_GPIO17_Pos)

typedef enum
{
    GPIOINTINV0_BIT_GPIO17_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV0_BIT_GPIO17_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV0_BIT_GPIO17;

#define GPIOINTINV0_ALL_GPIO17_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV0_ALL_GPIO17_Pos)
#define GPIOINTINV0_ALL_GPIO17_LOW_ACTIVE      ((0x1UL) << GPIOINTINV0_ALL_GPIO17_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO18
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO18
 *  @brief      GPIO18 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO18_Pos (0)
#define GPIOINTINV1_ALL_GPIO18_Msk (0x1UL << GPIOINTINV1_ALL_GPIO18_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO18_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO18_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO18;

#define GPIOINTINV1_ALL_GPIO18_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO18_Pos)
#define GPIOINTINV1_ALL_GPIO18_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO18_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO19
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO19
 *  @brief      GPIO19 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO19_Pos (1)
#define GPIOINTINV1_ALL_GPIO19_Msk (0x1UL << GPIOINTINV1_ALL_GPIO19_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO19_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO19_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO19;

#define GPIOINTINV1_ALL_GPIO19_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO19_Pos)
#define GPIOINTINV1_ALL_GPIO19_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO19_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO20
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO20
 *  @brief      GPIO20 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO20_Pos (2)
#define GPIOINTINV1_ALL_GPIO20_Msk (0x1UL << GPIOINTINV1_ALL_GPIO20_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO20_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO20_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO20;

#define GPIOINTINV1_ALL_GPIO20_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO20_Pos)
#define GPIOINTINV1_ALL_GPIO20_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO20_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO21
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO21
 *  @brief      GPIO21 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO21_Pos (3)
#define GPIOINTINV1_ALL_GPIO21_Msk (0x1UL << GPIOINTINV1_ALL_GPIO21_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO21_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO21_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO21;

#define GPIOINTINV1_ALL_GPIO21_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO21_Pos)
#define GPIOINTINV1_ALL_GPIO21_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO21_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO22
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO22
 *  @brief      GPIO22 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO22_Pos (4)
#define GPIOINTINV1_ALL_GPIO22_Msk (0x1UL << GPIOINTINV1_ALL_GPIO22_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO22_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO22_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO22;

#define GPIOINTINV1_ALL_GPIO22_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO22_Pos)
#define GPIOINTINV1_ALL_GPIO22_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO22_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO23
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO23
 *  @brief      GPIO23 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO23_Pos (5)
#define GPIOINTINV1_ALL_GPIO23_Msk (0x1UL << GPIOINTINV1_ALL_GPIO23_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO23_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO23_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO23;

#define GPIOINTINV1_ALL_GPIO23_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO23_Pos)
#define GPIOINTINV1_ALL_GPIO23_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO23_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO24
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO24
 *  @brief      GPIO24 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO24_Pos (6)
#define GPIOINTINV1_ALL_GPIO24_Msk (0x1UL << GPIOINTINV1_ALL_GPIO24_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO24_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO24_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO24;

#define GPIOINTINV1_ALL_GPIO24_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO24_Pos)
#define GPIOINTINV1_ALL_GPIO24_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO24_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO25
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO25
 *  @brief      GPIO25 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO25_Pos (7)
#define GPIOINTINV1_ALL_GPIO25_Msk (0x1UL << GPIOINTINV1_ALL_GPIO25_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO25_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO25_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO25;

#define GPIOINTINV1_ALL_GPIO25_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO25_Pos)
#define GPIOINTINV1_ALL_GPIO25_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO25_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO26
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO26
 *  @brief      GPIO26 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO26_Pos (8)
#define GPIOINTINV1_ALL_GPIO26_Msk (0x1UL << GPIOINTINV1_ALL_GPIO26_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO26_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO26_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO26;

#define GPIOINTINV1_ALL_GPIO26_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO26_Pos)
#define GPIOINTINV1_ALL_GPIO26_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO26_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO27
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO27
 *  @brief      GPIO27 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO27_Pos (9)
#define GPIOINTINV1_ALL_GPIO27_Msk (0x1UL << GPIOINTINV1_ALL_GPIO27_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO27_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO27_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO27;

#define GPIOINTINV1_ALL_GPIO27_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO27_Pos)
#define GPIOINTINV1_ALL_GPIO27_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO27_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO28
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO28
 *  @brief      GPIO28 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO28_Pos (10)
#define GPIOINTINV1_ALL_GPIO28_Msk (0x1UL << GPIOINTINV1_ALL_GPIO28_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO28_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO28_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO28;

#define GPIOINTINV1_ALL_GPIO28_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO28_Pos)
#define GPIOINTINV1_ALL_GPIO28_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO28_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO29
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO29
 *  @brief      GPIO29 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO29_Pos (11)
#define GPIOINTINV1_ALL_GPIO29_Msk (0x1UL << GPIOINTINV1_ALL_GPIO29_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO29_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO29_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO29;

#define GPIOINTINV1_ALL_GPIO29_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO29_Pos)
#define GPIOINTINV1_ALL_GPIO29_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO29_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO30
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO30
 *  @brief      GPIO30 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO30_Pos (12)
#define GPIOINTINV1_ALL_GPIO30_Msk (0x1UL << GPIOINTINV1_ALL_GPIO30_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO30_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO30_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO30;

#define GPIOINTINV1_ALL_GPIO30_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO30_Pos)
#define GPIOINTINV1_ALL_GPIO30_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO30_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO31
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO31
 *  @brief      GPIO31 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO31_Pos (13)
#define GPIOINTINV1_ALL_GPIO31_Msk (0x1UL << GPIOINTINV1_ALL_GPIO31_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO31_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO31_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO31;

#define GPIOINTINV1_ALL_GPIO31_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO31_Pos)
#define GPIOINTINV1_ALL_GPIO31_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO31_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO32
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO32
 *  @brief      GPIO32 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO32_Pos (14)
#define GPIOINTINV1_ALL_GPIO32_Msk (0x1UL << GPIOINTINV1_ALL_GPIO32_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO32_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO32_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO32;

#define GPIOINTINV1_ALL_GPIO32_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO32_Pos)
#define GPIOINTINV1_ALL_GPIO32_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO32_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO33
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO33
 *  @brief      GPIO33 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO33_Pos (15)
#define GPIOINTINV1_ALL_GPIO33_Msk (0x1UL << GPIOINTINV1_ALL_GPIO33_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO33_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO33_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO33;

#define GPIOINTINV1_ALL_GPIO33_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO33_Pos)
#define GPIOINTINV1_ALL_GPIO33_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO33_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO34
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO34
 *  @brief      GPIO34 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO34_Pos (16)
#define GPIOINTINV1_ALL_GPIO34_Msk (0x1UL << GPIOINTINV1_ALL_GPIO34_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO34_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO34_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO34;

#define GPIOINTINV1_ALL_GPIO34_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO34_Pos)
#define GPIOINTINV1_ALL_GPIO34_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO34_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOINTINV1     GPIO35
 *  @access     GLOBAL->GPIOINTINV1.bit.GPIO35
 *  @brief      GPIO35 interrupt polarity inversion
 */
#define GPIOINTINV1_ALL_GPIO35_Pos (17)
#define GPIOINTINV1_ALL_GPIO35_Msk (0x1UL << GPIOINTINV1_ALL_GPIO35_Pos)

typedef enum
{
    GPIOINTINV1_BIT_GPIO35_HIGH_ACTIVE     = 0,  /*!< Resume polarity (interrupt when high)   */
    GPIOINTINV1_BIT_GPIO35_LOW_ACTIVE      = 1,  /*!< Invert polarity (interrupt when low)    */
} GPIOINTINV1_BIT_GPIO35;

#define GPIOINTINV1_ALL_GPIO35_HIGH_ACTIVE     ((0x0UL) << GPIOINTINV1_ALL_GPIO35_Pos)
#define GPIOINTINV1_ALL_GPIO35_LOW_ACTIVE      ((0x1UL) << GPIOINTINV1_ALL_GPIO35_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOMISC        TZ1SEL
 *  @access     GLOBAL->GPIOMISC.bit.TZ1SEL
 *  @brief      TZ1 event source select
 */
#define GPIOMISC_ALL_TZ1SEL_Pos (0)
#define GPIOMISC_ALL_TZ1SEL_Msk (0x7UL << GPIOMISC_ALL_TZ1SEL_Pos)

typedef enum
{
    GPIOMISC_BIT_TZ1SEL_NO_EVENT     = 0,  /*!< 0 (No TZ1 event)   */
    GPIOMISC_BIT_TZ1SEL_GPIO0        = 1,  /*!< GPIO0              */
    GPIOMISC_BIT_TZ1SEL_GPIO5        = 2,  /*!< GPIO5              */
    GPIOMISC_BIT_TZ1SEL_GPIO10       = 3,  /*!< GPIO10             */
    GPIOMISC_BIT_TZ1SEL_GPIO15       = 4,  /*!< GPIO15             */
    GPIOMISC_BIT_TZ1SEL_GPIO20       = 5,  /*!< GPIO20             */
    GPIOMISC_BIT_TZ1SEL_GPIO25       = 6,  /*!< GPIO25             */
    GPIOMISC_BIT_TZ1SEL_GPIO30       = 7,  /*!< GPIO30             */
} GPIOMISC_BIT_TZ1SEL;

#define GPIOMISC_ALL_TZ1SEL_NO_EVENT     ((0x0UL) << GPIOMISC_ALL_TZ1SEL_Pos)
#define GPIOMISC_ALL_TZ1SEL_GPIO0        ((0x1UL) << GPIOMISC_ALL_TZ1SEL_Pos)
#define GPIOMISC_ALL_TZ1SEL_GPIO5        ((0x2UL) << GPIOMISC_ALL_TZ1SEL_Pos)
#define GPIOMISC_ALL_TZ1SEL_GPIO10       ((0x3UL) << GPIOMISC_ALL_TZ1SEL_Pos)
#define GPIOMISC_ALL_TZ1SEL_GPIO15       ((0x4UL) << GPIOMISC_ALL_TZ1SEL_Pos)
#define GPIOMISC_ALL_TZ1SEL_GPIO20       ((0x5UL) << GPIOMISC_ALL_TZ1SEL_Pos)
#define GPIOMISC_ALL_TZ1SEL_GPIO25       ((0x6UL) << GPIOMISC_ALL_TZ1SEL_Pos)
#define GPIOMISC_ALL_TZ1SEL_GPIO30       ((0x7UL) << GPIOMISC_ALL_TZ1SEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOMISC        TZ2SEL
 *  @access     GLOBAL->GPIOMISC.bit.TZ2SEL
 *  @brief      TZ2 event source select
 */
#define GPIOMISC_ALL_TZ2SEL_Pos (3)
#define GPIOMISC_ALL_TZ2SEL_Msk (0x7UL << GPIOMISC_ALL_TZ2SEL_Pos)

typedef enum
{
    GPIOMISC_BIT_TZ2SEL_NO_EVENT     = 0,  /*!< 0 (No TZ2 event)   */
    GPIOMISC_BIT_TZ2SEL_GPIO1        = 1,  /*!< GPIO1              */
    GPIOMISC_BIT_TZ2SEL_GPIO6        = 2,  /*!< GPIO6              */
    GPIOMISC_BIT_TZ2SEL_GPIO11       = 3,  /*!< GPIO11             */
    GPIOMISC_BIT_TZ2SEL_GPIO16       = 4,  /*!< GPIO16             */
    GPIOMISC_BIT_TZ2SEL_GPIO21       = 5,  /*!< GPIO21             */
    GPIOMISC_BIT_TZ2SEL_GPIO26       = 6,  /*!< GPIO26             */
    GPIOMISC_BIT_TZ2SEL_GPIO31       = 7,  /*!< GPIO31             */
} GPIOMISC_BIT_TZ2SEL;

#define GPIOMISC_ALL_TZ2SEL_NO_EVENT     ((0x0UL) << GPIOMISC_ALL_TZ2SEL_Pos)
#define GPIOMISC_ALL_TZ2SEL_GPIO1        ((0x1UL) << GPIOMISC_ALL_TZ2SEL_Pos)
#define GPIOMISC_ALL_TZ2SEL_GPIO6        ((0x2UL) << GPIOMISC_ALL_TZ2SEL_Pos)
#define GPIOMISC_ALL_TZ2SEL_GPIO11       ((0x3UL) << GPIOMISC_ALL_TZ2SEL_Pos)
#define GPIOMISC_ALL_TZ2SEL_GPIO16       ((0x4UL) << GPIOMISC_ALL_TZ2SEL_Pos)
#define GPIOMISC_ALL_TZ2SEL_GPIO21       ((0x5UL) << GPIOMISC_ALL_TZ2SEL_Pos)
#define GPIOMISC_ALL_TZ2SEL_GPIO26       ((0x6UL) << GPIOMISC_ALL_TZ2SEL_Pos)
#define GPIOMISC_ALL_TZ2SEL_GPIO31       ((0x7UL) << GPIOMISC_ALL_TZ2SEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOMISC        TZ3SEL
 *  @access     GLOBAL->GPIOMISC.bit.TZ3SEL
 *  @brief      TZ3 event source select
 */
#define GPIOMISC_ALL_TZ3SEL_Pos (6)
#define GPIOMISC_ALL_TZ3SEL_Msk (0x7UL << GPIOMISC_ALL_TZ3SEL_Pos)

typedef enum
{
    GPIOMISC_BIT_TZ3SEL_NO_EVENT     = 0,  /*!< 0 (No TZ3 event)   */
    GPIOMISC_BIT_TZ3SEL_GPIO2        = 1,  /*!< GPIO2              */
    GPIOMISC_BIT_TZ3SEL_GPIO7        = 2,  /*!< GPIO7              */
    GPIOMISC_BIT_TZ3SEL_GPIO12       = 3,  /*!< GPIO12             */
    GPIOMISC_BIT_TZ3SEL_GPIO17       = 4,  /*!< GPIO17             */
    GPIOMISC_BIT_TZ3SEL_GPIO22       = 5,  /*!< GPIO22             */
    GPIOMISC_BIT_TZ3SEL_GPIO27       = 6,  /*!< GPIO27             */
    GPIOMISC_BIT_TZ3SEL_GPIO32       = 7,  /*!< GPIO32             */
} GPIOMISC_BIT_TZ3SEL;

#define GPIOMISC_ALL_TZ3SEL_NO_EVENT     ((0x0UL) << GPIOMISC_ALL_TZ3SEL_Pos)
#define GPIOMISC_ALL_TZ3SEL_GPIO2        ((0x1UL) << GPIOMISC_ALL_TZ3SEL_Pos)
#define GPIOMISC_ALL_TZ3SEL_GPIO7        ((0x2UL) << GPIOMISC_ALL_TZ3SEL_Pos)
#define GPIOMISC_ALL_TZ3SEL_GPIO12       ((0x3UL) << GPIOMISC_ALL_TZ3SEL_Pos)
#define GPIOMISC_ALL_TZ3SEL_GPIO17       ((0x4UL) << GPIOMISC_ALL_TZ3SEL_Pos)
#define GPIOMISC_ALL_TZ3SEL_GPIO22       ((0x5UL) << GPIOMISC_ALL_TZ3SEL_Pos)
#define GPIOMISC_ALL_TZ3SEL_GPIO27       ((0x6UL) << GPIOMISC_ALL_TZ3SEL_Pos)
#define GPIOMISC_ALL_TZ3SEL_GPIO32       ((0x7UL) << GPIOMISC_ALL_TZ3SEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOMISC        TZ4SEL
 *  @access     GLOBAL->GPIOMISC.bit.TZ4SEL
 *  @brief      TZ4 event source select
 */
#define GPIOMISC_ALL_TZ4SEL_Pos (9)
#define GPIOMISC_ALL_TZ4SEL_Msk (0x7UL << GPIOMISC_ALL_TZ4SEL_Pos)

typedef enum
{
    GPIOMISC_BIT_TZ4SEL_NO_EVENT     = 0,  /*!< 0 (No TZ4 event)   */
    GPIOMISC_BIT_TZ4SEL_GPIO3        = 1,  /*!< GPIO3              */
    GPIOMISC_BIT_TZ4SEL_GPIO8        = 2,  /*!< GPIO8              */
    GPIOMISC_BIT_TZ4SEL_GPIO13       = 3,  /*!< GPIO13             */
    GPIOMISC_BIT_TZ4SEL_GPIO18       = 4,  /*!< GPIO18             */
    GPIOMISC_BIT_TZ4SEL_GPIO23       = 5,  /*!< GPIO23             */
    GPIOMISC_BIT_TZ4SEL_GPIO28       = 6,  /*!< GPIO28             */
    GPIOMISC_BIT_TZ4SEL_GPIO33       = 7,  /*!< GPIO33             */
} GPIOMISC_BIT_TZ4SEL;

#define GPIOMISC_ALL_TZ4SEL_NO_EVENT     ((0x0UL) << GPIOMISC_ALL_TZ4SEL_Pos)
#define GPIOMISC_ALL_TZ4SEL_GPIO3        ((0x1UL) << GPIOMISC_ALL_TZ4SEL_Pos)
#define GPIOMISC_ALL_TZ4SEL_GPIO8        ((0x2UL) << GPIOMISC_ALL_TZ4SEL_Pos)
#define GPIOMISC_ALL_TZ4SEL_GPIO13       ((0x3UL) << GPIOMISC_ALL_TZ4SEL_Pos)
#define GPIOMISC_ALL_TZ4SEL_GPIO18       ((0x4UL) << GPIOMISC_ALL_TZ4SEL_Pos)
#define GPIOMISC_ALL_TZ4SEL_GPIO23       ((0x5UL) << GPIOMISC_ALL_TZ4SEL_Pos)
#define GPIOMISC_ALL_TZ4SEL_GPIO28       ((0x6UL) << GPIOMISC_ALL_TZ4SEL_Pos)
#define GPIOMISC_ALL_TZ4SEL_GPIO33       ((0x7UL) << GPIOMISC_ALL_TZ4SEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOMISC        TZ5SEL
 *  @access     GLOBAL->GPIOMISC.bit.TZ5SEL
 *  @brief      TZ5 event source select
 */
#define GPIOMISC_ALL_TZ5SEL_Pos (12)
#define GPIOMISC_ALL_TZ5SEL_Msk (0x7UL << GPIOMISC_ALL_TZ5SEL_Pos)

typedef enum
{
    GPIOMISC_BIT_TZ5SEL_NO_EVENT     = 0,  /*!< 0 (No TZ5 event)   */
    GPIOMISC_BIT_TZ5SEL_GPIO4        = 1,  /*!< GPIO4              */
    GPIOMISC_BIT_TZ5SEL_GPIO9        = 2,  /*!< GPIO9              */
    GPIOMISC_BIT_TZ5SEL_GPIO14       = 3,  /*!< GPIO14             */
    GPIOMISC_BIT_TZ5SEL_GPIO19       = 4,  /*!< GPIO19             */
    GPIOMISC_BIT_TZ5SEL_GPIO24       = 5,  /*!< GPIO24             */
    GPIOMISC_BIT_TZ5SEL_GPIO29       = 6,  /*!< GPIO29             */
    GPIOMISC_BIT_TZ5SEL_GPIO34       = 7,  /*!< GPIO34             */
} GPIOMISC_BIT_TZ5SEL;

#define GPIOMISC_ALL_TZ5SEL_NO_EVENT     ((0x0UL) << GPIOMISC_ALL_TZ5SEL_Pos)
#define GPIOMISC_ALL_TZ5SEL_GPIO4        ((0x1UL) << GPIOMISC_ALL_TZ5SEL_Pos)
#define GPIOMISC_ALL_TZ5SEL_GPIO9        ((0x2UL) << GPIOMISC_ALL_TZ5SEL_Pos)
#define GPIOMISC_ALL_TZ5SEL_GPIO14       ((0x3UL) << GPIOMISC_ALL_TZ5SEL_Pos)
#define GPIOMISC_ALL_TZ5SEL_GPIO19       ((0x4UL) << GPIOMISC_ALL_TZ5SEL_Pos)
#define GPIOMISC_ALL_TZ5SEL_GPIO24       ((0x5UL) << GPIOMISC_ALL_TZ5SEL_Pos)
#define GPIOMISC_ALL_TZ5SEL_GPIO29       ((0x6UL) << GPIOMISC_ALL_TZ5SEL_Pos)
#define GPIOMISC_ALL_TZ5SEL_GPIO34       ((0x7UL) << GPIOMISC_ALL_TZ5SEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOMISC        ECAPSEL
 *  @access     GLOBAL->GPIOMISC.bit.ECAPSEL
 *  @brief      ECAP event source select
 */
#define GPIOMISC_ALL_ECAPSEL_Pos (15)
#define GPIOMISC_ALL_ECAPSEL_Msk (0x7FUL << GPIOMISC_ALL_ECAPSEL_Pos)

typedef enum
{
    GPIOMISC_BIT_ECAPSEL_NO_EVENT     = 0,  /*!< 0 (No ECAP event)   */
    GPIOMISC_BIT_ECAPSEL_GPIO0        = 1,  /*!< GPIO0               */
    GPIOMISC_BIT_ECAPSEL_GPIO1        = 2,  /*!< GPIO1               */
    GPIOMISC_BIT_ECAPSEL_GPIO2        = 3,  /*!< GPIO2               */
    GPIOMISC_BIT_ECAPSEL_GPIO3        = 4,  /*!< GPIO3               */
    GPIOMISC_BIT_ECAPSEL_GPIO4        = 5,  /*!< GPIO4               */
    GPIOMISC_BIT_ECAPSEL_GPIO5        = 6,  /*!< GPIO5               */
    GPIOMISC_BIT_ECAPSEL_GPIO6        = 7,  /*!< GPIO6               */
    GPIOMISC_BIT_ECAPSEL_GPIO7        = 8,  /*!< GPIO7               */
    GPIOMISC_BIT_ECAPSEL_GPIO8        = 9,  /*!< GPIO8               */
    GPIOMISC_BIT_ECAPSEL_GPIO9        = 10,  /*!< GPIO9               */
    GPIOMISC_BIT_ECAPSEL_GPIO10       = 11,  /*!< GPIO10              */
    GPIOMISC_BIT_ECAPSEL_GPIO11       = 12,  /*!< GPIO11              */
    GPIOMISC_BIT_ECAPSEL_GPIO12       = 13,  /*!< GPIO12              */
    GPIOMISC_BIT_ECAPSEL_GPIO13       = 14,  /*!< GPIO13              */
    GPIOMISC_BIT_ECAPSEL_GPIO14       = 15,  /*!< GPIO14              */
    GPIOMISC_BIT_ECAPSEL_GPIO15       = 16,  /*!< GPIO15              */
    GPIOMISC_BIT_ECAPSEL_GPIO16       = 17,  /*!< GPIO16              */
    GPIOMISC_BIT_ECAPSEL_GPIO17       = 18,  /*!< GPIO17              */
    GPIOMISC_BIT_ECAPSEL_GPIO18       = 19,  /*!< GPIO18              */
    GPIOMISC_BIT_ECAPSEL_GPIO19       = 20,  /*!< GPIO19              */
    GPIOMISC_BIT_ECAPSEL_GPIO20       = 21,  /*!< GPIO20              */
    GPIOMISC_BIT_ECAPSEL_GPIO21       = 22,  /*!< GPIO21              */
    GPIOMISC_BIT_ECAPSEL_GPIO22       = 23,  /*!< GPIO22              */
    GPIOMISC_BIT_ECAPSEL_GPIO23       = 24,  /*!< GPIO23              */
    GPIOMISC_BIT_ECAPSEL_GPIO24       = 25,  /*!< GPIO24              */
    GPIOMISC_BIT_ECAPSEL_GPIO25       = 26,  /*!< GPIO25              */
    GPIOMISC_BIT_ECAPSEL_GPIO26       = 27,  /*!< GPIO26              */
    GPIOMISC_BIT_ECAPSEL_GPIO27       = 28,  /*!< GPIO27              */
    GPIOMISC_BIT_ECAPSEL_GPIO28       = 29,  /*!< GPIO28              */
    GPIOMISC_BIT_ECAPSEL_GPIO29       = 30,  /*!< GPIO29              */
    GPIOMISC_BIT_ECAPSEL_GPIO30       = 31,  /*!< GPIO30              */
    GPIOMISC_BIT_ECAPSEL_GPIO31       = 32,  /*!< GPIO31              */
    GPIOMISC_BIT_ECAPSEL_GPIO32       = 33,  /*!< GPIO32              */
    GPIOMISC_BIT_ECAPSEL_GPIO33       = 34,  /*!< GPIO33              */
    GPIOMISC_BIT_ECAPSEL_GPIO34       = 35,  /*!< GPIO34              */
    GPIOMISC_BIT_ECAPSEL_GPIO35       = 36,  /*!< GPIO35              */
} GPIOMISC_BIT_ECAPSEL;

#define GPIOMISC_ALL_ECAPSEL_NO_EVENT     ((0x00UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO0        ((0x01UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO1        ((0x02UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO2        ((0x03UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO3        ((0x04UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO4        ((0x05UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO5        ((0x06UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO6        ((0x07UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO7        ((0x08UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO8        ((0x09UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO9        ((0x0AUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO10       ((0x0BUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO11       ((0x0CUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO12       ((0x0DUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO13       ((0x0EUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO14       ((0x0FUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO15       ((0x10UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO16       ((0x11UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO17       ((0x12UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO18       ((0x13UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO19       ((0x14UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO20       ((0x15UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO21       ((0x16UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO22       ((0x17UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO23       ((0x18UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO24       ((0x19UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO25       ((0x1AUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO26       ((0x1BUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO27       ((0x1CUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO28       ((0x1DUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO29       ((0x1EUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO30       ((0x1FUL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO31       ((0x20UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO32       ((0x21UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO33       ((0x22UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO34       ((0x23UL) << GPIOMISC_ALL_ECAPSEL_Pos)
#define GPIOMISC_ALL_ECAPSEL_GPIO35       ((0x24UL) << GPIOMISC_ALL_ECAPSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          GPIOMISC        EXTSOCSEL
 *  @access     GLOBAL->GPIOMISC.bit.EXTSOCSEL
 *  @brief      EXTSOC event source select
 */
#define GPIOMISC_ALL_EXTSOCSEL_Pos (22)
#define GPIOMISC_ALL_EXTSOCSEL_Msk (0x7FUL << GPIOMISC_ALL_EXTSOCSEL_Pos)

typedef enum
{
    GPIOMISC_BIT_EXTSOCSEL_NO_EVENT     = 0,  /*!< 0 (No EXTSOC event)   */
    GPIOMISC_BIT_EXTSOCSEL_GPIO0        = 1,  /*!< GPIO0                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO1        = 2,  /*!< GPIO1                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO2        = 3,  /*!< GPIO2                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO3        = 4,  /*!< GPIO3                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO4        = 5,  /*!< GPIO4                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO5        = 6,  /*!< GPIO5                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO6        = 7,  /*!< GPIO6                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO7        = 8,  /*!< GPIO7                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO8        = 9,  /*!< GPIO8                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO9        = 10,  /*!< GPIO9                 */
    GPIOMISC_BIT_EXTSOCSEL_GPIO10       = 11,  /*!< GPIO10                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO11       = 12,  /*!< GPIO11                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO12       = 13,  /*!< GPIO12                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO13       = 14,  /*!< GPIO13                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO14       = 15,  /*!< GPIO14                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO15       = 16,  /*!< GPIO15                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO16       = 17,  /*!< GPIO16                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO17       = 18,  /*!< GPIO17                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO18       = 19,  /*!< GPIO18                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO19       = 20,  /*!< GPIO19                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO20       = 21,  /*!< GPIO20                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO21       = 22,  /*!< GPIO21                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO22       = 23,  /*!< GPIO22                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO23       = 24,  /*!< GPIO23                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO24       = 25,  /*!< GPIO24                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO25       = 26,  /*!< GPIO25                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO26       = 27,  /*!< GPIO26                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO27       = 28,  /*!< GPIO27                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO28       = 29,  /*!< GPIO28                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO29       = 30,  /*!< GPIO29                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO30       = 31,  /*!< GPIO30                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO31       = 32,  /*!< GPIO31                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO32       = 33,  /*!< GPIO32                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO33       = 34,  /*!< GPIO33                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO34       = 35,  /*!< GPIO34                */
    GPIOMISC_BIT_EXTSOCSEL_GPIO35       = 36,  /*!< GPIO35                */
} GPIOMISC_BIT_EXTSOCSEL;

#define GPIOMISC_ALL_EXTSOCSEL_NO_EVENT     ((0x00UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO0        ((0x01UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO1        ((0x02UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO2        ((0x03UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO3        ((0x04UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO4        ((0x05UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO5        ((0x06UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO6        ((0x07UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO7        ((0x08UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO8        ((0x09UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO9        ((0x0AUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO10       ((0x0BUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO11       ((0x0CUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO12       ((0x0DUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO13       ((0x0EUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO14       ((0x0FUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO15       ((0x10UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO16       ((0x11UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO17       ((0x12UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO18       ((0x13UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO19       ((0x14UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO20       ((0x15UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO21       ((0x16UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO22       ((0x17UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO23       ((0x18UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO24       ((0x19UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO25       ((0x1AUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO26       ((0x1BUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO27       ((0x1CUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO28       ((0x1DUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO29       ((0x1EUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO30       ((0x1FUL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO31       ((0x20UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO32       ((0x21UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO33       ((0x22UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO34       ((0x23UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)
#define GPIOMISC_ALL_EXTSOCSEL_GPIO35       ((0x24UL) << GPIOMISC_ALL_EXTSOCSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          TMREXTSEL       TMR0
 *  @access     GLOBAL->TMREXTSEL.bit.TMR0
 *  @brief      TIMER0 event source select
 */
#define TMREXTSEL_ALL_TMR0_Pos (0)
#define TMREXTSEL_ALL_TMR0_Msk (0x7FUL << TMREXTSEL_ALL_TMR0_Pos)

typedef enum
{
    TMREXTSEL_BIT_TMR0_NO_EVENT     = 0,  /*!< 0 (No TIMER0 event)   */
    TMREXTSEL_BIT_TMR0_GPIO0        = 1,  /*!< GPIO0                 */
    TMREXTSEL_BIT_TMR0_GPIO1        = 2,  /*!< GPIO1                 */
    TMREXTSEL_BIT_TMR0_GPIO2        = 3,  /*!< GPIO2                 */
    TMREXTSEL_BIT_TMR0_GPIO3        = 4,  /*!< GPIO3                 */
    TMREXTSEL_BIT_TMR0_GPIO4        = 5,  /*!< GPIO4                 */
    TMREXTSEL_BIT_TMR0_GPIO5        = 6,  /*!< GPIO5                 */
    TMREXTSEL_BIT_TMR0_GPIO6        = 7,  /*!< GPIO6                 */
    TMREXTSEL_BIT_TMR0_GPIO7        = 8,  /*!< GPIO7                 */
    TMREXTSEL_BIT_TMR0_GPIO8        = 9,  /*!< GPIO8                 */
    TMREXTSEL_BIT_TMR0_GPIO9        = 10,  /*!< GPIO9                 */
    TMREXTSEL_BIT_TMR0_GPIO10       = 11,  /*!< GPIO10                */
    TMREXTSEL_BIT_TMR0_GPIO11       = 12,  /*!< GPIO11                */
    TMREXTSEL_BIT_TMR0_GPIO12       = 13,  /*!< GPIO12                */
    TMREXTSEL_BIT_TMR0_GPIO13       = 14,  /*!< GPIO13                */
    TMREXTSEL_BIT_TMR0_GPIO14       = 15,  /*!< GPIO14                */
    TMREXTSEL_BIT_TMR0_GPIO15       = 16,  /*!< GPIO15                */
    TMREXTSEL_BIT_TMR0_GPIO16       = 17,  /*!< GPIO16                */
    TMREXTSEL_BIT_TMR0_GPIO17       = 18,  /*!< GPIO17                */
    TMREXTSEL_BIT_TMR0_GPIO18       = 19,  /*!< GPIO18                */
    TMREXTSEL_BIT_TMR0_GPIO19       = 20,  /*!< GPIO19                */
    TMREXTSEL_BIT_TMR0_GPIO20       = 21,  /*!< GPIO20                */
    TMREXTSEL_BIT_TMR0_GPIO21       = 22,  /*!< GPIO21                */
    TMREXTSEL_BIT_TMR0_GPIO22       = 23,  /*!< GPIO22                */
    TMREXTSEL_BIT_TMR0_GPIO23       = 24,  /*!< GPIO23                */
    TMREXTSEL_BIT_TMR0_GPIO24       = 25,  /*!< GPIO24                */
    TMREXTSEL_BIT_TMR0_GPIO25       = 26,  /*!< GPIO25                */
    TMREXTSEL_BIT_TMR0_GPIO26       = 27,  /*!< GPIO26                */
    TMREXTSEL_BIT_TMR0_GPIO27       = 28,  /*!< GPIO27                */
    TMREXTSEL_BIT_TMR0_GPIO28       = 29,  /*!< GPIO28                */
    TMREXTSEL_BIT_TMR0_GPIO29       = 30,  /*!< GPIO29                */
    TMREXTSEL_BIT_TMR0_GPIO30       = 31,  /*!< GPIO30                */
    TMREXTSEL_BIT_TMR0_GPIO31       = 32,  /*!< GPIO31                */
    TMREXTSEL_BIT_TMR0_GPIO32       = 33,  /*!< GPIO32                */
    TMREXTSEL_BIT_TMR0_GPIO33       = 34,  /*!< GPIO33                */
    TMREXTSEL_BIT_TMR0_GPIO34       = 35,  /*!< GPIO34                */
    TMREXTSEL_BIT_TMR0_GPIO35       = 36,  /*!< GPIO35                */
} TMREXTSEL_BIT_TMR0;

#define TMREXTSEL_ALL_TMR0_NO_EVENT     ((0x00UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO0        ((0x01UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO1        ((0x02UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO2        ((0x03UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO3        ((0x04UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO4        ((0x05UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO5        ((0x06UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO6        ((0x07UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO7        ((0x08UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO8        ((0x09UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO9        ((0x0AUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO10       ((0x0BUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO11       ((0x0CUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO12       ((0x0DUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO13       ((0x0EUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO14       ((0x0FUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO15       ((0x10UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO16       ((0x11UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO17       ((0x12UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO18       ((0x13UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO19       ((0x14UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO20       ((0x15UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO21       ((0x16UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO22       ((0x17UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO23       ((0x18UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO24       ((0x19UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO25       ((0x1AUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO26       ((0x1BUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO27       ((0x1CUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO28       ((0x1DUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO29       ((0x1EUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO30       ((0x1FUL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO31       ((0x20UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO32       ((0x21UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO33       ((0x22UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO34       ((0x23UL) << TMREXTSEL_ALL_TMR0_Pos)
#define TMREXTSEL_ALL_TMR0_GPIO35       ((0x24UL) << TMREXTSEL_ALL_TMR0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          TMREXTSEL       TMR1
 *  @access     GLOBAL->TMREXTSEL.bit.TMR1
 *  @brief      TIMER1 event source select
 */
#define TMREXTSEL_ALL_TMR1_Pos (7)
#define TMREXTSEL_ALL_TMR1_Msk (0x7FUL << TMREXTSEL_ALL_TMR1_Pos)

typedef enum
{
    TMREXTSEL_BIT_TMR1_NO_EVENT     = 0,  /*!< 0 (No TIMER1 event)   */
    TMREXTSEL_BIT_TMR1_GPIO0        = 1,  /*!< GPIO0                 */
    TMREXTSEL_BIT_TMR1_GPIO1        = 2,  /*!< GPIO1                 */
    TMREXTSEL_BIT_TMR1_GPIO2        = 3,  /*!< GPIO2                 */
    TMREXTSEL_BIT_TMR1_GPIO3        = 4,  /*!< GPIO3                 */
    TMREXTSEL_BIT_TMR1_GPIO4        = 5,  /*!< GPIO4                 */
    TMREXTSEL_BIT_TMR1_GPIO5        = 6,  /*!< GPIO5                 */
    TMREXTSEL_BIT_TMR1_GPIO6        = 7,  /*!< GPIO6                 */
    TMREXTSEL_BIT_TMR1_GPIO7        = 8,  /*!< GPIO7                 */
    TMREXTSEL_BIT_TMR1_GPIO8        = 9,  /*!< GPIO8                 */
    TMREXTSEL_BIT_TMR1_GPIO9        = 10,  /*!< GPIO9                 */
    TMREXTSEL_BIT_TMR1_GPIO10       = 11,  /*!< GPIO10                */
    TMREXTSEL_BIT_TMR1_GPIO11       = 12,  /*!< GPIO11                */
    TMREXTSEL_BIT_TMR1_GPIO12       = 13,  /*!< GPIO12                */
    TMREXTSEL_BIT_TMR1_GPIO13       = 14,  /*!< GPIO13                */
    TMREXTSEL_BIT_TMR1_GPIO14       = 15,  /*!< GPIO14                */
    TMREXTSEL_BIT_TMR1_GPIO15       = 16,  /*!< GPIO15                */
    TMREXTSEL_BIT_TMR1_GPIO16       = 17,  /*!< GPIO16                */
    TMREXTSEL_BIT_TMR1_GPIO17       = 18,  /*!< GPIO17                */
    TMREXTSEL_BIT_TMR1_GPIO18       = 19,  /*!< GPIO18                */
    TMREXTSEL_BIT_TMR1_GPIO19       = 20,  /*!< GPIO19                */
    TMREXTSEL_BIT_TMR1_GPIO20       = 21,  /*!< GPIO20                */
    TMREXTSEL_BIT_TMR1_GPIO21       = 22,  /*!< GPIO21                */
    TMREXTSEL_BIT_TMR1_GPIO22       = 23,  /*!< GPIO22                */
    TMREXTSEL_BIT_TMR1_GPIO23       = 24,  /*!< GPIO23                */
    TMREXTSEL_BIT_TMR1_GPIO24       = 25,  /*!< GPIO24                */
    TMREXTSEL_BIT_TMR1_GPIO25       = 26,  /*!< GPIO25                */
    TMREXTSEL_BIT_TMR1_GPIO26       = 27,  /*!< GPIO26                */
    TMREXTSEL_BIT_TMR1_GPIO27       = 28,  /*!< GPIO27                */
    TMREXTSEL_BIT_TMR1_GPIO28       = 29,  /*!< GPIO28                */
    TMREXTSEL_BIT_TMR1_GPIO29       = 30,  /*!< GPIO29                */
    TMREXTSEL_BIT_TMR1_GPIO30       = 31,  /*!< GPIO30                */
    TMREXTSEL_BIT_TMR1_GPIO31       = 32,  /*!< GPIO31                */
    TMREXTSEL_BIT_TMR1_GPIO32       = 33,  /*!< GPIO32                */
    TMREXTSEL_BIT_TMR1_GPIO33       = 34,  /*!< GPIO33                */
    TMREXTSEL_BIT_TMR1_GPIO34       = 35,  /*!< GPIO34                */
    TMREXTSEL_BIT_TMR1_GPIO35       = 36,  /*!< GPIO35                */
} TMREXTSEL_BIT_TMR1;

#define TMREXTSEL_ALL_TMR1_NO_EVENT     ((0x00UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO0        ((0x01UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO1        ((0x02UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO2        ((0x03UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO3        ((0x04UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO4        ((0x05UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO5        ((0x06UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO6        ((0x07UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO7        ((0x08UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO8        ((0x09UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO9        ((0x0AUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO10       ((0x0BUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO11       ((0x0CUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO12       ((0x0DUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO13       ((0x0EUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO14       ((0x0FUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO15       ((0x10UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO16       ((0x11UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO17       ((0x12UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO18       ((0x13UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO19       ((0x14UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO20       ((0x15UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO21       ((0x16UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO22       ((0x17UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO23       ((0x18UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO24       ((0x19UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO25       ((0x1AUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO26       ((0x1BUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO27       ((0x1CUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO28       ((0x1DUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO29       ((0x1EUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO30       ((0x1FUL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO31       ((0x20UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO32       ((0x21UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO33       ((0x22UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO34       ((0x23UL) << TMREXTSEL_ALL_TMR1_Pos)
#define TMREXTSEL_ALL_TMR1_GPIO35       ((0x24UL) << TMREXTSEL_ALL_TMR1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          TMREXTSEL       TMR2
 *  @access     GLOBAL->TMREXTSEL.bit.TMR2
 *  @brief      TIMER2 event source select
 */
#define TMREXTSEL_ALL_TMR2_Pos (14)
#define TMREXTSEL_ALL_TMR2_Msk (0x7FUL << TMREXTSEL_ALL_TMR2_Pos)

typedef enum
{
    TMREXTSEL_BIT_TMR2_NO_EVENT     = 0,  /*!< 0 (No TIMER2 event)   */
    TMREXTSEL_BIT_TMR2_GPIO0        = 1,  /*!< GPIO0                 */
    TMREXTSEL_BIT_TMR2_GPIO1        = 2,  /*!< GPIO1                 */
    TMREXTSEL_BIT_TMR2_GPIO2        = 3,  /*!< GPIO2                 */
    TMREXTSEL_BIT_TMR2_GPIO3        = 4,  /*!< GPIO3                 */
    TMREXTSEL_BIT_TMR2_GPIO4        = 5,  /*!< GPIO4                 */
    TMREXTSEL_BIT_TMR2_GPIO5        = 6,  /*!< GPIO5                 */
    TMREXTSEL_BIT_TMR2_GPIO6        = 7,  /*!< GPIO6                 */
    TMREXTSEL_BIT_TMR2_GPIO7        = 8,  /*!< GPIO7                 */
    TMREXTSEL_BIT_TMR2_GPIO8        = 9,  /*!< GPIO8                 */
    TMREXTSEL_BIT_TMR2_GPIO9        = 10,  /*!< GPIO9                 */
    TMREXTSEL_BIT_TMR2_GPIO10       = 11,  /*!< GPIO10                */
    TMREXTSEL_BIT_TMR2_GPIO11       = 12,  /*!< GPIO11                */
    TMREXTSEL_BIT_TMR2_GPIO12       = 13,  /*!< GPIO12                */
    TMREXTSEL_BIT_TMR2_GPIO13       = 14,  /*!< GPIO13                */
    TMREXTSEL_BIT_TMR2_GPIO14       = 15,  /*!< GPIO14                */
    TMREXTSEL_BIT_TMR2_GPIO15       = 16,  /*!< GPIO15                */
    TMREXTSEL_BIT_TMR2_GPIO16       = 17,  /*!< GPIO16                */
    TMREXTSEL_BIT_TMR2_GPIO17       = 18,  /*!< GPIO17                */
    TMREXTSEL_BIT_TMR2_GPIO18       = 19,  /*!< GPIO18                */
    TMREXTSEL_BIT_TMR2_GPIO19       = 20,  /*!< GPIO19                */
    TMREXTSEL_BIT_TMR2_GPIO20       = 21,  /*!< GPIO20                */
    TMREXTSEL_BIT_TMR2_GPIO21       = 22,  /*!< GPIO21                */
    TMREXTSEL_BIT_TMR2_GPIO22       = 23,  /*!< GPIO22                */
    TMREXTSEL_BIT_TMR2_GPIO23       = 24,  /*!< GPIO23                */
    TMREXTSEL_BIT_TMR2_GPIO24       = 25,  /*!< GPIO24                */
    TMREXTSEL_BIT_TMR2_GPIO25       = 26,  /*!< GPIO25                */
    TMREXTSEL_BIT_TMR2_GPIO26       = 27,  /*!< GPIO26                */
    TMREXTSEL_BIT_TMR2_GPIO27       = 28,  /*!< GPIO27                */
    TMREXTSEL_BIT_TMR2_GPIO28       = 29,  /*!< GPIO28                */
    TMREXTSEL_BIT_TMR2_GPIO29       = 30,  /*!< GPIO29                */
    TMREXTSEL_BIT_TMR2_GPIO30       = 31,  /*!< GPIO30                */
    TMREXTSEL_BIT_TMR2_GPIO31       = 32,  /*!< GPIO31                */
    TMREXTSEL_BIT_TMR2_GPIO32       = 33,  /*!< GPIO32                */
    TMREXTSEL_BIT_TMR2_GPIO33       = 34,  /*!< GPIO33                */
    TMREXTSEL_BIT_TMR2_GPIO34       = 35,  /*!< GPIO34                */
    TMREXTSEL_BIT_TMR2_GPIO35       = 36,  /*!< GPIO35                */
} TMREXTSEL_BIT_TMR2;

#define TMREXTSEL_ALL_TMR2_NO_EVENT     ((0x00UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO0        ((0x01UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO1        ((0x02UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO2        ((0x03UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO3        ((0x04UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO4        ((0x05UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO5        ((0x06UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO6        ((0x07UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO7        ((0x08UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO8        ((0x09UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO9        ((0x0AUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO10       ((0x0BUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO11       ((0x0CUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO12       ((0x0DUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO13       ((0x0EUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO14       ((0x0FUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO15       ((0x10UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO16       ((0x11UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO17       ((0x12UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO18       ((0x13UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO19       ((0x14UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO20       ((0x15UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO21       ((0x16UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO22       ((0x17UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO23       ((0x18UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO24       ((0x19UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO25       ((0x1AUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO26       ((0x1BUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO27       ((0x1CUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO28       ((0x1DUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO29       ((0x1EUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO30       ((0x1FUL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO31       ((0x20UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO32       ((0x21UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO33       ((0x22UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO34       ((0x23UL) << TMREXTSEL_ALL_TMR2_Pos)
#define TMREXTSEL_ALL_TMR2_GPIO35       ((0x24UL) << TMREXTSEL_ALL_TMR2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          PWMFRCSYNC      PWM0SYNC
 *  @access     GLOBAL->PWMFRCSYNC.bit.PWM0SYNC
 *  @brief      Software forced synchronization on PWM0
 */
#define PWMFRCSYNC_ALL_PWM0SYNC_Pos (0)
#define PWMFRCSYNC_ALL_PWM0SYNC_Msk (0x1UL << PWMFRCSYNC_ALL_PWM0SYNC_Pos)

typedef enum
{
    PWMFRCSYNC_BIT_PWM0SYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect.                    
                                                     Always readback 0                            */
    PWMFRCSYNC_BIT_PWM0SYNC_ENABLE        = 1,  /*!< Write a 1 will force a SYNC event on PWM0.  
                                                     This bit is self-cleared                     */
} PWMFRCSYNC_BIT_PWM0SYNC;

#define PWMFRCSYNC_ALL_PWM0SYNC_NO_EFFECT     ((0x0UL) << PWMFRCSYNC_ALL_PWM0SYNC_Pos)
#define PWMFRCSYNC_ALL_PWM0SYNC_ENABLE        ((0x1UL) << PWMFRCSYNC_ALL_PWM0SYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          PWMFRCSYNC      PWM1SYNC
 *  @access     GLOBAL->PWMFRCSYNC.bit.PWM1SYNC
 *  @brief      Software forced synchronization on PWM1
 */
#define PWMFRCSYNC_ALL_PWM1SYNC_Pos (1)
#define PWMFRCSYNC_ALL_PWM1SYNC_Msk (0x1UL << PWMFRCSYNC_ALL_PWM1SYNC_Pos)

typedef enum
{
    PWMFRCSYNC_BIT_PWM1SYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect.                    
                                                     Always readback 0                            */
    PWMFRCSYNC_BIT_PWM1SYNC_ENABLE        = 1,  /*!< Write a 1 will force a SYNC event on PWM1.  
                                                     This bit is self-cleared                     */
} PWMFRCSYNC_BIT_PWM1SYNC;

#define PWMFRCSYNC_ALL_PWM1SYNC_NO_EFFECT     ((0x0UL) << PWMFRCSYNC_ALL_PWM1SYNC_Pos)
#define PWMFRCSYNC_ALL_PWM1SYNC_ENABLE        ((0x1UL) << PWMFRCSYNC_ALL_PWM1SYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          PWMFRCSYNC      PWM2SYNC
 *  @access     GLOBAL->PWMFRCSYNC.bit.PWM2SYNC
 *  @brief      Software forced synchronization on PWM2
 */
#define PWMFRCSYNC_ALL_PWM2SYNC_Pos (2)
#define PWMFRCSYNC_ALL_PWM2SYNC_Msk (0x1UL << PWMFRCSYNC_ALL_PWM2SYNC_Pos)

typedef enum
{
    PWMFRCSYNC_BIT_PWM2SYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect.                    
                                                     Always readback 0                            */
    PWMFRCSYNC_BIT_PWM2SYNC_ENABLE        = 1,  /*!< Write a 1 will force a SYNC event on PWM2.  
                                                     This bit is self-cleared                     */
} PWMFRCSYNC_BIT_PWM2SYNC;

#define PWMFRCSYNC_ALL_PWM2SYNC_NO_EFFECT     ((0x0UL) << PWMFRCSYNC_ALL_PWM2SYNC_Pos)
#define PWMFRCSYNC_ALL_PWM2SYNC_ENABLE        ((0x1UL) << PWMFRCSYNC_ALL_PWM2SYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          PWMFRCSYNC      PWM3SYNC
 *  @access     GLOBAL->PWMFRCSYNC.bit.PWM3SYNC
 *  @brief      Software forced synchronization on PWM3
 */
#define PWMFRCSYNC_ALL_PWM3SYNC_Pos (3)
#define PWMFRCSYNC_ALL_PWM3SYNC_Msk (0x1UL << PWMFRCSYNC_ALL_PWM3SYNC_Pos)

typedef enum
{
    PWMFRCSYNC_BIT_PWM3SYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect.                    
                                                     Always readback 0                            */
    PWMFRCSYNC_BIT_PWM3SYNC_ENABLE        = 1,  /*!< Write a 1 will force a SYNC event on PWM3.  
                                                     This bit is self-cleared                     */
} PWMFRCSYNC_BIT_PWM3SYNC;

#define PWMFRCSYNC_ALL_PWM3SYNC_NO_EFFECT     ((0x0UL) << PWMFRCSYNC_ALL_PWM3SYNC_Pos)
#define PWMFRCSYNC_ALL_PWM3SYNC_ENABLE        ((0x1UL) << PWMFRCSYNC_ALL_PWM3SYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          PWMFRCSYNC      PWM4SYNC
 *  @access     GLOBAL->PWMFRCSYNC.bit.PWM4SYNC
 *  @brief      Software forced synchronization on PWM4
 */
#define PWMFRCSYNC_ALL_PWM4SYNC_Pos (4)
#define PWMFRCSYNC_ALL_PWM4SYNC_Msk (0x1UL << PWMFRCSYNC_ALL_PWM4SYNC_Pos)

typedef enum
{
    PWMFRCSYNC_BIT_PWM4SYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect.                    
                                                     Always readback 0                            */
    PWMFRCSYNC_BIT_PWM4SYNC_ENABLE        = 1,  /*!< Write a 1 will force a SYNC event on PWM4.  
                                                     This bit is self-cleared                     */
} PWMFRCSYNC_BIT_PWM4SYNC;

#define PWMFRCSYNC_ALL_PWM4SYNC_NO_EFFECT     ((0x0UL) << PWMFRCSYNC_ALL_PWM4SYNC_Pos)
#define PWMFRCSYNC_ALL_PWM4SYNC_ENABLE        ((0x1UL) << PWMFRCSYNC_ALL_PWM4SYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          PWMFRCSYNC      PWM5SYNC
 *  @access     GLOBAL->PWMFRCSYNC.bit.PWM5SYNC
 *  @brief      Software forced synchronization on PWM5
 */
#define PWMFRCSYNC_ALL_PWM5SYNC_Pos (5)
#define PWMFRCSYNC_ALL_PWM5SYNC_Msk (0x1UL << PWMFRCSYNC_ALL_PWM5SYNC_Pos)

typedef enum
{
    PWMFRCSYNC_BIT_PWM5SYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect.                    
                                                     Always readback 0                            */
    PWMFRCSYNC_BIT_PWM5SYNC_ENABLE        = 1,  /*!< Write a 1 will force a SYNC event on PWM5.  
                                                     This bit is self-cleared                     */
} PWMFRCSYNC_BIT_PWM5SYNC;

#define PWMFRCSYNC_ALL_PWM5SYNC_NO_EFFECT     ((0x0UL) << PWMFRCSYNC_ALL_PWM5SYNC_Pos)
#define PWMFRCSYNC_ALL_PWM5SYNC_ENABLE        ((0x1UL) << PWMFRCSYNC_ALL_PWM5SYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   GLOBAL          PWMFRCSYNC      PWM6SYNC
 *  @access     GLOBAL->PWMFRCSYNC.bit.PWM6SYNC
 *  @brief      Software forced synchronization on PWM6
 */
#define PWMFRCSYNC_ALL_PWM6SYNC_Pos (6)
#define PWMFRCSYNC_ALL_PWM6SYNC_Msk (0x1UL << PWMFRCSYNC_ALL_PWM6SYNC_Pos)

typedef enum
{
    PWMFRCSYNC_BIT_PWM6SYNC_NO_EFFECT     = 0,  /*!< Write a 0 has no effect.                    
                                                     Always readback 0                            */
    PWMFRCSYNC_BIT_PWM6SYNC_ENABLE        = 1,  /*!< Write a 1 will force a SYNC event on PWM6.  
                                                     This bit is self-cleared                     */
} PWMFRCSYNC_BIT_PWM6SYNC;

#define PWMFRCSYNC_ALL_PWM6SYNC_NO_EFFECT     ((0x0UL) << PWMFRCSYNC_ALL_PWM6SYNC_Pos)
#define PWMFRCSYNC_ALL_PWM6SYNC_ENABLE        ((0x1UL) << PWMFRCSYNC_ALL_PWM6SYNC_Pos)





/********************************************************************************
*
* Module Name     POWER
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BGCTL           TEMPTRIM
 *  @access     POWER->BGCTL.bit.TEMPTRIM
 *  @brief      SYSBG temperature coefficient trimming
 *              Optimize this code to minimize temperature dependency
 */
#define BGCTL_ALL_TEMPTRIM_Pos (1)
#define BGCTL_ALL_TEMPTRIM_Msk (0xFUL << BGCTL_ALL_TEMPTRIM_Pos)

#define BGCTL_BIT_TEMPTRIM

#define BGCTL_ALL_TEMPTRIM_(x) ((x) << BGCTL_ALL_TEMPTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BGCTL           ADCBGDIS
 *  @access     POWER->BGCTL.bit.ADCBGDIS
 *  @brief      ADCBG disable
 */
#define BGCTL_ALL_ADCBGDIS_Pos (5)
#define BGCTL_ALL_ADCBGDIS_Msk (0x1UL << BGCTL_ALL_ADCBGDIS_Pos)

typedef enum
{
    BGCTL_BIT_ADCBGDIS_ENABLE_ADC_BANDGAP      = 0,  /*!< Enable ADC bandgap    */
    BGCTL_BIT_ADCBGDIS_DISABLE_ADC_BANDGAP     = 1,  /*!< Disable ADC bandgap   */
} BGCTL_BIT_ADCBGDIS;

#define BGCTL_ALL_ADCBGDIS_ENABLE_ADC_BANDGAP      ((0x0UL) << BGCTL_ALL_ADCBGDIS_Pos)
#define BGCTL_ALL_ADCBGDIS_DISABLE_ADC_BANDGAP     ((0x1UL) << BGCTL_ALL_ADCBGDIS_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BGCTL           ADCBGTEMPTRIM
 *  @access     POWER->BGCTL.bit.ADCBGTEMPTRIM
 *  @brief      ADCBG temperature coefficient trimming
 *              Optimize this code to minimize temperature dependency
 */
#define BGCTL_ALL_ADCBGTEMPTRIM_Pos (6)
#define BGCTL_ALL_ADCBGTEMPTRIM_Msk (0xFUL << BGCTL_ALL_ADCBGTEMPTRIM_Pos)

#define BGCTL_BIT_ADCBGTEMPTRIM

#define BGCTL_ALL_ADCBGTEMPTRIM_(x) ((x) << BGCTL_ALL_ADCBGTEMPTRIM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    HIBODEN
 *  @access     POWER->BODVCAP12CTL.bit.HIBODEN
 *  @brief      VCAP12_TOO_HIGH BOD enable
 */
#define BODVCAP12CTL_ALL_HIBODEN_Pos (0)
#define BODVCAP12CTL_ALL_HIBODEN_Msk (0x1UL << BODVCAP12CTL_ALL_HIBODEN_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_HIBODEN_DISABLE     = 0,  /*!< Disable   */
    BODVCAP12CTL_BIT_HIBODEN_ENABLE      = 1,  /*!< Enable    */
} BODVCAP12CTL_BIT_HIBODEN;

#define BODVCAP12CTL_ALL_HIBODEN_DISABLE     ((0x0UL) << BODVCAP12CTL_ALL_HIBODEN_Pos)
#define BODVCAP12CTL_ALL_HIBODEN_ENABLE      ((0x1UL) << BODVCAP12CTL_ALL_HIBODEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    LOBODEN
 *  @access     POWER->BODVCAP12CTL.bit.LOBODEN
 *  @brief      VCAP12_TOO_LOW BOD enable
 */
#define BODVCAP12CTL_ALL_LOBODEN_Pos (1)
#define BODVCAP12CTL_ALL_LOBODEN_Msk (0x1UL << BODVCAP12CTL_ALL_LOBODEN_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_LOBODEN_DISABLE     = 0,  /*!< Disable   */
    BODVCAP12CTL_BIT_LOBODEN_ENABLE      = 1,  /*!< Enable    */
} BODVCAP12CTL_BIT_LOBODEN;

#define BODVCAP12CTL_ALL_LOBODEN_DISABLE     ((0x0UL) << BODVCAP12CTL_ALL_LOBODEN_Pos)
#define BODVCAP12CTL_ALL_LOBODEN_ENABLE      ((0x1UL) << BODVCAP12CTL_ALL_LOBODEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    HIBODOM
 *  @access     POWER->BODVCAP12CTL.bit.HIBODOM
 *  @brief      VCAP12_TOO_HIGH BOD output mask
 */
#define BODVCAP12CTL_ALL_HIBODOM_Pos (2)
#define BODVCAP12CTL_ALL_HIBODOM_Msk (0x1UL << BODVCAP12CTL_ALL_HIBODOM_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_HIBODOM_UNMASK     = 0,  /*!< VCAP12_TOO_HIGH follows the BOD result   */
    BODVCAP12CTL_BIT_HIBODOM_MASK       = 1,  /*!< VCAP12_TOO_HIGH is masked as 0           */
} BODVCAP12CTL_BIT_HIBODOM;

#define BODVCAP12CTL_ALL_HIBODOM_UNMASK     ((0x0UL) << BODVCAP12CTL_ALL_HIBODOM_Pos)
#define BODVCAP12CTL_ALL_HIBODOM_MASK       ((0x1UL) << BODVCAP12CTL_ALL_HIBODOM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    LOBODOM
 *  @access     POWER->BODVCAP12CTL.bit.LOBODOM
 *  @brief      VCAP12_TOO_LOW BOD output mask
 */
#define BODVCAP12CTL_ALL_LOBODOM_Pos (3)
#define BODVCAP12CTL_ALL_LOBODOM_Msk (0x1UL << BODVCAP12CTL_ALL_LOBODOM_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_LOBODOM_UNMASK     = 0,  /*!< VCAP12_TOO_LOW follows the BOD result   */
    BODVCAP12CTL_BIT_LOBODOM_MASK       = 1,  /*!< VCAP12_TOO_LOW is masked as 0           */
} BODVCAP12CTL_BIT_LOBODOM;

#define BODVCAP12CTL_ALL_LOBODOM_UNMASK     ((0x0UL) << BODVCAP12CTL_ALL_LOBODOM_Pos)
#define BODVCAP12CTL_ALL_LOBODOM_MASK       ((0x1UL) << BODVCAP12CTL_ALL_LOBODOM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    HIBODL2HVTH
 *  @access     POWER->BODVCAP12CTL.bit.HIBODL2HVTH
 *  @brief      Select the threshold voltage for VCAP12 too high detection when VCAP12 varies from low to high.
 */
#define BODVCAP12CTL_ALL_HIBODL2HVTH_Pos (4)
#define BODVCAP12CTL_ALL_HIBODL2HVTH_Msk (0x7UL << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_HIBODL2HVTH_1dot50_V     = 0,  /*!< 1.50V   */
    BODVCAP12CTL_BIT_HIBODL2HVTH_1dot48_V     = 1,  /*!< 1.48V   */
    BODVCAP12CTL_BIT_HIBODL2HVTH_1dot45_V     = 2,  /*!< 1.45V   */
    BODVCAP12CTL_BIT_HIBODL2HVTH_1dot43_V     = 3,  /*!< 1.43V   */
    BODVCAP12CTL_BIT_HIBODL2HVTH_1dot41_V     = 4,  /*!< 1.41V   */
    BODVCAP12CTL_BIT_HIBODL2HVTH_1dot39_V     = 5,  /*!< 1.39V   */
    BODVCAP12CTL_BIT_HIBODL2HVTH_1dot37_V     = 6,  /*!< 1.37V   */
    BODVCAP12CTL_BIT_HIBODL2HVTH_1dot35_V     = 7,  /*!< 1.35V   */
} BODVCAP12CTL_BIT_HIBODL2HVTH;

#define BODVCAP12CTL_ALL_HIBODL2HVTH_1dot50_V     ((0x0UL) << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODL2HVTH_1dot48_V     ((0x1UL) << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODL2HVTH_1dot45_V     ((0x2UL) << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODL2HVTH_1dot43_V     ((0x3UL) << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODL2HVTH_1dot41_V     ((0x4UL) << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODL2HVTH_1dot39_V     ((0x5UL) << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODL2HVTH_1dot37_V     ((0x6UL) << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODL2HVTH_1dot35_V     ((0x7UL) << BODVCAP12CTL_ALL_HIBODL2HVTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    HIBODH2LVTH
 *  @access     POWER->BODVCAP12CTL.bit.HIBODH2LVTH
 *  @brief      Select the threshold voltage for VCAP12 too high detection when VCAP12 varies from high to low.
 */
#define BODVCAP12CTL_ALL_HIBODH2LVTH_Pos (7)
#define BODVCAP12CTL_ALL_HIBODH2LVTH_Msk (0x7UL << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_HIBODH2LVTH_1dot50_V     = 0,  /*!< 1.50V   */
    BODVCAP12CTL_BIT_HIBODH2LVTH_1dot48_V     = 1,  /*!< 1.48V   */
    BODVCAP12CTL_BIT_HIBODH2LVTH_1dot45_V     = 2,  /*!< 1.45V   */
    BODVCAP12CTL_BIT_HIBODH2LVTH_1dot43_V     = 3,  /*!< 1.43V   */
    BODVCAP12CTL_BIT_HIBODH2LVTH_1dot41_V     = 4,  /*!< 1.41V   */
    BODVCAP12CTL_BIT_HIBODH2LVTH_1dot39_V     = 5,  /*!< 1.39V   */
    BODVCAP12CTL_BIT_HIBODH2LVTH_1dot37_V     = 6,  /*!< 1.37V   */
    BODVCAP12CTL_BIT_HIBODH2LVTH_1dot35_V     = 7,  /*!< 1.35V   */
} BODVCAP12CTL_BIT_HIBODH2LVTH;

#define BODVCAP12CTL_ALL_HIBODH2LVTH_1dot50_V     ((0x0UL) << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODH2LVTH_1dot48_V     ((0x1UL) << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODH2LVTH_1dot45_V     ((0x2UL) << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODH2LVTH_1dot43_V     ((0x3UL) << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODH2LVTH_1dot41_V     ((0x4UL) << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODH2LVTH_1dot39_V     ((0x5UL) << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODH2LVTH_1dot37_V     ((0x6UL) << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_HIBODH2LVTH_1dot35_V     ((0x7UL) << BODVCAP12CTL_ALL_HIBODH2LVTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    LOBODH2LVTH
 *  @access     POWER->BODVCAP12CTL.bit.LOBODH2LVTH
 *  @brief      Select the threshold voltage for VCAP12 too low detection when VCAP12 varies from high to low.
 */
#define BODVCAP12CTL_ALL_LOBODH2LVTH_Pos (10)
#define BODVCAP12CTL_ALL_LOBODH2LVTH_Msk (0x7UL << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_LOBODH2LVTH_1dot06_V     = 0,  /*!< 1.06V   */
    BODVCAP12CTL_BIT_LOBODH2LVTH_1dot04_V     = 1,  /*!< 1.04V   */
    BODVCAP12CTL_BIT_LOBODH2LVTH_1dot02_V     = 2,  /*!< 1.02V   */
    BODVCAP12CTL_BIT_LOBODH2LVTH_1dot00_V     = 3,  /*!< 1.00V   */
    BODVCAP12CTL_BIT_LOBODH2LVTH_0dot98_V     = 4,  /*!< 0.98V   */
    BODVCAP12CTL_BIT_LOBODH2LVTH_0dot96_V     = 5,  /*!< 0.96V   */
    BODVCAP12CTL_BIT_LOBODH2LVTH_0dot94_V     = 6,  /*!< 0.94V   */
    BODVCAP12CTL_BIT_LOBODH2LVTH_0dot92_V     = 7,  /*!< 0.92V   */
} BODVCAP12CTL_BIT_LOBODH2LVTH;

#define BODVCAP12CTL_ALL_LOBODH2LVTH_1dot06_V     ((0x0UL) << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODH2LVTH_1dot04_V     ((0x1UL) << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODH2LVTH_1dot02_V     ((0x2UL) << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODH2LVTH_1dot00_V     ((0x3UL) << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODH2LVTH_0dot98_V     ((0x4UL) << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODH2LVTH_0dot96_V     ((0x5UL) << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODH2LVTH_0dot94_V     ((0x6UL) << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODH2LVTH_0dot92_V     ((0x7UL) << BODVCAP12CTL_ALL_LOBODH2LVTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    LOBODL2HVTH
 *  @access     POWER->BODVCAP12CTL.bit.LOBODL2HVTH
 *  @brief      Select the threshold voltage for VCAP12 too low detection when VCAP12 varies from low to high.
 */
#define BODVCAP12CTL_ALL_LOBODL2HVTH_Pos (13)
#define BODVCAP12CTL_ALL_LOBODL2HVTH_Msk (0x7UL << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_LOBODL2HVTH_1dot06_V     = 0,  /*!< 1.06V   */
    BODVCAP12CTL_BIT_LOBODL2HVTH_1dot04_V     = 1,  /*!< 1.04V   */
    BODVCAP12CTL_BIT_LOBODL2HVTH_1dot02_V     = 2,  /*!< 1.02V   */
    BODVCAP12CTL_BIT_LOBODL2HVTH_1dot00_V     = 3,  /*!< 1.00V   */
    BODVCAP12CTL_BIT_LOBODL2HVTH_0dot98_V     = 4,  /*!< 0.98V   */
    BODVCAP12CTL_BIT_LOBODL2HVTH_0dot96_V     = 5,  /*!< 0.96V   */
    BODVCAP12CTL_BIT_LOBODL2HVTH_0dot94_V     = 6,  /*!< 0.94V   */
    BODVCAP12CTL_BIT_LOBODL2HVTH_0dot92_V     = 7,  /*!< 0.92V   */
} BODVCAP12CTL_BIT_LOBODL2HVTH;

#define BODVCAP12CTL_ALL_LOBODL2HVTH_1dot06_V     ((0x0UL) << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODL2HVTH_1dot04_V     ((0x1UL) << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODL2HVTH_1dot02_V     ((0x2UL) << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODL2HVTH_1dot00_V     ((0x3UL) << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODL2HVTH_0dot98_V     ((0x4UL) << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODL2HVTH_0dot96_V     ((0x5UL) << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODL2HVTH_0dot94_V     ((0x6UL) << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)
#define BODVCAP12CTL_ALL_LOBODL2HVTH_0dot92_V     ((0x7UL) << BODVCAP12CTL_ALL_LOBODL2HVTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    HIBODRSTEN
 *  @access     POWER->BODVCAP12CTL.bit.HIBODRSTEN
 *  @brief      Enable reset when VCAP12 is too high
 */
#define BODVCAP12CTL_ALL_HIBODRSTEN_Pos (16)
#define BODVCAP12CTL_ALL_HIBODRSTEN_Msk (0x1UL << BODVCAP12CTL_ALL_HIBODRSTEN_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_HIBODRSTEN_DISABLE     = 0,  /*!< Disable   */
    BODVCAP12CTL_BIT_HIBODRSTEN_ENABLE      = 1,  /*!< Enable    */
} BODVCAP12CTL_BIT_HIBODRSTEN;

#define BODVCAP12CTL_ALL_HIBODRSTEN_DISABLE     ((0x0UL) << BODVCAP12CTL_ALL_HIBODRSTEN_Pos)
#define BODVCAP12CTL_ALL_HIBODRSTEN_ENABLE      ((0x1UL) << BODVCAP12CTL_ALL_HIBODRSTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVCAP12CTL    LOBODRSTEN
 *  @access     POWER->BODVCAP12CTL.bit.LOBODRSTEN
 *  @brief      Enable reset when VCAP12 is too low
 */
#define BODVCAP12CTL_ALL_LOBODRSTEN_Pos (17)
#define BODVCAP12CTL_ALL_LOBODRSTEN_Msk (0x1UL << BODVCAP12CTL_ALL_LOBODRSTEN_Pos)

typedef enum
{
    BODVCAP12CTL_BIT_LOBODRSTEN_DISABLE     = 0,  /*!< Disable   */
    BODVCAP12CTL_BIT_LOBODRSTEN_ENABLE      = 1,  /*!< Enable    */
} BODVCAP12CTL_BIT_LOBODRSTEN;

#define BODVCAP12CTL_ALL_LOBODRSTEN_DISABLE     ((0x0UL) << BODVCAP12CTL_ALL_LOBODRSTEN_Pos)
#define BODVCAP12CTL_ALL_LOBODRSTEN_ENABLE      ((0x1UL) << BODVCAP12CTL_ALL_LOBODRSTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       HIBODEN
 *  @access     POWER->BODVDDCTL.bit.HIBODEN
 *  @brief      VDD_TOO_HIGH BOD enable
 */
#define BODVDDCTL_ALL_HIBODEN_Pos (0)
#define BODVDDCTL_ALL_HIBODEN_Msk (0x1UL << BODVDDCTL_ALL_HIBODEN_Pos)

typedef enum
{
    BODVDDCTL_BIT_HIBODEN_DISABLE     = 0,  /*!< Disable   */
    BODVDDCTL_BIT_HIBODEN_ENABLE      = 1,  /*!< Enable    */
} BODVDDCTL_BIT_HIBODEN;

#define BODVDDCTL_ALL_HIBODEN_DISABLE     ((0x0UL) << BODVDDCTL_ALL_HIBODEN_Pos)
#define BODVDDCTL_ALL_HIBODEN_ENABLE      ((0x1UL) << BODVDDCTL_ALL_HIBODEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       LOBODEN
 *  @access     POWER->BODVDDCTL.bit.LOBODEN
 *  @brief      VDD_TOO_LOW BOD enable
 */
#define BODVDDCTL_ALL_LOBODEN_Pos (1)
#define BODVDDCTL_ALL_LOBODEN_Msk (0x1UL << BODVDDCTL_ALL_LOBODEN_Pos)

typedef enum
{
    BODVDDCTL_BIT_LOBODEN_DISABLE     = 0,  /*!< Disable   */
    BODVDDCTL_BIT_LOBODEN_ENABLE      = 1,  /*!< Enable    */
} BODVDDCTL_BIT_LOBODEN;

#define BODVDDCTL_ALL_LOBODEN_DISABLE     ((0x0UL) << BODVDDCTL_ALL_LOBODEN_Pos)
#define BODVDDCTL_ALL_LOBODEN_ENABLE      ((0x1UL) << BODVDDCTL_ALL_LOBODEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       HIBODOM
 *  @access     POWER->BODVDDCTL.bit.HIBODOM
 *  @brief      VDD_TOO_HIGH BOD output mask
 */
#define BODVDDCTL_ALL_HIBODOM_Pos (2)
#define BODVDDCTL_ALL_HIBODOM_Msk (0x1UL << BODVDDCTL_ALL_HIBODOM_Pos)

typedef enum
{
    BODVDDCTL_BIT_HIBODOM_UNMASK     = 0,  /*!< VDD_TOO_HIGH follows the BOD result   */
    BODVDDCTL_BIT_HIBODOM_MASK       = 1,  /*!< VDD_TOO_HIGH is masked as 0           */
} BODVDDCTL_BIT_HIBODOM;

#define BODVDDCTL_ALL_HIBODOM_UNMASK     ((0x0UL) << BODVDDCTL_ALL_HIBODOM_Pos)
#define BODVDDCTL_ALL_HIBODOM_MASK       ((0x1UL) << BODVDDCTL_ALL_HIBODOM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       LOBODOM
 *  @access     POWER->BODVDDCTL.bit.LOBODOM
 *  @brief      VDD_TOO_LOW BOD output mask
 */
#define BODVDDCTL_ALL_LOBODOM_Pos (3)
#define BODVDDCTL_ALL_LOBODOM_Msk (0x1UL << BODVDDCTL_ALL_LOBODOM_Pos)

typedef enum
{
    BODVDDCTL_BIT_LOBODOM_UNMASK     = 0,  /*!< VDD_TOO_LOW follows the BOD result   */
    BODVDDCTL_BIT_LOBODOM_MASK       = 1,  /*!< VDD_TOO_LOW is masked as 0           */
} BODVDDCTL_BIT_LOBODOM;

#define BODVDDCTL_ALL_LOBODOM_UNMASK     ((0x0UL) << BODVDDCTL_ALL_LOBODOM_Pos)
#define BODVDDCTL_ALL_LOBODOM_MASK       ((0x1UL) << BODVDDCTL_ALL_LOBODOM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       HIBODL2HVTH
 *  @access     POWER->BODVDDCTL.bit.HIBODL2HVTH
 *  @brief      Select the threshold voltage for VDD too high detection when VDD varies from low to high.
 */
#define BODVDDCTL_ALL_HIBODL2HVTH_Pos (4)
#define BODVDDCTL_ALL_HIBODL2HVTH_Msk (0x7UL << BODVDDCTL_ALL_HIBODL2HVTH_Pos)

typedef enum
{
    BODVDDCTL_BIT_HIBODL2HVTH_4dot22_V     = 0,  /*!< 4.22V   */
    BODVDDCTL_BIT_HIBODL2HVTH_4dot06_V     = 1,  /*!< 4.06V   */
    BODVDDCTL_BIT_HIBODL2HVTH_3dot91_V     = 2,  /*!< 3.91V   */
    BODVDDCTL_BIT_HIBODL2HVTH_3dot77_V     = 3,  /*!< 3.77V   */
    BODVDDCTL_BIT_HIBODL2HVTH_3dot64_V     = 4,  /*!< 3.64V   */
    BODVDDCTL_BIT_HIBODL2HVTH_3dot52_V     = 5,  /*!< 3.52V   */
    BODVDDCTL_BIT_HIBODL2HVTH_3dot41_V     = 6,  /*!< 3.41V   */
    BODVDDCTL_BIT_HIBODL2HVTH_3dot30_V     = 7,  /*!< 3.30V   */
} BODVDDCTL_BIT_HIBODL2HVTH;

#define BODVDDCTL_ALL_HIBODL2HVTH_4dot22_V     ((0x0UL) << BODVDDCTL_ALL_HIBODL2HVTH_Pos)
#define BODVDDCTL_ALL_HIBODL2HVTH_4dot06_V     ((0x1UL) << BODVDDCTL_ALL_HIBODL2HVTH_Pos)
#define BODVDDCTL_ALL_HIBODL2HVTH_3dot91_V     ((0x2UL) << BODVDDCTL_ALL_HIBODL2HVTH_Pos)
#define BODVDDCTL_ALL_HIBODL2HVTH_3dot77_V     ((0x3UL) << BODVDDCTL_ALL_HIBODL2HVTH_Pos)
#define BODVDDCTL_ALL_HIBODL2HVTH_3dot64_V     ((0x4UL) << BODVDDCTL_ALL_HIBODL2HVTH_Pos)
#define BODVDDCTL_ALL_HIBODL2HVTH_3dot52_V     ((0x5UL) << BODVDDCTL_ALL_HIBODL2HVTH_Pos)
#define BODVDDCTL_ALL_HIBODL2HVTH_3dot41_V     ((0x6UL) << BODVDDCTL_ALL_HIBODL2HVTH_Pos)
#define BODVDDCTL_ALL_HIBODL2HVTH_3dot30_V     ((0x7UL) << BODVDDCTL_ALL_HIBODL2HVTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       HIBODH2LVTH
 *  @access     POWER->BODVDDCTL.bit.HIBODH2LVTH
 *  @brief      Select the threshold voltage for VDD too high detection when VDD varies from high to low.
 */
#define BODVDDCTL_ALL_HIBODH2LVTH_Pos (7)
#define BODVDDCTL_ALL_HIBODH2LVTH_Msk (0x7UL << BODVDDCTL_ALL_HIBODH2LVTH_Pos)

typedef enum
{
    BODVDDCTL_BIT_HIBODH2LVTH_4dot22_V     = 0,  /*!< 4.22V   */
    BODVDDCTL_BIT_HIBODH2LVTH_4dot06_V     = 1,  /*!< 4.06V   */
    BODVDDCTL_BIT_HIBODH2LVTH_3dot91_V     = 2,  /*!< 3.91V   */
    BODVDDCTL_BIT_HIBODH2LVTH_3dot77_V     = 3,  /*!< 3.77V   */
    BODVDDCTL_BIT_HIBODH2LVTH_3dot64_V     = 4,  /*!< 3.64V   */
    BODVDDCTL_BIT_HIBODH2LVTH_3dot52_V     = 5,  /*!< 3.52V   */
    BODVDDCTL_BIT_HIBODH2LVTH_3dot41_V     = 6,  /*!< 3.41V   */
    BODVDDCTL_BIT_HIBODH2LVTH_3dot30_V     = 7,  /*!< 3.30V   */
} BODVDDCTL_BIT_HIBODH2LVTH;

#define BODVDDCTL_ALL_HIBODH2LVTH_4dot22_V     ((0x0UL) << BODVDDCTL_ALL_HIBODH2LVTH_Pos)
#define BODVDDCTL_ALL_HIBODH2LVTH_4dot06_V     ((0x1UL) << BODVDDCTL_ALL_HIBODH2LVTH_Pos)
#define BODVDDCTL_ALL_HIBODH2LVTH_3dot91_V     ((0x2UL) << BODVDDCTL_ALL_HIBODH2LVTH_Pos)
#define BODVDDCTL_ALL_HIBODH2LVTH_3dot77_V     ((0x3UL) << BODVDDCTL_ALL_HIBODH2LVTH_Pos)
#define BODVDDCTL_ALL_HIBODH2LVTH_3dot64_V     ((0x4UL) << BODVDDCTL_ALL_HIBODH2LVTH_Pos)
#define BODVDDCTL_ALL_HIBODH2LVTH_3dot52_V     ((0x5UL) << BODVDDCTL_ALL_HIBODH2LVTH_Pos)
#define BODVDDCTL_ALL_HIBODH2LVTH_3dot41_V     ((0x6UL) << BODVDDCTL_ALL_HIBODH2LVTH_Pos)
#define BODVDDCTL_ALL_HIBODH2LVTH_3dot30_V     ((0x7UL) << BODVDDCTL_ALL_HIBODH2LVTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       LOBODH2LVTH
 *  @access     POWER->BODVDDCTL.bit.LOBODH2LVTH
 *  @brief      Select the threshold voltage for VDD too low detection when VDD varies from high to low.
 */
#define BODVDDCTL_ALL_LOBODH2LVTH_Pos (10)
#define BODVDDCTL_ALL_LOBODH2LVTH_Msk (0x7UL << BODVDDCTL_ALL_LOBODH2LVTH_Pos)

typedef enum
{
    BODVDDCTL_BIT_LOBODH2LVTH_3dot11_V     = 0,  /*!< 3.11V   */
    BODVDDCTL_BIT_LOBODH2LVTH_3dot02_V     = 1,  /*!< 3.02V   */
    BODVDDCTL_BIT_LOBODH2LVTH_2dot93_V     = 2,  /*!< 2.93V   */
    BODVDDCTL_BIT_LOBODH2LVTH_2dot85_V     = 3,  /*!< 2.85V   */
    BODVDDCTL_BIT_LOBODH2LVTH_2dot78_V     = 4,  /*!< 2.78V   */
    BODVDDCTL_BIT_LOBODH2LVTH_2dot71_V     = 5,  /*!< 2.71V   */
    BODVDDCTL_BIT_LOBODH2LVTH_2dot64_V     = 6,  /*!< 2.64V   */
    BODVDDCTL_BIT_LOBODH2LVTH_2dot58_V     = 7,  /*!< 2.58V   */
} BODVDDCTL_BIT_LOBODH2LVTH;

#define BODVDDCTL_ALL_LOBODH2LVTH_3dot11_V     ((0x0UL) << BODVDDCTL_ALL_LOBODH2LVTH_Pos)
#define BODVDDCTL_ALL_LOBODH2LVTH_3dot02_V     ((0x1UL) << BODVDDCTL_ALL_LOBODH2LVTH_Pos)
#define BODVDDCTL_ALL_LOBODH2LVTH_2dot93_V     ((0x2UL) << BODVDDCTL_ALL_LOBODH2LVTH_Pos)
#define BODVDDCTL_ALL_LOBODH2LVTH_2dot85_V     ((0x3UL) << BODVDDCTL_ALL_LOBODH2LVTH_Pos)
#define BODVDDCTL_ALL_LOBODH2LVTH_2dot78_V     ((0x4UL) << BODVDDCTL_ALL_LOBODH2LVTH_Pos)
#define BODVDDCTL_ALL_LOBODH2LVTH_2dot71_V     ((0x5UL) << BODVDDCTL_ALL_LOBODH2LVTH_Pos)
#define BODVDDCTL_ALL_LOBODH2LVTH_2dot64_V     ((0x6UL) << BODVDDCTL_ALL_LOBODH2LVTH_Pos)
#define BODVDDCTL_ALL_LOBODH2LVTH_2dot58_V     ((0x7UL) << BODVDDCTL_ALL_LOBODH2LVTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       LOBODL2HVTH
 *  @access     POWER->BODVDDCTL.bit.LOBODL2HVTH
 *  @brief      Select the threshold voltage for VDD too low detection when VDD varies from low to high.
 */
#define BODVDDCTL_ALL_LOBODL2HVTH_Pos (13)
#define BODVDDCTL_ALL_LOBODL2HVTH_Msk (0x7UL << BODVDDCTL_ALL_LOBODL2HVTH_Pos)

typedef enum
{
    BODVDDCTL_BIT_LOBODL2HVTH_3dot11_V     = 0,  /*!< 3.11V   */
    BODVDDCTL_BIT_LOBODL2HVTH_3dot02_V     = 1,  /*!< 3.02V   */
    BODVDDCTL_BIT_LOBODL2HVTH_2dot93_V     = 2,  /*!< 2.93V   */
    BODVDDCTL_BIT_LOBODL2HVTH_2dot85_V     = 3,  /*!< 2.85V   */
    BODVDDCTL_BIT_LOBODL2HVTH_2dot78_V     = 4,  /*!< 2.78V   */
    BODVDDCTL_BIT_LOBODL2HVTH_2dot71_V     = 5,  /*!< 2.71V   */
    BODVDDCTL_BIT_LOBODL2HVTH_2dot64_V     = 6,  /*!< 2.64V   */
    BODVDDCTL_BIT_LOBODL2HVTH_2dot58_V     = 7,  /*!< 2.58V   */
} BODVDDCTL_BIT_LOBODL2HVTH;

#define BODVDDCTL_ALL_LOBODL2HVTH_3dot11_V     ((0x0UL) << BODVDDCTL_ALL_LOBODL2HVTH_Pos)
#define BODVDDCTL_ALL_LOBODL2HVTH_3dot02_V     ((0x1UL) << BODVDDCTL_ALL_LOBODL2HVTH_Pos)
#define BODVDDCTL_ALL_LOBODL2HVTH_2dot93_V     ((0x2UL) << BODVDDCTL_ALL_LOBODL2HVTH_Pos)
#define BODVDDCTL_ALL_LOBODL2HVTH_2dot85_V     ((0x3UL) << BODVDDCTL_ALL_LOBODL2HVTH_Pos)
#define BODVDDCTL_ALL_LOBODL2HVTH_2dot78_V     ((0x4UL) << BODVDDCTL_ALL_LOBODL2HVTH_Pos)
#define BODVDDCTL_ALL_LOBODL2HVTH_2dot71_V     ((0x5UL) << BODVDDCTL_ALL_LOBODL2HVTH_Pos)
#define BODVDDCTL_ALL_LOBODL2HVTH_2dot64_V     ((0x6UL) << BODVDDCTL_ALL_LOBODL2HVTH_Pos)
#define BODVDDCTL_ALL_LOBODL2HVTH_2dot58_V     ((0x7UL) << BODVDDCTL_ALL_LOBODL2HVTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       HIBODRSTEN
 *  @access     POWER->BODVDDCTL.bit.HIBODRSTEN
 *  @brief      Enable reset when VDD is too high
 */
#define BODVDDCTL_ALL_HIBODRSTEN_Pos (16)
#define BODVDDCTL_ALL_HIBODRSTEN_Msk (0x1UL << BODVDDCTL_ALL_HIBODRSTEN_Pos)

typedef enum
{
    BODVDDCTL_BIT_HIBODRSTEN_DISABLE     = 0,  /*!< Disable   */
    BODVDDCTL_BIT_HIBODRSTEN_ENABLE      = 1,  /*!< Enable    */
} BODVDDCTL_BIT_HIBODRSTEN;

#define BODVDDCTL_ALL_HIBODRSTEN_DISABLE     ((0x0UL) << BODVDDCTL_ALL_HIBODRSTEN_Pos)
#define BODVDDCTL_ALL_HIBODRSTEN_ENABLE      ((0x1UL) << BODVDDCTL_ALL_HIBODRSTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODVDDCTL       LOBODRSTEN
 *  @access     POWER->BODVDDCTL.bit.LOBODRSTEN
 *  @brief      Enable reset when VDD is too low
 */
#define BODVDDCTL_ALL_LOBODRSTEN_Pos (17)
#define BODVDDCTL_ALL_LOBODRSTEN_Msk (0x1UL << BODVDDCTL_ALL_LOBODRSTEN_Pos)

typedef enum
{
    BODVDDCTL_BIT_LOBODRSTEN_DISABLE     = 0,  /*!< Disable   */
    BODVDDCTL_BIT_LOBODRSTEN_ENABLE      = 1,  /*!< Enable    */
} BODVDDCTL_BIT_LOBODRSTEN;

#define BODVDDCTL_ALL_LOBODRSTEN_DISABLE     ((0x0UL) << BODVDDCTL_ALL_LOBODRSTEN_Pos)
#define BODVDDCTL_ALL_LOBODRSTEN_ENABLE      ((0x1UL) << BODVDDCTL_ALL_LOBODRSTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           LDOCTL          VREFEN
 *  @access     POWER->LDOCTL.bit.VREFEN
 *  @brief      Enable high-performance reference for LDO
 */
#define LDOCTL_ALL_VREFEN_Pos (1)
#define LDOCTL_ALL_VREFEN_Msk (0x1UL << LDOCTL_ALL_VREFEN_Pos)

typedef enum
{
    LDOCTL_BIT_VREFEN_DISABLE     = 0,  /*!< Disable   */
    LDOCTL_BIT_VREFEN_ENABLE      = 1,  /*!< Enable    */
} LDOCTL_BIT_VREFEN;

#define LDOCTL_ALL_VREFEN_DISABLE     ((0x0UL) << LDOCTL_ALL_VREFEN_Pos)
#define LDOCTL_ALL_VREFEN_ENABLE      ((0x1UL) << LDOCTL_ALL_VREFEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           LDOCTL          VREFSEL
 *  @access     POWER->LDOCTL.bit.VREFSEL
 *  @brief      Reference voltage select for LDO (Valid when VREFEN=1)
 */
#define LDOCTL_ALL_VREFSEL_Pos (5)
#define LDOCTL_ALL_VREFSEL_Msk (0xFUL << LDOCTL_ALL_VREFSEL_Pos)

typedef enum
{
    LDOCTL_BIT_VREFSEL_1dot06_V     = 0,  /*!< 1.06V   */
    LDOCTL_BIT_VREFSEL_1dot08_V     = 1,  /*!< 1.08V   */
    LDOCTL_BIT_VREFSEL_1dot10_V     = 2,  /*!< 1.10V   */
    LDOCTL_BIT_VREFSEL_1dot12_V     = 3,  /*!< 1.12V   */
    LDOCTL_BIT_VREFSEL_1dot14_V     = 4,  /*!< 1.14V   */
    LDOCTL_BIT_VREFSEL_1dot16_V     = 5,  /*!< 1.16V   */
    LDOCTL_BIT_VREFSEL_1dot18_V     = 6,  /*!< 1.18V   */
    LDOCTL_BIT_VREFSEL_1dot20_V     = 7,  /*!< 1.20V   */
    LDOCTL_BIT_VREFSEL_1dot22_V     = 8,  /*!< 1.22V   */
    LDOCTL_BIT_VREFSEL_1dot24_V     = 9,  /*!< 1.24V   */
    LDOCTL_BIT_VREFSEL_1dot26_V     = 10,  /*!< 1.26V   */
    LDOCTL_BIT_VREFSEL_1dot28_V     = 11,  /*!< 1.28V   */
    LDOCTL_BIT_VREFSEL_1dot30_V     = 12,  /*!< 1.30V   */
    LDOCTL_BIT_VREFSEL_1dot32_V     = 13,  /*!< 1.32V   */
    LDOCTL_BIT_VREFSEL_1dot34_V     = 14,  /*!< 1.34V   */
    LDOCTL_BIT_VREFSEL_1dot36_V     = 15,  /*!< 1.36V   */
} LDOCTL_BIT_VREFSEL;

#define LDOCTL_ALL_VREFSEL_1dot06_V     ((0x00UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot08_V     ((0x01UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot10_V     ((0x02UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot12_V     ((0x03UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot14_V     ((0x04UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot16_V     ((0x05UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot18_V     ((0x06UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot20_V     ((0x07UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot22_V     ((0x08UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot24_V     ((0x09UL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot26_V     ((0x0AUL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot28_V     ((0x0BUL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot30_V     ((0x0CUL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot32_V     ((0x0DUL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot34_V     ((0x0EUL) << LDOCTL_ALL_VREFSEL_Pos)
#define LDOCTL_ALL_VREFSEL_1dot36_V     ((0x0FUL) << LDOCTL_ALL_VREFSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           LDOCTL          LPREFSEL
 *  @access     POWER->LDOCTL.bit.LPREFSEL
 *  @brief      Low-power reference voltage select for LDO (Valid when VREFEN=0)
 */
#define LDOCTL_ALL_LPREFSEL_Pos (9)
#define LDOCTL_ALL_LPREFSEL_Msk (0x7UL << LDOCTL_ALL_LPREFSEL_Pos)

typedef enum
{
    LDOCTL_BIT_LPREFSEL_1dot12_V     = 0,  /*!< 1.12V   */
    LDOCTL_BIT_LPREFSEL_1dot17_V     = 1,  /*!< 1.17V   */
    LDOCTL_BIT_LPREFSEL_1dot22_V     = 2,  /*!< 1.22V   */
    LDOCTL_BIT_LPREFSEL_1dot27_V     = 3,  /*!< 1.27V   */
    LDOCTL_BIT_LPREFSEL_1dot31_V     = 4,  /*!< 1.31V   */
    LDOCTL_BIT_LPREFSEL_1dot36_V     = 5,  /*!< 1.36V   */
    LDOCTL_BIT_LPREFSEL_1dot41_V     = 6,  /*!< 1.41V   */
    LDOCTL_BIT_LPREFSEL_1dot45_V     = 7,  /*!< 1.45V   */
} LDOCTL_BIT_LPREFSEL;

#define LDOCTL_ALL_LPREFSEL_1dot12_V     ((0x0UL) << LDOCTL_ALL_LPREFSEL_Pos)
#define LDOCTL_ALL_LPREFSEL_1dot17_V     ((0x1UL) << LDOCTL_ALL_LPREFSEL_Pos)
#define LDOCTL_ALL_LPREFSEL_1dot22_V     ((0x2UL) << LDOCTL_ALL_LPREFSEL_Pos)
#define LDOCTL_ALL_LPREFSEL_1dot27_V     ((0x3UL) << LDOCTL_ALL_LPREFSEL_Pos)
#define LDOCTL_ALL_LPREFSEL_1dot31_V     ((0x4UL) << LDOCTL_ALL_LPREFSEL_Pos)
#define LDOCTL_ALL_LPREFSEL_1dot36_V     ((0x5UL) << LDOCTL_ALL_LPREFSEL_Pos)
#define LDOCTL_ALL_LPREFSEL_1dot41_V     ((0x6UL) << LDOCTL_ALL_LPREFSEL_Pos)
#define LDOCTL_ALL_LPREFSEL_1dot45_V     ((0x7UL) << LDOCTL_ALL_LPREFSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODSTS          VCAP12TOOHI
 *  @access     POWER->BODSTS.bit.VCAP12TOOHI
 *  @brief      Latched VCAP12_TOO_HIGH status
 */
#define BODSTS_ALL_VCAP12TOOHI_Pos (0)
#define BODSTS_ALL_VCAP12TOOHI_Msk (0x1UL << BODSTS_ALL_VCAP12TOOHI_Pos)

typedef enum
{
    BODSTS_BIT_VCAP12TOOHI_NOT_OCCUR     = 0,  /*!< VCAP12 has never been too high   */
    BODSTS_BIT_VCAP12TOOHI_OCCUR         = 1,  /*!< VCAP12 is used to be too high    */
} BODSTS_BIT_VCAP12TOOHI;

#define BODSTS_ALL_VCAP12TOOHI_NOT_OCCUR     ((0x0UL) << BODSTS_ALL_VCAP12TOOHI_Pos)
#define BODSTS_ALL_VCAP12TOOHI_OCCUR         ((0x1UL) << BODSTS_ALL_VCAP12TOOHI_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODSTS          VCAP12TOOLO
 *  @access     POWER->BODSTS.bit.VCAP12TOOLO
 *  @brief      Latched VCAP12_TOO_LOW status
 */
#define BODSTS_ALL_VCAP12TOOLO_Pos (1)
#define BODSTS_ALL_VCAP12TOOLO_Msk (0x1UL << BODSTS_ALL_VCAP12TOOLO_Pos)

typedef enum
{
    BODSTS_BIT_VCAP12TOOLO_NOT_OCCUR     = 0,  /*!< VCAP12 has never been too low   */
    BODSTS_BIT_VCAP12TOOLO_OCCUR         = 1,  /*!< VCAP12 is used to be too low    */
} BODSTS_BIT_VCAP12TOOLO;

#define BODSTS_ALL_VCAP12TOOLO_NOT_OCCUR     ((0x0UL) << BODSTS_ALL_VCAP12TOOLO_Pos)
#define BODSTS_ALL_VCAP12TOOLO_OCCUR         ((0x1UL) << BODSTS_ALL_VCAP12TOOLO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODSTS          VDDTOOHI
 *  @access     POWER->BODSTS.bit.VDDTOOHI
 *  @brief      Latched VDD_TOO_HIGH status
 */
#define BODSTS_ALL_VDDTOOHI_Pos (2)
#define BODSTS_ALL_VDDTOOHI_Msk (0x1UL << BODSTS_ALL_VDDTOOHI_Pos)

typedef enum
{
    BODSTS_BIT_VDDTOOHI_NOT_OCCUR     = 0,  /*!< VDD has never been too high   */
    BODSTS_BIT_VDDTOOHI_OCCUR         = 1,  /*!< VDD is used to be too high    */
} BODSTS_BIT_VDDTOOHI;

#define BODSTS_ALL_VDDTOOHI_NOT_OCCUR     ((0x0UL) << BODSTS_ALL_VDDTOOHI_Pos)
#define BODSTS_ALL_VDDTOOHI_OCCUR         ((0x1UL) << BODSTS_ALL_VDDTOOHI_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODSTS          VDDTOOLO
 *  @access     POWER->BODSTS.bit.VDDTOOLO
 *  @brief      Latched VDD_TOO_LOW status
 */
#define BODSTS_ALL_VDDTOOLO_Pos (3)
#define BODSTS_ALL_VDDTOOLO_Msk (0x1UL << BODSTS_ALL_VDDTOOLO_Pos)

typedef enum
{
    BODSTS_BIT_VDDTOOLO_NOT_OCCUR     = 0,  /*!< VDD has never been too low   */
    BODSTS_BIT_VDDTOOLO_OCCUR         = 1,  /*!< VDD is used to be too low    */
} BODSTS_BIT_VDDTOOLO;

#define BODSTS_ALL_VDDTOOLO_NOT_OCCUR     ((0x0UL) << BODSTS_ALL_VDDTOOLO_Pos)
#define BODSTS_ALL_VDDTOOLO_OCCUR         ((0x1UL) << BODSTS_ALL_VDDTOOLO_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODSTS          CLR
 *  @access     POWER->BODSTS.bit.CLR
 *  @brief      Clear latched BOD status
 */
#define BODSTS_ALL_CLR_Pos (31)
#define BODSTS_ALL_CLR_Msk (0x1UL << BODSTS_ALL_CLR_Pos)

typedef enum
{
    BODSTS_BIT_CLR_NO_EFFECT     = 0,  /*!< Write a 0 has no effect.                      
                                            Always readback 0.                             */
    BODSTS_BIT_CLR_CLEAR         = 1,  /*!< Write a 1 will clear all latched BOD status.  
                                            This bit is self-cleared to 0.                 */
} BODSTS_BIT_CLR;

#define BODSTS_ALL_CLR_NO_EFFECT     ((0x0UL) << BODSTS_ALL_CLR_Pos)
#define BODSTS_ALL_CLR_CLEAR         ((0x1UL) << BODSTS_ALL_CLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   POWER           BODCTL          VREFSEL
 *  @access     POWER->BODCTL.bit.VREFSEL
 *  @brief      BOD reference voltage select
 */
#define BODCTL_ALL_VREFSEL_Pos (0)
#define BODCTL_ALL_VREFSEL_Msk (0xFUL << BODCTL_ALL_VREFSEL_Pos)

typedef enum
{
    BODCTL_BIT_VREFSEL_1dot13_V     = 0,  /*!< 1.13V   */
    BODCTL_BIT_VREFSEL_1dot14_V     = 1,  /*!< 1.14V   */
    BODCTL_BIT_VREFSEL_1dot15_V     = 2,  /*!< 1.15V   */
    BODCTL_BIT_VREFSEL_1dot16_V     = 3,  /*!< 1.16V   */
    BODCTL_BIT_VREFSEL_1dot17_V     = 4,  /*!< 1.17V   */
    BODCTL_BIT_VREFSEL_1dot18_V     = 5,  /*!< 1.18V   */
    BODCTL_BIT_VREFSEL_1dot19_V     = 6,  /*!< 1.19V   */
    BODCTL_BIT_VREFSEL_1dot20_V     = 7,  /*!< 1.20V   */
    BODCTL_BIT_VREFSEL_1dot21_V     = 8,  /*!< 1.21V   */
    BODCTL_BIT_VREFSEL_1dot22_V     = 9,  /*!< 1.22V   */
    BODCTL_BIT_VREFSEL_1dot23_V     = 10,  /*!< 1.23V   */
    BODCTL_BIT_VREFSEL_1dot24_V     = 11,  /*!< 1.24V   */
    BODCTL_BIT_VREFSEL_1dot25_V     = 12,  /*!< 1.25V   */
    BODCTL_BIT_VREFSEL_1dot26_V     = 13,  /*!< 1.26V   */
    BODCTL_BIT_VREFSEL_1dot27_V     = 14,  /*!< 1.27V   */
    BODCTL_BIT_VREFSEL_1dot28_V     = 15,  /*!< 1.28V   */
} BODCTL_BIT_VREFSEL;

#define BODCTL_ALL_VREFSEL_1dot13_V     ((0x00UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot14_V     ((0x01UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot15_V     ((0x02UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot16_V     ((0x03UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot17_V     ((0x04UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot18_V     ((0x05UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot19_V     ((0x06UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot20_V     ((0x07UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot21_V     ((0x08UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot22_V     ((0x09UL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot23_V     ((0x0AUL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot24_V     ((0x0BUL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot25_V     ((0x0CUL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot26_V     ((0x0DUL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot27_V     ((0x0EUL) << BODCTL_ALL_VREFSEL_Pos)
#define BODCTL_ALL_VREFSEL_1dot28_V     ((0x0FUL) << BODCTL_ALL_VREFSEL_Pos)





/********************************************************************************
*
* Module Name     PINMUX
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO0           MUXSEL
 *  @access     PINMUX->GPIO0.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO0_ALL_MUXSEL_Pos (0)
#define GPIO0_ALL_MUXSEL_Msk (0x7UL << GPIO0_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO0_BIT_MUXSEL_GPIO0        = 0,  /*!< GPIO0         */
    GPIO0_BIT_MUXSEL_UART_TXD     = 1,  /*!< UART_TXD      */
    GPIO0_BIT_MUXSEL_I2C_SCL      = 2,  /*!< I2C_SCL       */
    GPIO0_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO0_BIT_MUXSEL;

#define GPIO0_ALL_MUXSEL_GPIO0        ((0x0UL) << GPIO0_ALL_MUXSEL_Pos)
#define GPIO0_ALL_MUXSEL_UART_TXD     ((0x1UL) << GPIO0_ALL_MUXSEL_Pos)
#define GPIO0_ALL_MUXSEL_I2C_SCL      ((0x2UL) << GPIO0_ALL_MUXSEL_Pos)
#define GPIO0_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO0_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO0           DEMUX
 *  @access     PINMUX->GPIO0.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO0_ALL_DEMUX_Pos (3)
#define GPIO0_ALL_DEMUX_Msk (0xFFUL << GPIO0_ALL_DEMUX_Pos)

#define GPIO0_BIT_DEMUX

#define GPIO0_ALL_DEMUX_(x) ((x) << GPIO0_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO0           NPU
 *  @access     PINMUX->GPIO0.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO0_ALL_NPU_Pos (11)
#define GPIO0_ALL_NPU_Msk (0xFFUL << GPIO0_ALL_NPU_Pos)

#define GPIO0_BIT_NPU

#define GPIO0_ALL_NPU_(x) ((x) << GPIO0_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO0           DEGLITCH
 *  @access     PINMUX->GPIO0.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO0_ALL_DEGLITCH_Pos (19)
#define GPIO0_ALL_DEGLITCH_Msk (0x1UL << GPIO0_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO0_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO0_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO0_BIT_DEGLITCH;

#define GPIO0_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO0_ALL_DEGLITCH_Pos)
#define GPIO0_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO0_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO1           MUXSEL
 *  @access     PINMUX->GPIO1.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO1_ALL_MUXSEL_Pos (0)
#define GPIO1_ALL_MUXSEL_Msk (0x7UL << GPIO1_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO1_BIT_MUXSEL_ADC0         = 0,  /*!< ADC0          */
    GPIO1_BIT_MUXSEL_GPIO1        = 1,  /*!< GPIO1         */
    GPIO1_BIT_MUXSEL_PWMSYNCI     = 2,  /*!< PWMSYNCI      */
    GPIO1_BIT_MUXSEL_PWMSYNCO     = 3,  /*!< PWMSYNCO      */
    GPIO1_BIT_MUXSEL_I2C_SDA      = 4,  /*!< I2C_SDA       */
    GPIO1_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO1_BIT_MUXSEL;

#define GPIO1_ALL_MUXSEL_ADC0         ((0x0UL) << GPIO1_ALL_MUXSEL_Pos)
#define GPIO1_ALL_MUXSEL_GPIO1        ((0x1UL) << GPIO1_ALL_MUXSEL_Pos)
#define GPIO1_ALL_MUXSEL_PWMSYNCI     ((0x2UL) << GPIO1_ALL_MUXSEL_Pos)
#define GPIO1_ALL_MUXSEL_PWMSYNCO     ((0x3UL) << GPIO1_ALL_MUXSEL_Pos)
#define GPIO1_ALL_MUXSEL_I2C_SDA      ((0x4UL) << GPIO1_ALL_MUXSEL_Pos)
#define GPIO1_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO1_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO1           DEMUX
 *  @access     PINMUX->GPIO1.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO1_ALL_DEMUX_Pos (3)
#define GPIO1_ALL_DEMUX_Msk (0xFFUL << GPIO1_ALL_DEMUX_Pos)

#define GPIO1_BIT_DEMUX

#define GPIO1_ALL_DEMUX_(x) ((x) << GPIO1_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO1           NPU
 *  @access     PINMUX->GPIO1.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO1_ALL_NPU_Pos (11)
#define GPIO1_ALL_NPU_Msk (0xFFUL << GPIO1_ALL_NPU_Pos)

#define GPIO1_BIT_NPU

#define GPIO1_ALL_NPU_(x) ((x) << GPIO1_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO1           DEGLITCH
 *  @access     PINMUX->GPIO1.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO1_ALL_DEGLITCH_Pos (19)
#define GPIO1_ALL_DEGLITCH_Msk (0x1UL << GPIO1_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO1_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO1_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO1_BIT_DEGLITCH;

#define GPIO1_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO1_ALL_DEGLITCH_Pos)
#define GPIO1_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO1_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO2           MUXSEL
 *  @access     PINMUX->GPIO2.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO2_ALL_MUXSEL_Pos (0)
#define GPIO2_ALL_MUXSEL_Msk (0x7UL << GPIO2_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO2_BIT_MUXSEL_ADC1      = 0,  /*!< ADC1          */
    GPIO2_BIT_MUXSEL_GPIO2     = 1,  /*!< GPIO2         */
    GPIO2_BIT_MUXSEL_PWM5B     = 2,  /*!< PWM5B         */
    GPIO2_BIT_MUXSEL_ECAPO     = 7,  /*!< ECAP output   */
} GPIO2_BIT_MUXSEL;

#define GPIO2_ALL_MUXSEL_ADC1      ((0x0UL) << GPIO2_ALL_MUXSEL_Pos)
#define GPIO2_ALL_MUXSEL_GPIO2     ((0x1UL) << GPIO2_ALL_MUXSEL_Pos)
#define GPIO2_ALL_MUXSEL_PWM5B     ((0x2UL) << GPIO2_ALL_MUXSEL_Pos)
#define GPIO2_ALL_MUXSEL_ECAPO     ((0x7UL) << GPIO2_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO2           DEMUX
 *  @access     PINMUX->GPIO2.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO2_ALL_DEMUX_Pos (3)
#define GPIO2_ALL_DEMUX_Msk (0xFFUL << GPIO2_ALL_DEMUX_Pos)

#define GPIO2_BIT_DEMUX

#define GPIO2_ALL_DEMUX_(x) ((x) << GPIO2_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO2           NPU
 *  @access     PINMUX->GPIO2.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO2_ALL_NPU_Pos (11)
#define GPIO2_ALL_NPU_Msk (0xFFUL << GPIO2_ALL_NPU_Pos)

#define GPIO2_BIT_NPU

#define GPIO2_ALL_NPU_(x) ((x) << GPIO2_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO2           DEGLITCH
 *  @access     PINMUX->GPIO2.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO2_ALL_DEGLITCH_Pos (19)
#define GPIO2_ALL_DEGLITCH_Msk (0x1UL << GPIO2_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO2_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO2_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO2_BIT_DEGLITCH;

#define GPIO2_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO2_ALL_DEGLITCH_Pos)
#define GPIO2_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO2_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO3           MUXSEL
 *  @access     PINMUX->GPIO3.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO3_ALL_MUXSEL_Pos (0)
#define GPIO3_ALL_MUXSEL_Msk (0x7UL << GPIO3_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO3_BIT_MUXSEL_ADC2      = 0,  /*!< ADC2          */
    GPIO3_BIT_MUXSEL_GPIO3     = 1,  /*!< GPIO3         */
    GPIO3_BIT_MUXSEL_PWM5A     = 2,  /*!< PWM5A         */
    GPIO3_BIT_MUXSEL_ECAPO     = 7,  /*!< ECAP output   */
} GPIO3_BIT_MUXSEL;

#define GPIO3_ALL_MUXSEL_ADC2      ((0x0UL) << GPIO3_ALL_MUXSEL_Pos)
#define GPIO3_ALL_MUXSEL_GPIO3     ((0x1UL) << GPIO3_ALL_MUXSEL_Pos)
#define GPIO3_ALL_MUXSEL_PWM5A     ((0x2UL) << GPIO3_ALL_MUXSEL_Pos)
#define GPIO3_ALL_MUXSEL_ECAPO     ((0x7UL) << GPIO3_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO3           DEMUX
 *  @access     PINMUX->GPIO3.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO3_ALL_DEMUX_Pos (3)
#define GPIO3_ALL_DEMUX_Msk (0xFFUL << GPIO3_ALL_DEMUX_Pos)

#define GPIO3_BIT_DEMUX

#define GPIO3_ALL_DEMUX_(x) ((x) << GPIO3_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO3           NPU
 *  @access     PINMUX->GPIO3.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO3_ALL_NPU_Pos (11)
#define GPIO3_ALL_NPU_Msk (0xFFUL << GPIO3_ALL_NPU_Pos)

#define GPIO3_BIT_NPU

#define GPIO3_ALL_NPU_(x) ((x) << GPIO3_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO3           DEGLITCH
 *  @access     PINMUX->GPIO3.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO3_ALL_DEGLITCH_Pos (19)
#define GPIO3_ALL_DEGLITCH_Msk (0x1UL << GPIO3_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO3_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO3_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO3_BIT_DEGLITCH;

#define GPIO3_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO3_ALL_DEGLITCH_Pos)
#define GPIO3_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO3_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO4           MUXSEL
 *  @access     PINMUX->GPIO4.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO4_ALL_MUXSEL_Pos (0)
#define GPIO4_ALL_MUXSEL_Msk (0x7UL << GPIO4_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO4_BIT_MUXSEL_ADC3      = 0,  /*!< ADC3          */
    GPIO4_BIT_MUXSEL_GPIO4     = 1,  /*!< GPIO4         */
    GPIO4_BIT_MUXSEL_PWM6B     = 2,  /*!< PWM6B         */
    GPIO4_BIT_MUXSEL_ECAPO     = 7,  /*!< ECAP output   */
} GPIO4_BIT_MUXSEL;

#define GPIO4_ALL_MUXSEL_ADC3      ((0x0UL) << GPIO4_ALL_MUXSEL_Pos)
#define GPIO4_ALL_MUXSEL_GPIO4     ((0x1UL) << GPIO4_ALL_MUXSEL_Pos)
#define GPIO4_ALL_MUXSEL_PWM6B     ((0x2UL) << GPIO4_ALL_MUXSEL_Pos)
#define GPIO4_ALL_MUXSEL_ECAPO     ((0x7UL) << GPIO4_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO4           DEMUX
 *  @access     PINMUX->GPIO4.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO4_ALL_DEMUX_Pos (3)
#define GPIO4_ALL_DEMUX_Msk (0xFFUL << GPIO4_ALL_DEMUX_Pos)

#define GPIO4_BIT_DEMUX

#define GPIO4_ALL_DEMUX_(x) ((x) << GPIO4_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO4           NPU
 *  @access     PINMUX->GPIO4.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO4_ALL_NPU_Pos (11)
#define GPIO4_ALL_NPU_Msk (0xFFUL << GPIO4_ALL_NPU_Pos)

#define GPIO4_BIT_NPU

#define GPIO4_ALL_NPU_(x) ((x) << GPIO4_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO4           DEGLITCH
 *  @access     PINMUX->GPIO4.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO4_ALL_DEGLITCH_Pos (19)
#define GPIO4_ALL_DEGLITCH_Msk (0x1UL << GPIO4_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO4_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO4_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO4_BIT_DEGLITCH;

#define GPIO4_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO4_ALL_DEGLITCH_Pos)
#define GPIO4_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO4_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO5           MUXSEL
 *  @access     PINMUX->GPIO5.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO5_ALL_MUXSEL_Pos (0)
#define GPIO5_ALL_MUXSEL_Msk (0x7UL << GPIO5_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO5_BIT_MUXSEL_ADC4      = 0,  /*!< ADC4          */
    GPIO5_BIT_MUXSEL_GPIO5     = 1,  /*!< GPIO5         */
    GPIO5_BIT_MUXSEL_PWM6A     = 2,  /*!< PWM6A         */
    GPIO5_BIT_MUXSEL_ECAPO     = 7,  /*!< ECAP output   */
} GPIO5_BIT_MUXSEL;

#define GPIO5_ALL_MUXSEL_ADC4      ((0x0UL) << GPIO5_ALL_MUXSEL_Pos)
#define GPIO5_ALL_MUXSEL_GPIO5     ((0x1UL) << GPIO5_ALL_MUXSEL_Pos)
#define GPIO5_ALL_MUXSEL_PWM6A     ((0x2UL) << GPIO5_ALL_MUXSEL_Pos)
#define GPIO5_ALL_MUXSEL_ECAPO     ((0x7UL) << GPIO5_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO5           DEMUX
 *  @access     PINMUX->GPIO5.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO5_ALL_DEMUX_Pos (3)
#define GPIO5_ALL_DEMUX_Msk (0xFFUL << GPIO5_ALL_DEMUX_Pos)

#define GPIO5_BIT_DEMUX

#define GPIO5_ALL_DEMUX_(x) ((x) << GPIO5_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO5           NPU
 *  @access     PINMUX->GPIO5.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO5_ALL_NPU_Pos (11)
#define GPIO5_ALL_NPU_Msk (0xFFUL << GPIO5_ALL_NPU_Pos)

#define GPIO5_BIT_NPU

#define GPIO5_ALL_NPU_(x) ((x) << GPIO5_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO5           DEGLITCH
 *  @access     PINMUX->GPIO5.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO5_ALL_DEGLITCH_Pos (19)
#define GPIO5_ALL_DEGLITCH_Msk (0x1UL << GPIO5_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO5_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO5_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO5_BIT_DEGLITCH;

#define GPIO5_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO5_ALL_DEGLITCH_Pos)
#define GPIO5_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO5_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO6           MUXSEL
 *  @access     PINMUX->GPIO6.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO6_ALL_MUXSEL_Pos (0)
#define GPIO6_ALL_MUXSEL_Msk (0x7UL << GPIO6_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO6_BIT_MUXSEL_ADC5      = 0,  /*!< ADC5          */
    GPIO6_BIT_MUXSEL_GPIO6     = 1,  /*!< GPIO6         */
    GPIO6_BIT_MUXSEL_PWM4B     = 2,  /*!< PWM4B         */
    GPIO6_BIT_MUXSEL_ECAPO     = 7,  /*!< ECAP output   */
} GPIO6_BIT_MUXSEL;

#define GPIO6_ALL_MUXSEL_ADC5      ((0x0UL) << GPIO6_ALL_MUXSEL_Pos)
#define GPIO6_ALL_MUXSEL_GPIO6     ((0x1UL) << GPIO6_ALL_MUXSEL_Pos)
#define GPIO6_ALL_MUXSEL_PWM4B     ((0x2UL) << GPIO6_ALL_MUXSEL_Pos)
#define GPIO6_ALL_MUXSEL_ECAPO     ((0x7UL) << GPIO6_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO6           DEMUX
 *  @access     PINMUX->GPIO6.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO6_ALL_DEMUX_Pos (3)
#define GPIO6_ALL_DEMUX_Msk (0xFFUL << GPIO6_ALL_DEMUX_Pos)

#define GPIO6_BIT_DEMUX

#define GPIO6_ALL_DEMUX_(x) ((x) << GPIO6_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO6           NPU
 *  @access     PINMUX->GPIO6.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO6_ALL_NPU_Pos (11)
#define GPIO6_ALL_NPU_Msk (0xFFUL << GPIO6_ALL_NPU_Pos)

#define GPIO6_BIT_NPU

#define GPIO6_ALL_NPU_(x) ((x) << GPIO6_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO6           DEGLITCH
 *  @access     PINMUX->GPIO6.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO6_ALL_DEGLITCH_Pos (19)
#define GPIO6_ALL_DEGLITCH_Msk (0x1UL << GPIO6_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO6_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO6_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO6_BIT_DEGLITCH;

#define GPIO6_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO6_ALL_DEGLITCH_Pos)
#define GPIO6_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO6_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO7           MUXSEL
 *  @access     PINMUX->GPIO7.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO7_ALL_MUXSEL_Pos (0)
#define GPIO7_ALL_MUXSEL_Msk (0x7UL << GPIO7_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO7_BIT_MUXSEL_ADC6      = 0,  /*!< ADC6          */
    GPIO7_BIT_MUXSEL_GPIO7     = 1,  /*!< GPIO7         */
    GPIO7_BIT_MUXSEL_PWM4A     = 2,  /*!< PWM4A         */
    GPIO7_BIT_MUXSEL_ECAPO     = 7,  /*!< ECAP output   */
} GPIO7_BIT_MUXSEL;

#define GPIO7_ALL_MUXSEL_ADC6      ((0x0UL) << GPIO7_ALL_MUXSEL_Pos)
#define GPIO7_ALL_MUXSEL_GPIO7     ((0x1UL) << GPIO7_ALL_MUXSEL_Pos)
#define GPIO7_ALL_MUXSEL_PWM4A     ((0x2UL) << GPIO7_ALL_MUXSEL_Pos)
#define GPIO7_ALL_MUXSEL_ECAPO     ((0x7UL) << GPIO7_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO7           DEMUX
 *  @access     PINMUX->GPIO7.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO7_ALL_DEMUX_Pos (3)
#define GPIO7_ALL_DEMUX_Msk (0xFFUL << GPIO7_ALL_DEMUX_Pos)

#define GPIO7_BIT_DEMUX

#define GPIO7_ALL_DEMUX_(x) ((x) << GPIO7_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO7           NPU
 *  @access     PINMUX->GPIO7.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO7_ALL_NPU_Pos (11)
#define GPIO7_ALL_NPU_Msk (0xFFUL << GPIO7_ALL_NPU_Pos)

#define GPIO7_BIT_NPU

#define GPIO7_ALL_NPU_(x) ((x) << GPIO7_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO7           DEGLITCH
 *  @access     PINMUX->GPIO7.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO7_ALL_DEGLITCH_Pos (19)
#define GPIO7_ALL_DEGLITCH_Msk (0x1UL << GPIO7_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO7_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO7_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO7_BIT_DEGLITCH;

#define GPIO7_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO7_ALL_DEGLITCH_Pos)
#define GPIO7_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO7_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO8           MUXSEL
 *  @access     PINMUX->GPIO8.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO8_ALL_MUXSEL_Pos (0)
#define GPIO8_ALL_MUXSEL_Msk (0x7UL << GPIO8_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO8_BIT_MUXSEL_ADC7          = 0,  /*!< ADC7          */
    GPIO8_BIT_MUXSEL_GPIO8         = 1,  /*!< GPIO8         */
    GPIO8_BIT_MUXSEL_PWM4A         = 2,  /*!< PWM4A         */
    GPIO8_BIT_MUXSEL_COMP0HOUT     = 3,  /*!< COMP0HOUT     */
    GPIO8_BIT_MUXSEL_ECAPO         = 7,  /*!< ECAP output   */
} GPIO8_BIT_MUXSEL;

#define GPIO8_ALL_MUXSEL_ADC7          ((0x0UL) << GPIO8_ALL_MUXSEL_Pos)
#define GPIO8_ALL_MUXSEL_GPIO8         ((0x1UL) << GPIO8_ALL_MUXSEL_Pos)
#define GPIO8_ALL_MUXSEL_PWM4A         ((0x2UL) << GPIO8_ALL_MUXSEL_Pos)
#define GPIO8_ALL_MUXSEL_COMP0HOUT     ((0x3UL) << GPIO8_ALL_MUXSEL_Pos)
#define GPIO8_ALL_MUXSEL_ECAPO         ((0x7UL) << GPIO8_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO8           DEMUX
 *  @access     PINMUX->GPIO8.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO8_ALL_DEMUX_Pos (3)
#define GPIO8_ALL_DEMUX_Msk (0xFFUL << GPIO8_ALL_DEMUX_Pos)

#define GPIO8_BIT_DEMUX

#define GPIO8_ALL_DEMUX_(x) ((x) << GPIO8_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO8           NPU
 *  @access     PINMUX->GPIO8.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO8_ALL_NPU_Pos (11)
#define GPIO8_ALL_NPU_Msk (0xFFUL << GPIO8_ALL_NPU_Pos)

#define GPIO8_BIT_NPU

#define GPIO8_ALL_NPU_(x) ((x) << GPIO8_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO8           DEGLITCH
 *  @access     PINMUX->GPIO8.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO8_ALL_DEGLITCH_Pos (19)
#define GPIO8_ALL_DEGLITCH_Msk (0x1UL << GPIO8_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO8_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO8_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO8_BIT_DEGLITCH;

#define GPIO8_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO8_ALL_DEGLITCH_Pos)
#define GPIO8_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO8_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO9           MUXSEL
 *  @access     PINMUX->GPIO9.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO9_ALL_MUXSEL_Pos (0)
#define GPIO9_ALL_MUXSEL_Msk (0x7UL << GPIO9_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO9_BIT_MUXSEL_ADC8          = 0,  /*!< ADC8          */
    GPIO9_BIT_MUXSEL_GPIO9         = 1,  /*!< GPIO9         */
    GPIO9_BIT_MUXSEL_PWM4B         = 2,  /*!< PWM4B         */
    GPIO9_BIT_MUXSEL_COMP1HOUT     = 3,  /*!< COMP1HOUT     */
    GPIO9_BIT_MUXSEL_ECAPO         = 7,  /*!< ECAP output   */
} GPIO9_BIT_MUXSEL;

#define GPIO9_ALL_MUXSEL_ADC8          ((0x0UL) << GPIO9_ALL_MUXSEL_Pos)
#define GPIO9_ALL_MUXSEL_GPIO9         ((0x1UL) << GPIO9_ALL_MUXSEL_Pos)
#define GPIO9_ALL_MUXSEL_PWM4B         ((0x2UL) << GPIO9_ALL_MUXSEL_Pos)
#define GPIO9_ALL_MUXSEL_COMP1HOUT     ((0x3UL) << GPIO9_ALL_MUXSEL_Pos)
#define GPIO9_ALL_MUXSEL_ECAPO         ((0x7UL) << GPIO9_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO9           DEMUX
 *  @access     PINMUX->GPIO9.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO9_ALL_DEMUX_Pos (3)
#define GPIO9_ALL_DEMUX_Msk (0xFFUL << GPIO9_ALL_DEMUX_Pos)

#define GPIO9_BIT_DEMUX

#define GPIO9_ALL_DEMUX_(x) ((x) << GPIO9_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO9           NPU
 *  @access     PINMUX->GPIO9.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO9_ALL_NPU_Pos (11)
#define GPIO9_ALL_NPU_Msk (0xFFUL << GPIO9_ALL_NPU_Pos)

#define GPIO9_BIT_NPU

#define GPIO9_ALL_NPU_(x) ((x) << GPIO9_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO9           DEGLITCH
 *  @access     PINMUX->GPIO9.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO9_ALL_DEGLITCH_Pos (19)
#define GPIO9_ALL_DEGLITCH_Msk (0x1UL << GPIO9_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO9_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO9_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO9_BIT_DEGLITCH;

#define GPIO9_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO9_ALL_DEGLITCH_Pos)
#define GPIO9_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO9_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO10          MUXSEL
 *  @access     PINMUX->GPIO10.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO10_ALL_MUXSEL_Pos (0)
#define GPIO10_ALL_MUXSEL_Msk (0x7UL << GPIO10_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO10_BIT_MUXSEL_ADC9          = 0,  /*!< ADC9          */
    GPIO10_BIT_MUXSEL_GPIO10        = 1,  /*!< GPIO10        */
    GPIO10_BIT_MUXSEL_PWM6A         = 2,  /*!< PWM6A         */
    GPIO10_BIT_MUXSEL_COMP2HOUT     = 3,  /*!< COMP2HOUT     */
    GPIO10_BIT_MUXSEL_ECAPO         = 7,  /*!< ECAP output   */
} GPIO10_BIT_MUXSEL;

#define GPIO10_ALL_MUXSEL_ADC9          ((0x0UL) << GPIO10_ALL_MUXSEL_Pos)
#define GPIO10_ALL_MUXSEL_GPIO10        ((0x1UL) << GPIO10_ALL_MUXSEL_Pos)
#define GPIO10_ALL_MUXSEL_PWM6A         ((0x2UL) << GPIO10_ALL_MUXSEL_Pos)
#define GPIO10_ALL_MUXSEL_COMP2HOUT     ((0x3UL) << GPIO10_ALL_MUXSEL_Pos)
#define GPIO10_ALL_MUXSEL_ECAPO         ((0x7UL) << GPIO10_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO10          DEMUX
 *  @access     PINMUX->GPIO10.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO10_ALL_DEMUX_Pos (3)
#define GPIO10_ALL_DEMUX_Msk (0xFFUL << GPIO10_ALL_DEMUX_Pos)

#define GPIO10_BIT_DEMUX

#define GPIO10_ALL_DEMUX_(x) ((x) << GPIO10_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO10          NPU
 *  @access     PINMUX->GPIO10.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO10_ALL_NPU_Pos (11)
#define GPIO10_ALL_NPU_Msk (0xFFUL << GPIO10_ALL_NPU_Pos)

#define GPIO10_BIT_NPU

#define GPIO10_ALL_NPU_(x) ((x) << GPIO10_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO10          DEGLITCH
 *  @access     PINMUX->GPIO10.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO10_ALL_DEGLITCH_Pos (19)
#define GPIO10_ALL_DEGLITCH_Msk (0x1UL << GPIO10_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO10_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO10_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO10_BIT_DEGLITCH;

#define GPIO10_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO10_ALL_DEGLITCH_Pos)
#define GPIO10_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO10_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO11          MUXSEL
 *  @access     PINMUX->GPIO11.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO11_ALL_MUXSEL_Pos (0)
#define GPIO11_ALL_MUXSEL_Msk (0x7UL << GPIO11_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO11_BIT_MUXSEL_ADC10         = 0,  /*!< ADC10         */
    GPIO11_BIT_MUXSEL_GPIO11        = 1,  /*!< GPIO11        */
    GPIO11_BIT_MUXSEL_PWM6B         = 2,  /*!< PWM6B         */
    GPIO11_BIT_MUXSEL_COMP0LOUT     = 3,  /*!< COMP0LOUT     */
    GPIO11_BIT_MUXSEL_ECAPO         = 7,  /*!< ECAP output   */
} GPIO11_BIT_MUXSEL;

#define GPIO11_ALL_MUXSEL_ADC10         ((0x0UL) << GPIO11_ALL_MUXSEL_Pos)
#define GPIO11_ALL_MUXSEL_GPIO11        ((0x1UL) << GPIO11_ALL_MUXSEL_Pos)
#define GPIO11_ALL_MUXSEL_PWM6B         ((0x2UL) << GPIO11_ALL_MUXSEL_Pos)
#define GPIO11_ALL_MUXSEL_COMP0LOUT     ((0x3UL) << GPIO11_ALL_MUXSEL_Pos)
#define GPIO11_ALL_MUXSEL_ECAPO         ((0x7UL) << GPIO11_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO11          DEMUX
 *  @access     PINMUX->GPIO11.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO11_ALL_DEMUX_Pos (3)
#define GPIO11_ALL_DEMUX_Msk (0xFFUL << GPIO11_ALL_DEMUX_Pos)

#define GPIO11_BIT_DEMUX

#define GPIO11_ALL_DEMUX_(x) ((x) << GPIO11_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO11          NPU
 *  @access     PINMUX->GPIO11.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO11_ALL_NPU_Pos (11)
#define GPIO11_ALL_NPU_Msk (0xFFUL << GPIO11_ALL_NPU_Pos)

#define GPIO11_BIT_NPU

#define GPIO11_ALL_NPU_(x) ((x) << GPIO11_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO11          DEGLITCH
 *  @access     PINMUX->GPIO11.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO11_ALL_DEGLITCH_Pos (19)
#define GPIO11_ALL_DEGLITCH_Msk (0x1UL << GPIO11_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO11_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO11_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO11_BIT_DEGLITCH;

#define GPIO11_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO11_ALL_DEGLITCH_Pos)
#define GPIO11_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO11_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO12          MUXSEL
 *  @access     PINMUX->GPIO12.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO12_ALL_MUXSEL_Pos (0)
#define GPIO12_ALL_MUXSEL_Msk (0x7UL << GPIO12_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO12_BIT_MUXSEL_ADC11         = 0,  /*!< ADC11         */
    GPIO12_BIT_MUXSEL_GPIO12        = 1,  /*!< GPIO12        */
    GPIO12_BIT_MUXSEL_PWM5A         = 2,  /*!< PWM5A         */
    GPIO12_BIT_MUXSEL_COMP1LOUT     = 3,  /*!< COMP1LOUT     */
    GPIO12_BIT_MUXSEL_ECAPO         = 7,  /*!< ECAP output   */
} GPIO12_BIT_MUXSEL;

#define GPIO12_ALL_MUXSEL_ADC11         ((0x0UL) << GPIO12_ALL_MUXSEL_Pos)
#define GPIO12_ALL_MUXSEL_GPIO12        ((0x1UL) << GPIO12_ALL_MUXSEL_Pos)
#define GPIO12_ALL_MUXSEL_PWM5A         ((0x2UL) << GPIO12_ALL_MUXSEL_Pos)
#define GPIO12_ALL_MUXSEL_COMP1LOUT     ((0x3UL) << GPIO12_ALL_MUXSEL_Pos)
#define GPIO12_ALL_MUXSEL_ECAPO         ((0x7UL) << GPIO12_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO12          DEMUX
 *  @access     PINMUX->GPIO12.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO12_ALL_DEMUX_Pos (3)
#define GPIO12_ALL_DEMUX_Msk (0xFFUL << GPIO12_ALL_DEMUX_Pos)

#define GPIO12_BIT_DEMUX

#define GPIO12_ALL_DEMUX_(x) ((x) << GPIO12_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO12          NPU
 *  @access     PINMUX->GPIO12.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO12_ALL_NPU_Pos (11)
#define GPIO12_ALL_NPU_Msk (0xFFUL << GPIO12_ALL_NPU_Pos)

#define GPIO12_BIT_NPU

#define GPIO12_ALL_NPU_(x) ((x) << GPIO12_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO12          DEGLITCH
 *  @access     PINMUX->GPIO12.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO12_ALL_DEGLITCH_Pos (19)
#define GPIO12_ALL_DEGLITCH_Msk (0x1UL << GPIO12_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO12_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO12_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO12_BIT_DEGLITCH;

#define GPIO12_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO12_ALL_DEGLITCH_Pos)
#define GPIO12_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO12_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO13          MUXSEL
 *  @access     PINMUX->GPIO13.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO13_ALL_MUXSEL_Pos (0)
#define GPIO13_ALL_MUXSEL_Msk (0x7UL << GPIO13_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO13_BIT_MUXSEL_ADC12         = 0,  /*!< ADC12         */
    GPIO13_BIT_MUXSEL_GPIO13        = 1,  /*!< GPIO13        */
    GPIO13_BIT_MUXSEL_PWM5B         = 2,  /*!< PWM5B         */
    GPIO13_BIT_MUXSEL_COMP2LOUT     = 3,  /*!< COMP2LOUT     */
    GPIO13_BIT_MUXSEL_ECAPO         = 7,  /*!< ECAP output   */
} GPIO13_BIT_MUXSEL;

#define GPIO13_ALL_MUXSEL_ADC12         ((0x0UL) << GPIO13_ALL_MUXSEL_Pos)
#define GPIO13_ALL_MUXSEL_GPIO13        ((0x1UL) << GPIO13_ALL_MUXSEL_Pos)
#define GPIO13_ALL_MUXSEL_PWM5B         ((0x2UL) << GPIO13_ALL_MUXSEL_Pos)
#define GPIO13_ALL_MUXSEL_COMP2LOUT     ((0x3UL) << GPIO13_ALL_MUXSEL_Pos)
#define GPIO13_ALL_MUXSEL_ECAPO         ((0x7UL) << GPIO13_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO13          DEMUX
 *  @access     PINMUX->GPIO13.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO13_ALL_DEMUX_Pos (3)
#define GPIO13_ALL_DEMUX_Msk (0xFFUL << GPIO13_ALL_DEMUX_Pos)

#define GPIO13_BIT_DEMUX

#define GPIO13_ALL_DEMUX_(x) ((x) << GPIO13_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO13          NPU
 *  @access     PINMUX->GPIO13.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO13_ALL_NPU_Pos (11)
#define GPIO13_ALL_NPU_Msk (0xFFUL << GPIO13_ALL_NPU_Pos)

#define GPIO13_BIT_NPU

#define GPIO13_ALL_NPU_(x) ((x) << GPIO13_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO13          DEGLITCH
 *  @access     PINMUX->GPIO13.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO13_ALL_DEGLITCH_Pos (19)
#define GPIO13_ALL_DEGLITCH_Msk (0x1UL << GPIO13_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO13_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO13_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO13_BIT_DEGLITCH;

#define GPIO13_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO13_ALL_DEGLITCH_Pos)
#define GPIO13_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO13_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO14          MUXSEL
 *  @access     PINMUX->GPIO14.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO14_ALL_MUXSEL_Pos (0)
#define GPIO14_ALL_MUXSEL_Msk (0x7UL << GPIO14_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO14_BIT_MUXSEL_ADC13      = 0,  /*!< ADC13         */
    GPIO14_BIT_MUXSEL_GPIO14     = 1,  /*!< GPIO14        */
    GPIO14_BIT_MUXSEL_ECAPO      = 7,  /*!< ECAP output   */
} GPIO14_BIT_MUXSEL;

#define GPIO14_ALL_MUXSEL_ADC13      ((0x0UL) << GPIO14_ALL_MUXSEL_Pos)
#define GPIO14_ALL_MUXSEL_GPIO14     ((0x1UL) << GPIO14_ALL_MUXSEL_Pos)
#define GPIO14_ALL_MUXSEL_ECAPO      ((0x7UL) << GPIO14_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO14          DEMUX
 *  @access     PINMUX->GPIO14.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO14_ALL_DEMUX_Pos (3)
#define GPIO14_ALL_DEMUX_Msk (0xFFUL << GPIO14_ALL_DEMUX_Pos)

#define GPIO14_BIT_DEMUX

#define GPIO14_ALL_DEMUX_(x) ((x) << GPIO14_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO14          NPU
 *  @access     PINMUX->GPIO14.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO14_ALL_NPU_Pos (11)
#define GPIO14_ALL_NPU_Msk (0xFFUL << GPIO14_ALL_NPU_Pos)

#define GPIO14_BIT_NPU

#define GPIO14_ALL_NPU_(x) ((x) << GPIO14_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO14          DEGLITCH
 *  @access     PINMUX->GPIO14.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO14_ALL_DEGLITCH_Pos (19)
#define GPIO14_ALL_DEGLITCH_Msk (0x1UL << GPIO14_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO14_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO14_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO14_BIT_DEGLITCH;

#define GPIO14_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO14_ALL_DEGLITCH_Pos)
#define GPIO14_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO14_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO15          MUXSEL
 *  @access     PINMUX->GPIO15.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO15_ALL_MUXSEL_Pos (0)
#define GPIO15_ALL_MUXSEL_Msk (0x7UL << GPIO15_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO15_BIT_MUXSEL_ADC14      = 0,  /*!< ADC14         */
    GPIO15_BIT_MUXSEL_GPIO15     = 1,  /*!< GPIO15        */
    GPIO15_BIT_MUXSEL_TDI        = 2,  /*!< TDI           */
    GPIO15_BIT_MUXSEL_ECAPO      = 7,  /*!< ECAP output   */
} GPIO15_BIT_MUXSEL;

#define GPIO15_ALL_MUXSEL_ADC14      ((0x0UL) << GPIO15_ALL_MUXSEL_Pos)
#define GPIO15_ALL_MUXSEL_GPIO15     ((0x1UL) << GPIO15_ALL_MUXSEL_Pos)
#define GPIO15_ALL_MUXSEL_TDI        ((0x2UL) << GPIO15_ALL_MUXSEL_Pos)
#define GPIO15_ALL_MUXSEL_ECAPO      ((0x7UL) << GPIO15_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO15          DEMUX
 *  @access     PINMUX->GPIO15.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO15_ALL_DEMUX_Pos (3)
#define GPIO15_ALL_DEMUX_Msk (0xFFUL << GPIO15_ALL_DEMUX_Pos)

#define GPIO15_BIT_DEMUX

#define GPIO15_ALL_DEMUX_(x) ((x) << GPIO15_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO15          NPU
 *  @access     PINMUX->GPIO15.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO15_ALL_NPU_Pos (11)
#define GPIO15_ALL_NPU_Msk (0xFFUL << GPIO15_ALL_NPU_Pos)

#define GPIO15_BIT_NPU

#define GPIO15_ALL_NPU_(x) ((x) << GPIO15_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO15          DEGLITCH
 *  @access     PINMUX->GPIO15.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO15_ALL_DEGLITCH_Pos (19)
#define GPIO15_ALL_DEGLITCH_Msk (0x1UL << GPIO15_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO15_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO15_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO15_BIT_DEGLITCH;

#define GPIO15_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO15_ALL_DEGLITCH_Pos)
#define GPIO15_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO15_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO16          MUXSEL
 *  @access     PINMUX->GPIO16.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO16_ALL_MUXSEL_Pos (0)
#define GPIO16_ALL_MUXSEL_Msk (0x7UL << GPIO16_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO16_BIT_MUXSEL_ADC15       = 0,  /*!< ADC15         */
    GPIO16_BIT_MUXSEL_GPIO16      = 1,  /*!< GPIO16        */
    GPIO16_BIT_MUXSEL_TMS_SWD     = 2,  /*!< TMS/SWD       */
    GPIO16_BIT_MUXSEL_ECAPO       = 7,  /*!< ECAP output   */
} GPIO16_BIT_MUXSEL;

#define GPIO16_ALL_MUXSEL_ADC15       ((0x0UL) << GPIO16_ALL_MUXSEL_Pos)
#define GPIO16_ALL_MUXSEL_GPIO16      ((0x1UL) << GPIO16_ALL_MUXSEL_Pos)
#define GPIO16_ALL_MUXSEL_TMS_SWD     ((0x2UL) << GPIO16_ALL_MUXSEL_Pos)
#define GPIO16_ALL_MUXSEL_ECAPO       ((0x7UL) << GPIO16_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO16          DEMUX
 *  @access     PINMUX->GPIO16.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO16_ALL_DEMUX_Pos (3)
#define GPIO16_ALL_DEMUX_Msk (0xFFUL << GPIO16_ALL_DEMUX_Pos)

#define GPIO16_BIT_DEMUX

#define GPIO16_ALL_DEMUX_(x) ((x) << GPIO16_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO16          NPU
 *  @access     PINMUX->GPIO16.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO16_ALL_NPU_Pos (11)
#define GPIO16_ALL_NPU_Msk (0xFFUL << GPIO16_ALL_NPU_Pos)

#define GPIO16_BIT_NPU

#define GPIO16_ALL_NPU_(x) ((x) << GPIO16_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO16          DEGLITCH
 *  @access     PINMUX->GPIO16.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO16_ALL_DEGLITCH_Pos (19)
#define GPIO16_ALL_DEGLITCH_Msk (0x1UL << GPIO16_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO16_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO16_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO16_BIT_DEGLITCH;

#define GPIO16_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO16_ALL_DEGLITCH_Pos)
#define GPIO16_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO16_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO17          MUXSEL
 *  @access     PINMUX->GPIO17.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO17_ALL_MUXSEL_Pos (0)
#define GPIO17_ALL_MUXSEL_Msk (0x7UL << GPIO17_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO17_BIT_MUXSEL_GPIO17      = 0,  /*!< GPIO17        */
    GPIO17_BIT_MUXSEL_TDO         = 2,  /*!< TDO           */
    GPIO17_BIT_MUXSEL_TMS_SWD     = 3,  /*!< TMS/SWD       */
    GPIO17_BIT_MUXSEL_SPI_FRM     = 5,  /*!< SPI_FRM       */
    GPIO17_BIT_MUXSEL_PWM6B       = 6,  /*!< PWM6B         */
    GPIO17_BIT_MUXSEL_ECAPO       = 7,  /*!< ECAP output   */
} GPIO17_BIT_MUXSEL;

#define GPIO17_ALL_MUXSEL_GPIO17      ((0x0UL) << GPIO17_ALL_MUXSEL_Pos)
#define GPIO17_ALL_MUXSEL_TDO         ((0x2UL) << GPIO17_ALL_MUXSEL_Pos)
#define GPIO17_ALL_MUXSEL_TMS_SWD     ((0x3UL) << GPIO17_ALL_MUXSEL_Pos)
#define GPIO17_ALL_MUXSEL_SPI_FRM     ((0x5UL) << GPIO17_ALL_MUXSEL_Pos)
#define GPIO17_ALL_MUXSEL_PWM6B       ((0x6UL) << GPIO17_ALL_MUXSEL_Pos)
#define GPIO17_ALL_MUXSEL_ECAPO       ((0x7UL) << GPIO17_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO17          DEMUX
 *  @access     PINMUX->GPIO17.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO17_ALL_DEMUX_Pos (3)
#define GPIO17_ALL_DEMUX_Msk (0xFFUL << GPIO17_ALL_DEMUX_Pos)

#define GPIO17_BIT_DEMUX

#define GPIO17_ALL_DEMUX_(x) ((x) << GPIO17_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO17          NPU
 *  @access     PINMUX->GPIO17.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO17_ALL_NPU_Pos (11)
#define GPIO17_ALL_NPU_Msk (0xFFUL << GPIO17_ALL_NPU_Pos)

#define GPIO17_BIT_NPU

#define GPIO17_ALL_NPU_(x) ((x) << GPIO17_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO17          DEGLITCH
 *  @access     PINMUX->GPIO17.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO17_ALL_DEGLITCH_Pos (19)
#define GPIO17_ALL_DEGLITCH_Msk (0x1UL << GPIO17_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO17_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO17_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO17_BIT_DEGLITCH;

#define GPIO17_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO17_ALL_DEGLITCH_Pos)
#define GPIO17_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO17_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO18          MUXSEL
 *  @access     PINMUX->GPIO18.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO18_ALL_MUXSEL_Pos (0)
#define GPIO18_ALL_MUXSEL_Msk (0x7UL << GPIO18_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO18_BIT_MUXSEL_GPIO18       = 0,  /*!< GPIO18        */
    GPIO18_BIT_MUXSEL_SPIMO        = 1,  /*!< SPIMO         */
    GPIO18_BIT_MUXSEL_TCK_SWCK     = 2,  /*!< TCK/SWCK      */
    GPIO18_BIT_MUXSEL_I2C_SDA      = 4,  /*!< I2C_SDA       */
    GPIO18_BIT_MUXSEL_SPIMI        = 5,  /*!< SPIMI         */
    GPIO18_BIT_MUXSEL_PWM6A        = 6,  /*!< PWM6A         */
    GPIO18_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO18_BIT_MUXSEL;

#define GPIO18_ALL_MUXSEL_GPIO18       ((0x0UL) << GPIO18_ALL_MUXSEL_Pos)
#define GPIO18_ALL_MUXSEL_SPIMO        ((0x1UL) << GPIO18_ALL_MUXSEL_Pos)
#define GPIO18_ALL_MUXSEL_TCK_SWCK     ((0x2UL) << GPIO18_ALL_MUXSEL_Pos)
#define GPIO18_ALL_MUXSEL_I2C_SDA      ((0x4UL) << GPIO18_ALL_MUXSEL_Pos)
#define GPIO18_ALL_MUXSEL_SPIMI        ((0x5UL) << GPIO18_ALL_MUXSEL_Pos)
#define GPIO18_ALL_MUXSEL_PWM6A        ((0x6UL) << GPIO18_ALL_MUXSEL_Pos)
#define GPIO18_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO18_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO18          DEMUX
 *  @access     PINMUX->GPIO18.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO18_ALL_DEMUX_Pos (3)
#define GPIO18_ALL_DEMUX_Msk (0xFFUL << GPIO18_ALL_DEMUX_Pos)

#define GPIO18_BIT_DEMUX

#define GPIO18_ALL_DEMUX_(x) ((x) << GPIO18_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO18          NPU
 *  @access     PINMUX->GPIO18.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO18_ALL_NPU_Pos (11)
#define GPIO18_ALL_NPU_Msk (0xFFUL << GPIO18_ALL_NPU_Pos)

#define GPIO18_BIT_NPU

#define GPIO18_ALL_NPU_(x) ((x) << GPIO18_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO18          DEGLITCH
 *  @access     PINMUX->GPIO18.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO18_ALL_DEGLITCH_Pos (19)
#define GPIO18_ALL_DEGLITCH_Msk (0x1UL << GPIO18_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO18_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO18_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO18_BIT_DEGLITCH;

#define GPIO18_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO18_ALL_DEGLITCH_Pos)
#define GPIO18_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO18_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO19          MUXSEL
 *  @access     PINMUX->GPIO19.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO19_ALL_MUXSEL_Pos (0)
#define GPIO19_ALL_MUXSEL_Msk (0x7UL << GPIO19_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO19_BIT_MUXSEL_GPIO19       = 0,  /*!< GPIO19        */
    GPIO19_BIT_MUXSEL_SPICLK       = 1,  /*!< SPICLK        */
    GPIO19_BIT_MUXSEL_UART_TXD     = 2,  /*!< UART_TXD      */
    GPIO19_BIT_MUXSEL_CLK_TEST     = 3,  /*!< CLK_TEST      */
    GPIO19_BIT_MUXSEL_I2C_SCL      = 4,  /*!< I2C_SCL       */
    // GPIO19_BIT_MUXSEL_SPICLK    = 5,  /*!< SPICLK        */
    GPIO19_BIT_MUXSEL_PWM5B        = 6,  /*!< PWM5B         */
    GPIO19_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO19_BIT_MUXSEL;

#define GPIO19_ALL_MUXSEL_GPIO19       ((0x0UL) << GPIO19_ALL_MUXSEL_Pos)
#define GPIO19_ALL_MUXSEL_SPICLK       ((0x1UL) << GPIO19_ALL_MUXSEL_Pos)
#define GPIO19_ALL_MUXSEL_UART_TXD     ((0x2UL) << GPIO19_ALL_MUXSEL_Pos)
#define GPIO19_ALL_MUXSEL_CLK_TEST     ((0x3UL) << GPIO19_ALL_MUXSEL_Pos)
#define GPIO19_ALL_MUXSEL_I2C_SCL      ((0x4UL) << GPIO19_ALL_MUXSEL_Pos)
// #define GPIO19_ALL_MUXSEL_SPICLK       ((0x5UL) << GPIO19_ALL_MUXSEL_Pos)
#define GPIO19_ALL_MUXSEL_PWM5B        ((0x6UL) << GPIO19_ALL_MUXSEL_Pos)
#define GPIO19_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO19_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO19          DEMUX
 *  @access     PINMUX->GPIO19.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO19_ALL_DEMUX_Pos (3)
#define GPIO19_ALL_DEMUX_Msk (0xFFUL << GPIO19_ALL_DEMUX_Pos)

#define GPIO19_BIT_DEMUX

#define GPIO19_ALL_DEMUX_(x) ((x) << GPIO19_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO19          NPU
 *  @access     PINMUX->GPIO19.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO19_ALL_NPU_Pos (11)
#define GPIO19_ALL_NPU_Msk (0xFFUL << GPIO19_ALL_NPU_Pos)

#define GPIO19_BIT_NPU

#define GPIO19_ALL_NPU_(x) ((x) << GPIO19_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO19          DEGLITCH
 *  @access     PINMUX->GPIO19.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO19_ALL_DEGLITCH_Pos (19)
#define GPIO19_ALL_DEGLITCH_Msk (0x1UL << GPIO19_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO19_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO19_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO19_BIT_DEGLITCH;

#define GPIO19_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO19_ALL_DEGLITCH_Pos)
#define GPIO19_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO19_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO20          MUXSEL
 *  @access     PINMUX->GPIO20.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO20_ALL_MUXSEL_Pos (0)
#define GPIO20_ALL_MUXSEL_Msk (0x7UL << GPIO20_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO20_BIT_MUXSEL_GPIO20       = 0,  /*!< GPIO20        */
    GPIO20_BIT_MUXSEL_SPI_FRM      = 2,  /*!< SPI_FRM       */
    GPIO20_BIT_MUXSEL_UART_RXD     = 3,  /*!< UART_RXD      */
    GPIO20_BIT_MUXSEL_PWM5A        = 6,  /*!< PWM5A         */
    GPIO20_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO20_BIT_MUXSEL;

#define GPIO20_ALL_MUXSEL_GPIO20       ((0x0UL) << GPIO20_ALL_MUXSEL_Pos)
#define GPIO20_ALL_MUXSEL_SPI_FRM      ((0x2UL) << GPIO20_ALL_MUXSEL_Pos)
#define GPIO20_ALL_MUXSEL_UART_RXD     ((0x3UL) << GPIO20_ALL_MUXSEL_Pos)
#define GPIO20_ALL_MUXSEL_PWM5A        ((0x6UL) << GPIO20_ALL_MUXSEL_Pos)
#define GPIO20_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO20_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO20          DEMUX
 *  @access     PINMUX->GPIO20.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO20_ALL_DEMUX_Pos (3)
#define GPIO20_ALL_DEMUX_Msk (0xFFUL << GPIO20_ALL_DEMUX_Pos)

#define GPIO20_BIT_DEMUX

#define GPIO20_ALL_DEMUX_(x) ((x) << GPIO20_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO20          NPU
 *  @access     PINMUX->GPIO20.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO20_ALL_NPU_Pos (11)
#define GPIO20_ALL_NPU_Msk (0xFFUL << GPIO20_ALL_NPU_Pos)

#define GPIO20_BIT_NPU

#define GPIO20_ALL_NPU_(x) ((x) << GPIO20_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO20          DEGLITCH
 *  @access     PINMUX->GPIO20.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO20_ALL_DEGLITCH_Pos (19)
#define GPIO20_ALL_DEGLITCH_Msk (0x1UL << GPIO20_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO20_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO20_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO20_BIT_DEGLITCH;

#define GPIO20_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO20_ALL_DEGLITCH_Pos)
#define GPIO20_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO20_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO21          MUXSEL
 *  @access     PINMUX->GPIO21.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO21_ALL_MUXSEL_Pos (0)
#define GPIO21_ALL_MUXSEL_Msk (0x7UL << GPIO21_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO21_BIT_MUXSEL_GPIO21     = 0,  /*!< GPIO21        */
    GPIO21_BIT_MUXSEL_SPIMI      = 1,  /*!< SPIMI         */
    GPIO21_BIT_MUXSEL_SPISO      = 2,  /*!< SPISO         */
    GPIO21_BIT_MUXSEL_PWM4B      = 6,  /*!< PWM4B         */
    GPIO21_BIT_MUXSEL_ECAPO      = 7,  /*!< ECAP output   */
} GPIO21_BIT_MUXSEL;

#define GPIO21_ALL_MUXSEL_GPIO21     ((0x0UL) << GPIO21_ALL_MUXSEL_Pos)
#define GPIO21_ALL_MUXSEL_SPIMI      ((0x1UL) << GPIO21_ALL_MUXSEL_Pos)
#define GPIO21_ALL_MUXSEL_SPISO      ((0x2UL) << GPIO21_ALL_MUXSEL_Pos)
#define GPIO21_ALL_MUXSEL_PWM4B      ((0x6UL) << GPIO21_ALL_MUXSEL_Pos)
#define GPIO21_ALL_MUXSEL_ECAPO      ((0x7UL) << GPIO21_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO21          DEMUX
 *  @access     PINMUX->GPIO21.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO21_ALL_DEMUX_Pos (3)
#define GPIO21_ALL_DEMUX_Msk (0xFFUL << GPIO21_ALL_DEMUX_Pos)

#define GPIO21_BIT_DEMUX

#define GPIO21_ALL_DEMUX_(x) ((x) << GPIO21_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO21          NPU
 *  @access     PINMUX->GPIO21.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO21_ALL_NPU_Pos (11)
#define GPIO21_ALL_NPU_Msk (0xFFUL << GPIO21_ALL_NPU_Pos)

#define GPIO21_BIT_NPU

#define GPIO21_ALL_NPU_(x) ((x) << GPIO21_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO21          DEGLITCH
 *  @access     PINMUX->GPIO21.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO21_ALL_DEGLITCH_Pos (19)
#define GPIO21_ALL_DEGLITCH_Msk (0x1UL << GPIO21_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO21_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO21_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO21_BIT_DEGLITCH;

#define GPIO21_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO21_ALL_DEGLITCH_Pos)
#define GPIO21_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO21_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO22          MUXSEL
 *  @access     PINMUX->GPIO22.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO22_ALL_MUXSEL_Pos (0)
#define GPIO22_ALL_MUXSEL_Msk (0x7UL << GPIO22_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO22_BIT_MUXSEL_GPIO22     = 0,  /*!< GPIO22        */
    GPIO22_BIT_MUXSEL_SPIMO      = 1,  /*!< SPIMO         */
    GPIO22_BIT_MUXSEL_SPISI      = 2,  /*!< SPISI         */
    GPIO22_BIT_MUXSEL_PWM4A      = 6,  /*!< PWM4A         */
    GPIO22_BIT_MUXSEL_ECAPO      = 7,  /*!< ECAP output   */
} GPIO22_BIT_MUXSEL;

#define GPIO22_ALL_MUXSEL_GPIO22     ((0x0UL) << GPIO22_ALL_MUXSEL_Pos)
#define GPIO22_ALL_MUXSEL_SPIMO      ((0x1UL) << GPIO22_ALL_MUXSEL_Pos)
#define GPIO22_ALL_MUXSEL_SPISI      ((0x2UL) << GPIO22_ALL_MUXSEL_Pos)
#define GPIO22_ALL_MUXSEL_PWM4A      ((0x6UL) << GPIO22_ALL_MUXSEL_Pos)
#define GPIO22_ALL_MUXSEL_ECAPO      ((0x7UL) << GPIO22_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO22          DEMUX
 *  @access     PINMUX->GPIO22.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO22_ALL_DEMUX_Pos (3)
#define GPIO22_ALL_DEMUX_Msk (0xFFUL << GPIO22_ALL_DEMUX_Pos)

#define GPIO22_BIT_DEMUX

#define GPIO22_ALL_DEMUX_(x) ((x) << GPIO22_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO22          NPU
 *  @access     PINMUX->GPIO22.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO22_ALL_NPU_Pos (11)
#define GPIO22_ALL_NPU_Msk (0xFFUL << GPIO22_ALL_NPU_Pos)

#define GPIO22_BIT_NPU

#define GPIO22_ALL_NPU_(x) ((x) << GPIO22_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO22          DEGLITCH
 *  @access     PINMUX->GPIO22.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO22_ALL_DEGLITCH_Pos (19)
#define GPIO22_ALL_DEGLITCH_Msk (0x1UL << GPIO22_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO22_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO22_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO22_BIT_DEGLITCH;

#define GPIO22_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO22_ALL_DEGLITCH_Pos)
#define GPIO22_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO22_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO23          MUXSEL
 *  @access     PINMUX->GPIO23.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO23_ALL_MUXSEL_Pos (0)
#define GPIO23_ALL_MUXSEL_Msk (0x7UL << GPIO23_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO23_BIT_MUXSEL_GPIO23        = 0,  /*!< GPIO23        */
    GPIO23_BIT_MUXSEL_PWM0B         = 1,  /*!< PWM0B         */
    GPIO23_BIT_MUXSEL_COMP0LOUT     = 2,  /*!< COMP0LOUT     */
    GPIO23_BIT_MUXSEL_ECAPO         = 7,  /*!< ECAP output   */
} GPIO23_BIT_MUXSEL;

#define GPIO23_ALL_MUXSEL_GPIO23        ((0x0UL) << GPIO23_ALL_MUXSEL_Pos)
#define GPIO23_ALL_MUXSEL_PWM0B         ((0x1UL) << GPIO23_ALL_MUXSEL_Pos)
#define GPIO23_ALL_MUXSEL_COMP0LOUT     ((0x2UL) << GPIO23_ALL_MUXSEL_Pos)
#define GPIO23_ALL_MUXSEL_ECAPO         ((0x7UL) << GPIO23_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO23          DEMUX
 *  @access     PINMUX->GPIO23.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO23_ALL_DEMUX_Pos (3)
#define GPIO23_ALL_DEMUX_Msk (0xFFUL << GPIO23_ALL_DEMUX_Pos)

#define GPIO23_BIT_DEMUX

#define GPIO23_ALL_DEMUX_(x) ((x) << GPIO23_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO23          NPU
 *  @access     PINMUX->GPIO23.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO23_ALL_NPU_Pos (11)
#define GPIO23_ALL_NPU_Msk (0xFFUL << GPIO23_ALL_NPU_Pos)

#define GPIO23_BIT_NPU

#define GPIO23_ALL_NPU_(x) ((x) << GPIO23_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO23          DEGLITCH
 *  @access     PINMUX->GPIO23.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO23_ALL_DEGLITCH_Pos (19)
#define GPIO23_ALL_DEGLITCH_Msk (0x1UL << GPIO23_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO23_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO23_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO23_BIT_DEGLITCH;

#define GPIO23_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO23_ALL_DEGLITCH_Pos)
#define GPIO23_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO23_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO24          MUXSEL
 *  @access     PINMUX->GPIO24.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO24_ALL_MUXSEL_Pos (0)
#define GPIO24_ALL_MUXSEL_Msk (0x7UL << GPIO24_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO24_BIT_MUXSEL_GPIO24     = 0,  /*!< GPIO24        */
    GPIO24_BIT_MUXSEL_PWM0A      = 1,  /*!< PWM0A         */
    GPIO24_BIT_MUXSEL_ATEST      = 2,  /*!< ATEST         */
    GPIO24_BIT_MUXSEL_ECAPO      = 7,  /*!< ECAP output   */
} GPIO24_BIT_MUXSEL;

#define GPIO24_ALL_MUXSEL_GPIO24     ((0x0UL) << GPIO24_ALL_MUXSEL_Pos)
#define GPIO24_ALL_MUXSEL_PWM0A      ((0x1UL) << GPIO24_ALL_MUXSEL_Pos)
#define GPIO24_ALL_MUXSEL_ATEST      ((0x2UL) << GPIO24_ALL_MUXSEL_Pos)
#define GPIO24_ALL_MUXSEL_ECAPO      ((0x7UL) << GPIO24_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO24          DEMUX
 *  @access     PINMUX->GPIO24.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO24_ALL_DEMUX_Pos (3)
#define GPIO24_ALL_DEMUX_Msk (0xFFUL << GPIO24_ALL_DEMUX_Pos)

#define GPIO24_BIT_DEMUX

#define GPIO24_ALL_DEMUX_(x) ((x) << GPIO24_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO24          NPU
 *  @access     PINMUX->GPIO24.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO24_ALL_NPU_Pos (11)
#define GPIO24_ALL_NPU_Msk (0xFFUL << GPIO24_ALL_NPU_Pos)

#define GPIO24_BIT_NPU

#define GPIO24_ALL_NPU_(x) ((x) << GPIO24_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO24          DEGLITCH
 *  @access     PINMUX->GPIO24.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO24_ALL_DEGLITCH_Pos (19)
#define GPIO24_ALL_DEGLITCH_Msk (0x1UL << GPIO24_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO24_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO24_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO24_BIT_DEGLITCH;

#define GPIO24_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO24_ALL_DEGLITCH_Pos)
#define GPIO24_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO24_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO25          MUXSEL
 *  @access     PINMUX->GPIO25.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO25_ALL_MUXSEL_Pos (0)
#define GPIO25_ALL_MUXSEL_Msk (0x7UL << GPIO25_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO25_BIT_MUXSEL_TEST       = 0,  /*!< TEST          */
    GPIO25_BIT_MUXSEL_GPIO25     = 1,  /*!< GPIO25        */
    GPIO25_BIT_MUXSEL_ECAPO      = 7,  /*!< ECAP output   */
} GPIO25_BIT_MUXSEL;

#define GPIO25_ALL_MUXSEL_TEST       ((0x0UL) << GPIO25_ALL_MUXSEL_Pos)
#define GPIO25_ALL_MUXSEL_GPIO25     ((0x1UL) << GPIO25_ALL_MUXSEL_Pos)
#define GPIO25_ALL_MUXSEL_ECAPO      ((0x7UL) << GPIO25_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO25          DEMUX
 *  @access     PINMUX->GPIO25.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO25_ALL_DEMUX_Pos (3)
#define GPIO25_ALL_DEMUX_Msk (0xFFUL << GPIO25_ALL_DEMUX_Pos)

#define GPIO25_BIT_DEMUX

#define GPIO25_ALL_DEMUX_(x) ((x) << GPIO25_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO25          NPU
 *  @access     PINMUX->GPIO25.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO25_ALL_NPU_Pos (11)
#define GPIO25_ALL_NPU_Msk (0xFFUL << GPIO25_ALL_NPU_Pos)

#define GPIO25_BIT_NPU

#define GPIO25_ALL_NPU_(x) ((x) << GPIO25_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO25          DEGLITCH
 *  @access     PINMUX->GPIO25.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO25_ALL_DEGLITCH_Pos (19)
#define GPIO25_ALL_DEGLITCH_Msk (0x1UL << GPIO25_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO25_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO25_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO25_BIT_DEGLITCH;

#define GPIO25_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO25_ALL_DEGLITCH_Pos)
#define GPIO25_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO25_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO26          MUXSEL
 *  @access     PINMUX->GPIO26.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO26_ALL_MUXSEL_Pos (0)
#define GPIO26_ALL_MUXSEL_Msk (0x7UL << GPIO26_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO26_BIT_MUXSEL_GPIO26       = 0,  /*!< GPIO26        */
    GPIO26_BIT_MUXSEL_I2C_SDA      = 1,  /*!< I2C_SDA       */
    GPIO26_BIT_MUXSEL_PWMSYNCI     = 2,  /*!< PWMSYNCI      */
    GPIO26_BIT_MUXSEL_ADCSOCAO     = 3,  /*!< ADCSOCAO      */
    GPIO26_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO26_BIT_MUXSEL;

#define GPIO26_ALL_MUXSEL_GPIO26       ((0x0UL) << GPIO26_ALL_MUXSEL_Pos)
#define GPIO26_ALL_MUXSEL_I2C_SDA      ((0x1UL) << GPIO26_ALL_MUXSEL_Pos)
#define GPIO26_ALL_MUXSEL_PWMSYNCI     ((0x2UL) << GPIO26_ALL_MUXSEL_Pos)
#define GPIO26_ALL_MUXSEL_ADCSOCAO     ((0x3UL) << GPIO26_ALL_MUXSEL_Pos)
#define GPIO26_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO26_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO26          DEMUX
 *  @access     PINMUX->GPIO26.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO26_ALL_DEMUX_Pos (3)
#define GPIO26_ALL_DEMUX_Msk (0xFFUL << GPIO26_ALL_DEMUX_Pos)

#define GPIO26_BIT_DEMUX

#define GPIO26_ALL_DEMUX_(x) ((x) << GPIO26_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO26          NPU
 *  @access     PINMUX->GPIO26.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO26_ALL_NPU_Pos (11)
#define GPIO26_ALL_NPU_Msk (0xFFUL << GPIO26_ALL_NPU_Pos)

#define GPIO26_BIT_NPU

#define GPIO26_ALL_NPU_(x) ((x) << GPIO26_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO26          DEGLITCH
 *  @access     PINMUX->GPIO26.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO26_ALL_DEGLITCH_Pos (19)
#define GPIO26_ALL_DEGLITCH_Msk (0x1UL << GPIO26_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO26_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO26_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO26_BIT_DEGLITCH;

#define GPIO26_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO26_ALL_DEGLITCH_Pos)
#define GPIO26_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO26_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO27          MUXSEL
 *  @access     PINMUX->GPIO27.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO27_ALL_MUXSEL_Pos (0)
#define GPIO27_ALL_MUXSEL_Msk (0x7UL << GPIO27_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO27_BIT_MUXSEL_GPIO27       = 0,  /*!< GPIO27        */
    GPIO27_BIT_MUXSEL_I2C_SCL      = 1,  /*!< I2C_SCL       */
    GPIO27_BIT_MUXSEL_PWMSYNCO     = 2,  /*!< PWMSYNCO      */
    GPIO27_BIT_MUXSEL_ADCSOCBO     = 3,  /*!< ADCSOCBO      */
    GPIO27_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO27_BIT_MUXSEL;

#define GPIO27_ALL_MUXSEL_GPIO27       ((0x0UL) << GPIO27_ALL_MUXSEL_Pos)
#define GPIO27_ALL_MUXSEL_I2C_SCL      ((0x1UL) << GPIO27_ALL_MUXSEL_Pos)
#define GPIO27_ALL_MUXSEL_PWMSYNCO     ((0x2UL) << GPIO27_ALL_MUXSEL_Pos)
#define GPIO27_ALL_MUXSEL_ADCSOCBO     ((0x3UL) << GPIO27_ALL_MUXSEL_Pos)
#define GPIO27_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO27_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO27          DEMUX
 *  @access     PINMUX->GPIO27.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO27_ALL_DEMUX_Pos (3)
#define GPIO27_ALL_DEMUX_Msk (0xFFUL << GPIO27_ALL_DEMUX_Pos)

#define GPIO27_BIT_DEMUX

#define GPIO27_ALL_DEMUX_(x) ((x) << GPIO27_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO27          NPU
 *  @access     PINMUX->GPIO27.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO27_ALL_NPU_Pos (11)
#define GPIO27_ALL_NPU_Msk (0xFFUL << GPIO27_ALL_NPU_Pos)

#define GPIO27_BIT_NPU

#define GPIO27_ALL_NPU_(x) ((x) << GPIO27_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO27          DEGLITCH
 *  @access     PINMUX->GPIO27.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO27_ALL_DEGLITCH_Pos (19)
#define GPIO27_ALL_DEGLITCH_Msk (0x1UL << GPIO27_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO27_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO27_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO27_BIT_DEGLITCH;

#define GPIO27_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO27_ALL_DEGLITCH_Pos)
#define GPIO27_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO27_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO28          MUXSEL
 *  @access     PINMUX->GPIO28.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO28_ALL_MUXSEL_Pos (0)
#define GPIO28_ALL_MUXSEL_Msk (0x7UL << GPIO28_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO28_BIT_MUXSEL_GPIO28     = 0,  /*!< GPIO28        */
    GPIO28_BIT_MUXSEL_PWM1A      = 1,  /*!< PWM1A         */
    GPIO28_BIT_MUXSEL_TDI        = 4,  /*!< TDI           */
    GPIO28_BIT_MUXSEL_ECAPO      = 7,  /*!< ECAP output   */
} GPIO28_BIT_MUXSEL;

#define GPIO28_ALL_MUXSEL_GPIO28     ((0x0UL) << GPIO28_ALL_MUXSEL_Pos)
#define GPIO28_ALL_MUXSEL_PWM1A      ((0x1UL) << GPIO28_ALL_MUXSEL_Pos)
#define GPIO28_ALL_MUXSEL_TDI        ((0x4UL) << GPIO28_ALL_MUXSEL_Pos)
#define GPIO28_ALL_MUXSEL_ECAPO      ((0x7UL) << GPIO28_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO28          DEMUX
 *  @access     PINMUX->GPIO28.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO28_ALL_DEMUX_Pos (3)
#define GPIO28_ALL_DEMUX_Msk (0xFFUL << GPIO28_ALL_DEMUX_Pos)

#define GPIO28_BIT_DEMUX

#define GPIO28_ALL_DEMUX_(x) ((x) << GPIO28_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO28          NPU
 *  @access     PINMUX->GPIO28.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO28_ALL_NPU_Pos (11)
#define GPIO28_ALL_NPU_Msk (0xFFUL << GPIO28_ALL_NPU_Pos)

#define GPIO28_BIT_NPU

#define GPIO28_ALL_NPU_(x) ((x) << GPIO28_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO28          DEGLITCH
 *  @access     PINMUX->GPIO28.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO28_ALL_DEGLITCH_Pos (19)
#define GPIO28_ALL_DEGLITCH_Msk (0x1UL << GPIO28_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO28_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO28_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO28_BIT_DEGLITCH;

#define GPIO28_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO28_ALL_DEGLITCH_Pos)
#define GPIO28_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO28_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO29          MUXSEL
 *  @access     PINMUX->GPIO29.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO29_ALL_MUXSEL_Pos (0)
#define GPIO29_ALL_MUXSEL_Msk (0x7UL << GPIO29_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO29_BIT_MUXSEL_GPIO29        = 0,  /*!< GPIO29      */
    GPIO29_BIT_MUXSEL_PWM1B         = 1,  /*!< PWM1B       */
    GPIO29_BIT_MUXSEL_COMP0HOUT     = 2,  /*!< COMP0HOUT   */
    GPIO29_BIT_MUXSEL_TDO           = 4,  /*!< TDO         */
    GPIO29_BIT_MUXSEL_ECAPO         = 7,  /*!< ECAPO       */
} GPIO29_BIT_MUXSEL;

#define GPIO29_ALL_MUXSEL_GPIO29        ((0x0UL) << GPIO29_ALL_MUXSEL_Pos)
#define GPIO29_ALL_MUXSEL_PWM1B         ((0x1UL) << GPIO29_ALL_MUXSEL_Pos)
#define GPIO29_ALL_MUXSEL_COMP0HOUT     ((0x2UL) << GPIO29_ALL_MUXSEL_Pos)
#define GPIO29_ALL_MUXSEL_TDO           ((0x4UL) << GPIO29_ALL_MUXSEL_Pos)
#define GPIO29_ALL_MUXSEL_ECAPO         ((0x7UL) << GPIO29_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO29          DEMUX
 *  @access     PINMUX->GPIO29.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO29_ALL_DEMUX_Pos (3)
#define GPIO29_ALL_DEMUX_Msk (0xFFUL << GPIO29_ALL_DEMUX_Pos)

#define GPIO29_BIT_DEMUX

#define GPIO29_ALL_DEMUX_(x) ((x) << GPIO29_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO29          NPU
 *  @access     PINMUX->GPIO29.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO29_ALL_NPU_Pos (11)
#define GPIO29_ALL_NPU_Msk (0xFFUL << GPIO29_ALL_NPU_Pos)

#define GPIO29_BIT_NPU

#define GPIO29_ALL_NPU_(x) ((x) << GPIO29_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO29          DEGLITCH
 *  @access     PINMUX->GPIO29.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO29_ALL_DEGLITCH_Pos (19)
#define GPIO29_ALL_DEGLITCH_Msk (0x1UL << GPIO29_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO29_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO29_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO29_BIT_DEGLITCH;

#define GPIO29_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO29_ALL_DEGLITCH_Pos)
#define GPIO29_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO29_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO30          MUXSEL
 *  @access     PINMUX->GPIO30.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO30_ALL_MUXSEL_Pos (0)
#define GPIO30_ALL_MUXSEL_Msk (0x7UL << GPIO30_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO30_BIT_MUXSEL_GPIO30      = 0,  /*!< GPIO30        */
    GPIO30_BIT_MUXSEL_PWM2A       = 1,  /*!< PWM2A         */
    GPIO30_BIT_MUXSEL_TMS_SWD     = 4,  /*!< TMS/SWD       */
    // GPIO30_BIT_MUXSEL_TMS_SWD  = 5,  /*!< TMS/SWD       */
    GPIO30_BIT_MUXSEL_ECAPO       = 7,  /*!< ECAP output   */
} GPIO30_BIT_MUXSEL;

#define GPIO30_ALL_MUXSEL_GPIO30      ((0x0UL) << GPIO30_ALL_MUXSEL_Pos)
#define GPIO30_ALL_MUXSEL_PWM2A       ((0x1UL) << GPIO30_ALL_MUXSEL_Pos)
#define GPIO30_ALL_MUXSEL_TMS_SWD     ((0x4UL) << GPIO30_ALL_MUXSEL_Pos)
// #define GPIO30_ALL_MUXSEL_TMS_SWD     ((0x5UL) << GPIO30_ALL_MUXSEL_Pos)
#define GPIO30_ALL_MUXSEL_ECAPO       ((0x7UL) << GPIO30_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO30          DEMUX
 *  @access     PINMUX->GPIO30.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO30_ALL_DEMUX_Pos (3)
#define GPIO30_ALL_DEMUX_Msk (0xFFUL << GPIO30_ALL_DEMUX_Pos)

#define GPIO30_BIT_DEMUX

#define GPIO30_ALL_DEMUX_(x) ((x) << GPIO30_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO30          NPU
 *  @access     PINMUX->GPIO30.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO30_ALL_NPU_Pos (11)
#define GPIO30_ALL_NPU_Msk (0xFFUL << GPIO30_ALL_NPU_Pos)

#define GPIO30_BIT_NPU

#define GPIO30_ALL_NPU_(x) ((x) << GPIO30_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO30          DEGLITCH
 *  @access     PINMUX->GPIO30.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO30_ALL_DEGLITCH_Pos (19)
#define GPIO30_ALL_DEGLITCH_Msk (0x1UL << GPIO30_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO30_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO30_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO30_BIT_DEGLITCH;

#define GPIO30_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO30_ALL_DEGLITCH_Pos)
#define GPIO30_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO30_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO31          MUXSEL
 *  @access     PINMUX->GPIO31.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO31_ALL_MUXSEL_Pos (0)
#define GPIO31_ALL_MUXSEL_Msk (0x7UL << GPIO31_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO31_BIT_MUXSEL_GPIO31       = 0,  /*!< GPIO31        */
    GPIO31_BIT_MUXSEL_PWM2B        = 1,  /*!< PWM2B         */
    GPIO31_BIT_MUXSEL_TCK_SWCK     = 4,  /*!< TCK/SWCK      */
    GPIO31_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO31_BIT_MUXSEL;

#define GPIO31_ALL_MUXSEL_GPIO31       ((0x0UL) << GPIO31_ALL_MUXSEL_Pos)
#define GPIO31_ALL_MUXSEL_PWM2B        ((0x1UL) << GPIO31_ALL_MUXSEL_Pos)
#define GPIO31_ALL_MUXSEL_TCK_SWCK     ((0x4UL) << GPIO31_ALL_MUXSEL_Pos)
#define GPIO31_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO31_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO31          DEMUX
 *  @access     PINMUX->GPIO31.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO31_ALL_DEMUX_Pos (3)
#define GPIO31_ALL_DEMUX_Msk (0xFFUL << GPIO31_ALL_DEMUX_Pos)

#define GPIO31_BIT_DEMUX

#define GPIO31_ALL_DEMUX_(x) ((x) << GPIO31_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO31          NPU
 *  @access     PINMUX->GPIO31.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO31_ALL_NPU_Pos (11)
#define GPIO31_ALL_NPU_Msk (0xFFUL << GPIO31_ALL_NPU_Pos)

#define GPIO31_BIT_NPU

#define GPIO31_ALL_NPU_(x) ((x) << GPIO31_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO31          DEGLITCH
 *  @access     PINMUX->GPIO31.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO31_ALL_DEGLITCH_Pos (19)
#define GPIO31_ALL_DEGLITCH_Msk (0x1UL << GPIO31_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO31_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO31_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO31_BIT_DEGLITCH;

#define GPIO31_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO31_ALL_DEGLITCH_Pos)
#define GPIO31_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO31_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO32          MUXSEL
 *  @access     PINMUX->GPIO32.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO32_ALL_MUXSEL_Pos (0)
#define GPIO32_ALL_MUXSEL_Msk (0x7UL << GPIO32_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO32_BIT_MUXSEL_GPIO32       = 0,  /*!< GPIO32        */
    GPIO32_BIT_MUXSEL_PWM3A        = 1,  /*!< PWM3A         */
    GPIO32_BIT_MUXSEL_PWMSYNCI     = 2,  /*!< PWMSYNCI      */
    GPIO32_BIT_MUXSEL_PWMSYNCO     = 3,  /*!< PWMSYNCO      */
    GPIO32_BIT_MUXSEL_SPICLK       = 4,  /*!< SPICLK        */
    GPIO32_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO32_BIT_MUXSEL;

#define GPIO32_ALL_MUXSEL_GPIO32       ((0x0UL) << GPIO32_ALL_MUXSEL_Pos)
#define GPIO32_ALL_MUXSEL_PWM3A        ((0x1UL) << GPIO32_ALL_MUXSEL_Pos)
#define GPIO32_ALL_MUXSEL_PWMSYNCI     ((0x2UL) << GPIO32_ALL_MUXSEL_Pos)
#define GPIO32_ALL_MUXSEL_PWMSYNCO     ((0x3UL) << GPIO32_ALL_MUXSEL_Pos)
#define GPIO32_ALL_MUXSEL_SPICLK       ((0x4UL) << GPIO32_ALL_MUXSEL_Pos)
#define GPIO32_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO32_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO32          DEMUX
 *  @access     PINMUX->GPIO32.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO32_ALL_DEMUX_Pos (3)
#define GPIO32_ALL_DEMUX_Msk (0xFFUL << GPIO32_ALL_DEMUX_Pos)

#define GPIO32_BIT_DEMUX

#define GPIO32_ALL_DEMUX_(x) ((x) << GPIO32_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO32          NPU
 *  @access     PINMUX->GPIO32.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO32_ALL_NPU_Pos (11)
#define GPIO32_ALL_NPU_Msk (0xFFUL << GPIO32_ALL_NPU_Pos)

#define GPIO32_BIT_NPU

#define GPIO32_ALL_NPU_(x) ((x) << GPIO32_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO32          DEGLITCH
 *  @access     PINMUX->GPIO32.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO32_ALL_DEGLITCH_Pos (19)
#define GPIO32_ALL_DEGLITCH_Msk (0x1UL << GPIO32_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO32_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO32_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO32_BIT_DEGLITCH;

#define GPIO32_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO32_ALL_DEGLITCH_Pos)
#define GPIO32_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO32_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO33          MUXSEL
 *  @access     PINMUX->GPIO33.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO33_ALL_MUXSEL_Pos (0)
#define GPIO33_ALL_MUXSEL_Msk (0x7UL << GPIO33_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO33_BIT_MUXSEL_GPIO33       = 0,  /*!< GPIO33        */
    GPIO33_BIT_MUXSEL_PWM3B        = 1,  /*!< PWM3B         */
    GPIO33_BIT_MUXSEL_UART_RXD     = 2,  /*!< UART_RXD      */
    GPIO33_BIT_MUXSEL_SPI_FRM      = 4,  /*!< SPI_FRM       */
    GPIO33_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO33_BIT_MUXSEL;

#define GPIO33_ALL_MUXSEL_GPIO33       ((0x0UL) << GPIO33_ALL_MUXSEL_Pos)
#define GPIO33_ALL_MUXSEL_PWM3B        ((0x1UL) << GPIO33_ALL_MUXSEL_Pos)
#define GPIO33_ALL_MUXSEL_UART_RXD     ((0x2UL) << GPIO33_ALL_MUXSEL_Pos)
#define GPIO33_ALL_MUXSEL_SPI_FRM      ((0x4UL) << GPIO33_ALL_MUXSEL_Pos)
#define GPIO33_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO33_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO33          DEMUX
 *  @access     PINMUX->GPIO33.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO33_ALL_DEMUX_Pos (3)
#define GPIO33_ALL_DEMUX_Msk (0xFFUL << GPIO33_ALL_DEMUX_Pos)

#define GPIO33_BIT_DEMUX

#define GPIO33_ALL_DEMUX_(x) ((x) << GPIO33_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO33          NPU
 *  @access     PINMUX->GPIO33.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO33_ALL_NPU_Pos (11)
#define GPIO33_ALL_NPU_Msk (0xFFUL << GPIO33_ALL_NPU_Pos)

#define GPIO33_BIT_NPU

#define GPIO33_ALL_NPU_(x) ((x) << GPIO33_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO33          DEGLITCH
 *  @access     PINMUX->GPIO33.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO33_ALL_DEGLITCH_Pos (19)
#define GPIO33_ALL_DEGLITCH_Msk (0x1UL << GPIO33_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO33_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO33_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO33_BIT_DEGLITCH;

#define GPIO33_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO33_ALL_DEGLITCH_Pos)
#define GPIO33_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO33_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO34          MUXSEL
 *  @access     PINMUX->GPIO34.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO34_ALL_MUXSEL_Pos (0)
#define GPIO34_ALL_MUXSEL_Msk (0x7UL << GPIO34_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO34_BIT_MUXSEL_GPIO34       = 0,  /*!< GPIO34        */
    GPIO34_BIT_MUXSEL_UART_TXD     = 1,  /*!< UART_TXD      */
    GPIO34_BIT_MUXSEL_UART_RXD     = 3,  /*!< UART_RXD      */
    GPIO34_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO34_BIT_MUXSEL;

#define GPIO34_ALL_MUXSEL_GPIO34       ((0x0UL) << GPIO34_ALL_MUXSEL_Pos)
#define GPIO34_ALL_MUXSEL_UART_TXD     ((0x1UL) << GPIO34_ALL_MUXSEL_Pos)
#define GPIO34_ALL_MUXSEL_UART_RXD     ((0x3UL) << GPIO34_ALL_MUXSEL_Pos)
#define GPIO34_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO34_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO34          DEMUX
 *  @access     PINMUX->GPIO34.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO34_ALL_DEMUX_Pos (3)
#define GPIO34_ALL_DEMUX_Msk (0xFFUL << GPIO34_ALL_DEMUX_Pos)

#define GPIO34_BIT_DEMUX

#define GPIO34_ALL_DEMUX_(x) ((x) << GPIO34_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO34          NPU
 *  @access     PINMUX->GPIO34.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO34_ALL_NPU_Pos (11)
#define GPIO34_ALL_NPU_Msk (0xFFUL << GPIO34_ALL_NPU_Pos)

#define GPIO34_BIT_NPU

#define GPIO34_ALL_NPU_(x) ((x) << GPIO34_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO34          DEGLITCH
 *  @access     PINMUX->GPIO34.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO34_ALL_DEGLITCH_Pos (19)
#define GPIO34_ALL_DEGLITCH_Msk (0x1UL << GPIO34_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO34_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO34_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO34_BIT_DEGLITCH;

#define GPIO34_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO34_ALL_DEGLITCH_Pos)
#define GPIO34_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO34_ALL_DEGLITCH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO35          MUXSEL
 *  @access     PINMUX->GPIO35.bit.MUXSEL
 *  @brief      Channel select
 */
#define GPIO35_ALL_MUXSEL_Pos (0)
#define GPIO35_ALL_MUXSEL_Msk (0x7UL << GPIO35_ALL_MUXSEL_Pos)

typedef enum
{
    GPIO35_BIT_MUXSEL_GPIO35       = 0,  /*!< GPIO35        */
    GPIO35_BIT_MUXSEL_UART_RXD     = 1,  /*!< UART_RXD      */
    GPIO35_BIT_MUXSEL_I2C_SDA      = 2,  /*!< I2C_SDA       */
    GPIO35_BIT_MUXSEL_UART_TXD     = 3,  /*!< UART_TXD      */
    GPIO35_BIT_MUXSEL_ECAPO        = 7,  /*!< ECAP output   */
} GPIO35_BIT_MUXSEL;

#define GPIO35_ALL_MUXSEL_GPIO35       ((0x0UL) << GPIO35_ALL_MUXSEL_Pos)
#define GPIO35_ALL_MUXSEL_UART_RXD     ((0x1UL) << GPIO35_ALL_MUXSEL_Pos)
#define GPIO35_ALL_MUXSEL_I2C_SDA      ((0x2UL) << GPIO35_ALL_MUXSEL_Pos)
#define GPIO35_ALL_MUXSEL_UART_TXD     ((0x3UL) << GPIO35_ALL_MUXSEL_Pos)
#define GPIO35_ALL_MUXSEL_ECAPO        ((0x7UL) << GPIO35_ALL_MUXSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO35          DEMUX
 *  @access     PINMUX->GPIO35.bit.DEMUX
 *  @brief      Default value for each demuxed input channel
 */
#define GPIO35_ALL_DEMUX_Pos (3)
#define GPIO35_ALL_DEMUX_Msk (0xFFUL << GPIO35_ALL_DEMUX_Pos)

#define GPIO35_BIT_DEMUX

#define GPIO35_ALL_DEMUX_(x) ((x) << GPIO35_ALL_DEMUX_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO35          NPU
 *  @access     PINMUX->GPIO35.bit.NPU
 *  @brief      Disable internal pull-up for each channel
 */
#define GPIO35_ALL_NPU_Pos (11)
#define GPIO35_ALL_NPU_Msk (0xFFUL << GPIO35_ALL_NPU_Pos)

#define GPIO35_BIT_NPU

#define GPIO35_ALL_NPU_(x) ((x) << GPIO35_ALL_NPU_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   PINMUX          GPIO35          DEGLITCH
 *  @access     PINMUX->GPIO35.bit.DEGLITCH
 *  @brief      Input de-glitch filtering
 */
#define GPIO35_ALL_DEGLITCH_Pos (19)
#define GPIO35_ALL_DEGLITCH_Msk (0x1UL << GPIO35_ALL_DEGLITCH_Pos)

typedef enum
{
    GPIO35_BIT_DEGLITCH_DISABLE     = 0,  /*!< Disable de-glitch   */
    GPIO35_BIT_DEGLITCH_ENABLE      = 1,  /*!< Enable de-glitch    */
} GPIO35_BIT_DEGLITCH;

#define GPIO35_ALL_DEGLITCH_DISABLE     ((0x0UL) << GPIO35_ALL_DEGLITCH_Pos)
#define GPIO35_ALL_DEGLITCH_ENABLE      ((0x1UL) << GPIO35_ALL_DEGLITCH_Pos)





/********************************************************************************
*
* Module Name     ECAP
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            TSCNT           VAL
 *  @access     ECAP->TSCNT.bit.VAL
 *  @brief      Active 32-bit counter register that is used as the capture time-base
 */
#define TSCNT_ALL_VAL_Pos (0)
#define TSCNT_ALL_VAL_Msk (0xFFFFFFFFUL << TSCNT_ALL_VAL_Pos)

#define TSCNT_BIT_VAL

#define TSCNT_ALL_VAL_(x) ((x) << TSCNT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CNTPHS          VAL
 *  @access     ECAP->CNTPHS.bit.VAL
 *  @brief      Counter phase value register that can be programmed for phase lag/lead
 */
#define CNTPHS_ALL_VAL_Pos (0)
#define CNTPHS_ALL_VAL_Msk (0xFFFFFFFFUL << CNTPHS_ALL_VAL_Pos)

#define CNTPHS_BIT_VAL

#define CNTPHS_ALL_VAL_(x) ((x) << CNTPHS_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAP0            VAL
 *  @access     ECAP->CAP0.bit.VAL
 *  @brief      This register can be loaded by:
 *              - Time-Stamp(i.e., counter value) during a capture event
 *              - Software - may be useful for test purposes or initialization
 *              - APRD shadow register(i.e., CAP2) when used in APWM mode
 *              
 *              NOTE: In APWM mode, writing to CAP0/CAP1 active registers also writes the same value to the corresponding shadow registers CAP2/CAP3. This emulates immediate mode. Writing to the shadow registers CAP2/CAP3 invokes the shadow mode.
 */
#define CAP0_ALL_VAL_Pos (0)
#define CAP0_ALL_VAL_Msk (0xFFFFFFFFUL << CAP0_ALL_VAL_Pos)

#define CAP0_BIT_VAL

#define CAP0_ALL_VAL_(x) ((x) << CAP0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAP1            VAL
 *  @access     ECAP->CAP1.bit.VAL
 *  @brief      This register can be loaded by:
 *              - Time-Stamp(i.e., counter value) during a capture event
 *              - Software - may be useful for test purposes or initialization
 *              - APRD shadow register(i.e., CAP3) when used in APWM mode
 *              
 *              NOTE: In APWM mode, writing to CAP0/CAP1 active registers also writes the same value to the corresponding shadow registers CAP2/CAP3. This emulates immediate mode. Writing to the shadow registers CAP2/CAP3 invokes the shadow mode.
 */
#define CAP1_ALL_VAL_Pos (0)
#define CAP1_ALL_VAL_Msk (0xFFFFFFFFUL << CAP1_ALL_VAL_Pos)

#define CAP1_BIT_VAL

#define CAP1_ALL_VAL_(x) ((x) << CAP1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAP2            VAL
 *  @access     ECAP->CAP2.bit.VAL
 *  @brief      In Capture mode, this is a time-stamp capture register. In APWM mode, this is the period shadow (APRD) register. You update the PWM period value through this register. In this mode, CAP2 (APRD) shadows CAP0.
 */
#define CAP2_ALL_VAL_Pos (0)
#define CAP2_ALL_VAL_Msk (0xFFFFFFFFUL << CAP2_ALL_VAL_Pos)

#define CAP2_BIT_VAL

#define CAP2_ALL_VAL_(x) ((x) << CAP2_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAP3            VAL
 *  @access     ECAP->CAP3.bit.VAL
 *  @brief      In Capture mode, this is a time-stamp capture register. In APWM mode, this is the compare shadow (ACMP) register. You update the PWM compare value via this register. In this mode, CAP3 (ACMP) shadows CAP1.
 */
#define CAP3_ALL_VAL_Pos (0)
#define CAP3_ALL_VAL_Msk (0xFFFFFFFFUL << CAP3_ALL_VAL_Pos)

#define CAP3_BIT_VAL

#define CAP3_ALL_VAL_(x) ((x) << CAP3_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CAP0POL
 *  @access     ECAP->CAPCTL.bit.CAP0POL
 *  @brief      Capture Event 0 Polarity select
 */
#define CAPCTL_ALL_CAP0POL_Pos (0)
#define CAPCTL_ALL_CAP0POL_Msk (0x1UL << CAPCTL_ALL_CAP0POL_Pos)

typedef enum
{
    CAPCTL_BIT_CAP0POL_TRIG_ON_RISING_EDGE      = 0,  /*!< Capture Event 0 triggered on a rising edge (RE)    */
    CAPCTL_BIT_CAP0POL_TRIG_ON_FALLING_EDGE     = 1,  /*!< Capture Event 0 triggered on a falling edge (FE)   */
} CAPCTL_BIT_CAP0POL;

#define CAPCTL_ALL_CAP0POL_TRIG_ON_RISING_EDGE      ((0x0UL) << CAPCTL_ALL_CAP0POL_Pos)
#define CAPCTL_ALL_CAP0POL_TRIG_ON_FALLING_EDGE     ((0x1UL) << CAPCTL_ALL_CAP0POL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CNTRST0
 *  @access     ECAP->CAPCTL.bit.CNTRST0
 *  @brief      Counter Reset on Capture Event 0
 */
#define CAPCTL_ALL_CNTRST0_Pos (1)
#define CAPCTL_ALL_CNTRST0_Msk (0x1UL << CAPCTL_ALL_CNTRST0_Pos)

typedef enum
{
    CAPCTL_BIT_CNTRST0_NO_RESET_ON_CAPTURE     = 0,  /*!< Do not reset counter on Capture Event 0 (absolute time stamp)                                  */
    CAPCTL_BIT_CNTRST0_RESET_ON_CAPTURE        = 1,  /*!< Reset counter after Event 0 time-stamp has been captured (used in difference mode operation)   */
} CAPCTL_BIT_CNTRST0;

#define CAPCTL_ALL_CNTRST0_NO_RESET_ON_CAPTURE     ((0x0UL) << CAPCTL_ALL_CNTRST0_Pos)
#define CAPCTL_ALL_CNTRST0_RESET_ON_CAPTURE        ((0x1UL) << CAPCTL_ALL_CNTRST0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CAP1POL
 *  @access     ECAP->CAPCTL.bit.CAP1POL
 *  @brief      Capture Event 1 Polarity select
 */
#define CAPCTL_ALL_CAP1POL_Pos (2)
#define CAPCTL_ALL_CAP1POL_Msk (0x1UL << CAPCTL_ALL_CAP1POL_Pos)

typedef enum
{
    CAPCTL_BIT_CAP1POL_TRIG_ON_RISING_EDGE      = 0,  /*!< Capture Event 1 triggered on a rising edge (RE)    */
    CAPCTL_BIT_CAP1POL_TRIG_ON_FALLING_EDGE     = 1,  /*!< Capture Event 1 triggered on a falling edge (FE)   */
} CAPCTL_BIT_CAP1POL;

#define CAPCTL_ALL_CAP1POL_TRIG_ON_RISING_EDGE      ((0x0UL) << CAPCTL_ALL_CAP1POL_Pos)
#define CAPCTL_ALL_CAP1POL_TRIG_ON_FALLING_EDGE     ((0x1UL) << CAPCTL_ALL_CAP1POL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CNTRST1
 *  @access     ECAP->CAPCTL.bit.CNTRST1
 *  @brief      Counter Reset on Capture Event 1
 */
#define CAPCTL_ALL_CNTRST1_Pos (3)
#define CAPCTL_ALL_CNTRST1_Msk (0x1UL << CAPCTL_ALL_CNTRST1_Pos)

typedef enum
{
    CAPCTL_BIT_CNTRST1_NO_RESET_ON_CAPTURE     = 0,  /*!< Do not reset counter on Capture Event 1 (absolute time stamp)                                  */
    CAPCTL_BIT_CNTRST1_RESET_ON_CAPTURE        = 1,  /*!< Reset counter after Event 1 time-stamp has been captured (used in difference mode operation)   */
} CAPCTL_BIT_CNTRST1;

#define CAPCTL_ALL_CNTRST1_NO_RESET_ON_CAPTURE     ((0x0UL) << CAPCTL_ALL_CNTRST1_Pos)
#define CAPCTL_ALL_CNTRST1_RESET_ON_CAPTURE        ((0x1UL) << CAPCTL_ALL_CNTRST1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CAP2POL
 *  @access     ECAP->CAPCTL.bit.CAP2POL
 *  @brief      Capture Event 2 Polarity select
 */
#define CAPCTL_ALL_CAP2POL_Pos (4)
#define CAPCTL_ALL_CAP2POL_Msk (0x1UL << CAPCTL_ALL_CAP2POL_Pos)

typedef enum
{
    CAPCTL_BIT_CAP2POL_TRIG_ON_RISING_EDGE      = 0,  /*!< Capture Event 2 triggered on a rising edge (RE)    */
    CAPCTL_BIT_CAP2POL_TRIG_ON_FALLING_EDGE     = 1,  /*!< Capture Event 2 triggered on a falling edge (FE)   */
} CAPCTL_BIT_CAP2POL;

#define CAPCTL_ALL_CAP2POL_TRIG_ON_RISING_EDGE      ((0x0UL) << CAPCTL_ALL_CAP2POL_Pos)
#define CAPCTL_ALL_CAP2POL_TRIG_ON_FALLING_EDGE     ((0x1UL) << CAPCTL_ALL_CAP2POL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CNTRST2
 *  @access     ECAP->CAPCTL.bit.CNTRST2
 *  @brief      Counter Reset on Capture Event 2
 */
#define CAPCTL_ALL_CNTRST2_Pos (5)
#define CAPCTL_ALL_CNTRST2_Msk (0x1UL << CAPCTL_ALL_CNTRST2_Pos)

typedef enum
{
    CAPCTL_BIT_CNTRST2_NO_RESET_ON_CAPTURE     = 0,  /*!< Do not reset counter on Capture Event 2 (absolute time stamp)                                  */
    CAPCTL_BIT_CNTRST2_RESET_ON_CAPTURE        = 1,  /*!< Reset counter after Event 2 time-stamp has been captured (used in difference mode operation)   */
} CAPCTL_BIT_CNTRST2;

#define CAPCTL_ALL_CNTRST2_NO_RESET_ON_CAPTURE     ((0x0UL) << CAPCTL_ALL_CNTRST2_Pos)
#define CAPCTL_ALL_CNTRST2_RESET_ON_CAPTURE        ((0x1UL) << CAPCTL_ALL_CNTRST2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CAP3POL
 *  @access     ECAP->CAPCTL.bit.CAP3POL
 *  @brief      Capture Event 3 Polarity select
 */
#define CAPCTL_ALL_CAP3POL_Pos (6)
#define CAPCTL_ALL_CAP3POL_Msk (0x1UL << CAPCTL_ALL_CAP3POL_Pos)

typedef enum
{
    CAPCTL_BIT_CAP3POL_TRIG_ON_RISING_EDGE      = 0,  /*!< Capture Event 3 triggered on a rising edge (RE)    */
    CAPCTL_BIT_CAP3POL_TRIG_ON_FALLING_EDGE     = 1,  /*!< Capture Event 3 triggered on a falling edge (FE)   */
} CAPCTL_BIT_CAP3POL;

#define CAPCTL_ALL_CAP3POL_TRIG_ON_RISING_EDGE      ((0x0UL) << CAPCTL_ALL_CAP3POL_Pos)
#define CAPCTL_ALL_CAP3POL_TRIG_ON_FALLING_EDGE     ((0x1UL) << CAPCTL_ALL_CAP3POL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CNTRST3
 *  @access     ECAP->CAPCTL.bit.CNTRST3
 *  @brief      Counter Reset on Capture Event 3
 */
#define CAPCTL_ALL_CNTRST3_Pos (7)
#define CAPCTL_ALL_CNTRST3_Msk (0x1UL << CAPCTL_ALL_CNTRST3_Pos)

typedef enum
{
    CAPCTL_BIT_CNTRST3_NO_RESET_ON_CAPTURE     = 0,  /*!< Do not reset counter on Capture Event 3 (absolute time stamp operation)                                */
    CAPCTL_BIT_CNTRST3_RESET_ON_CAPTURE        = 1,  /*!< Reset counter after Capture Event 3 time-stamp has been captured (used in difference mode operation)   */
} CAPCTL_BIT_CNTRST3;

#define CAPCTL_ALL_CNTRST3_NO_RESET_ON_CAPTURE     ((0x0UL) << CAPCTL_ALL_CNTRST3_Pos)
#define CAPCTL_ALL_CNTRST3_RESET_ON_CAPTURE        ((0x1UL) << CAPCTL_ALL_CNTRST3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CAPLDEN
 *  @access     ECAP->CAPCTL.bit.CAPLDEN
 *  @brief      Enable Loading of CAP0-3 registers on a capture event
 */
#define CAPCTL_ALL_CAPLDEN_Pos (8)
#define CAPCTL_ALL_CAPLDEN_Msk (0x1UL << CAPCTL_ALL_CAPLDEN_Pos)

typedef enum
{
    CAPCTL_BIT_CAPLDEN_CAPTURE_LOAD_DISABLE     = 0,  /*!< Disable CAP0-3 register loads at capture event time   */
    CAPCTL_BIT_CAPLDEN_CAPTURE_LOAD_ENABLE      = 1,  /*!< Enable CAP0-3 register loads at capture event time    */
} CAPCTL_BIT_CAPLDEN;

#define CAPCTL_ALL_CAPLDEN_CAPTURE_LOAD_DISABLE     ((0x0UL) << CAPCTL_ALL_CAPLDEN_Pos)
#define CAPCTL_ALL_CAPLDEN_CAPTURE_LOAD_ENABLE      ((0x1UL) << CAPCTL_ALL_CAPLDEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          EVTDIV
 *  @access     ECAP->CAPCTL.bit.EVTDIV
 *  @brief      Event Filter prescale select
 */
#define CAPCTL_ALL_EVTDIV_Pos (9)
#define CAPCTL_ALL_EVTDIV_Msk (0x1FUL << CAPCTL_ALL_EVTDIV_Pos)

#define CAPCTL_BIT_EVTDIV

#define CAPCTL_ALL_EVTDIV_(x) ((x) << CAPCTL_ALL_EVTDIV_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          DBGRUN
 *  @access     ECAP->CAPCTL.bit.DBGRUN
 *  @brief      ECAP counter behaviour when CPU is halted
 *              
 *              Note: Debug operation and CPU fault exceptions both can cause CPU halted.
 */
#define CAPCTL_ALL_DBGRUN_Pos (14)
#define CAPCTL_ALL_DBGRUN_Msk (0x3UL << CAPCTL_ALL_DBGRUN_Pos)

typedef enum
{
    CAPCTL_BIT_DBGRUN_STOP_IMMEDIATELY     = 0,  /*!< TSCNT counter stops immediately when CPU is halted   */
    CAPCTL_BIT_DBGRUN_STOP_AT_ZERO         = 1,  /*!< TSCNT counter runs until = 0 when CPU is halted      */
    CAPCTL_BIT_DBGRUN_KEEP_RUN             = 2,  /*!< TSCNT counter is unaffected when CPU is halted       */
} CAPCTL_BIT_DBGRUN;

#define CAPCTL_ALL_DBGRUN_STOP_IMMEDIATELY     ((0x0UL) << CAPCTL_ALL_DBGRUN_Pos)
#define CAPCTL_ALL_DBGRUN_STOP_AT_ZERO         ((0x1UL) << CAPCTL_ALL_DBGRUN_Pos)
#define CAPCTL_ALL_DBGRUN_KEEP_RUN             ((0x2UL) << CAPCTL_ALL_DBGRUN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          MODE
 *  @access     ECAP->CAPCTL.bit.MODE
 *  @brief      Continuous or one-shot mode control (applicable only in capture mode)
 */
#define CAPCTL_ALL_MODE_Pos (16)
#define CAPCTL_ALL_MODE_Msk (0x1UL << CAPCTL_ALL_MODE_Pos)

typedef enum
{
    CAPCTL_BIT_MODE_CONTINOUS_MODE     = 0,  /*!< Operate in continuous mode   */
    CAPCTL_BIT_MODE_ONESHOT_MODE       = 1,  /*!< Operate in one-Shot mode     */
} CAPCTL_BIT_MODE;

#define CAPCTL_ALL_MODE_CONTINOUS_MODE     ((0x0UL) << CAPCTL_ALL_MODE_Pos)
#define CAPCTL_ALL_MODE_ONESHOT_MODE       ((0x1UL) << CAPCTL_ALL_MODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          STOPWRAP
 *  @access     ECAP->CAPCTL.bit.STOPWRAP
 *  @brief      Stop value for one-shot mode
 *              This is the number (between 0-3) of captures allowed to occur before the CAP (0-3) registers are frozen, i.e., capture sequence is stopped.
 *              Wrap value for continuous mode. This is the number (between 0-3) of the capture register in which the circular buffer wraps around and starts again.
 *              Notes: STOP_WRAP is compared to Mod4 counter and, when equal, 2 actions occur:
 *              - Mod4 counter is stopped (frozen)
 *              - Capture register loads are inhibited
 *              In one-shot mode, further interrupt events are blocked until re-armed.
 */
#define CAPCTL_ALL_STOPWRAP_Pos (17)
#define CAPCTL_ALL_STOPWRAP_Msk (0x3UL << CAPCTL_ALL_STOPWRAP_Pos)

typedef enum
{
    CAPCTL_BIT_STOPWRAP_ON_CAPTURE_EVENT0     = 0,  /*!< Stop after Capture Event 0 in one-shot mode Wrap after Capture Event 0 in continuous mode   */
    CAPCTL_BIT_STOPWRAP_ON_CAPTURE_EVENT1     = 1,  /*!< Stop after Capture Event 1 in one-shot mode Wrap after Capture Event 1 in continuous mode   */
    CAPCTL_BIT_STOPWRAP_ON_CAPTURE_EVENT2     = 2,  /*!< Stop after Capture Event 2 in one-shot mode Wrap after Capture Event 2 in continuous mode   */
    CAPCTL_BIT_STOPWRAP_ON_CAPTURE_EVENT3     = 3,  /*!< Stop after Capture Event 3 in one-shot mode Wrap after Capture Event 3 in continuous mode   */
} CAPCTL_BIT_STOPWRAP;

#define CAPCTL_ALL_STOPWRAP_ON_CAPTURE_EVENT0     ((0x0UL) << CAPCTL_ALL_STOPWRAP_Pos)
#define CAPCTL_ALL_STOPWRAP_ON_CAPTURE_EVENT1     ((0x1UL) << CAPCTL_ALL_STOPWRAP_Pos)
#define CAPCTL_ALL_STOPWRAP_ON_CAPTURE_EVENT2     ((0x2UL) << CAPCTL_ALL_STOPWRAP_Pos)
#define CAPCTL_ALL_STOPWRAP_ON_CAPTURE_EVENT3     ((0x3UL) << CAPCTL_ALL_STOPWRAP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          REARM
 *  @access     ECAP->CAPCTL.bit.REARM
 *  @brief      One-Shot Re-Arming Control, i.e. wait for stop trigger. Note: The re-arm function is valid in one shot or continuous mode.
 */
#define CAPCTL_ALL_REARM_Pos (19)
#define CAPCTL_ALL_REARM_Msk (0x1UL << CAPCTL_ALL_REARM_Pos)

typedef enum
{
    CAPCTL_BIT_REARM_NO_EFFECT     = 0,  /*!< Has no effect (reading always returns a 0)   */
    CAPCTL_BIT_REARM_ENABLE        = 1,  /*!< Arms the one-shot sequence as follows:      
                                              1) Resets the Mod4 counter to zero          
                                              2) Unfreezes the Mod4 counter               
                                              3) Enables capture register loads            */
} CAPCTL_BIT_REARM;

#define CAPCTL_ALL_REARM_NO_EFFECT     ((0x0UL) << CAPCTL_ALL_REARM_Pos)
#define CAPCTL_ALL_REARM_ENABLE        ((0x1UL) << CAPCTL_ALL_REARM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          TSCNTRUN
 *  @access     ECAP->CAPCTL.bit.TSCNTRUN
 *  @brief      Time Stamp (TSCNT) Counter Stop (freeze) Control
 */
#define CAPCTL_ALL_TSCNTRUN_Pos (20)
#define CAPCTL_ALL_TSCNTRUN_Msk (0x1UL << CAPCTL_ALL_TSCNTRUN_Pos)

typedef enum
{
    CAPCTL_BIT_TSCNTRUN_STOP_COUNTER      = 0,  /*!< TSCNT stopped        */
    CAPCTL_BIT_TSCNTRUN_START_COUNTER     = 1,  /*!< TSCNT free-running   */
} CAPCTL_BIT_TSCNTRUN;

#define CAPCTL_ALL_TSCNTRUN_STOP_COUNTER      ((0x0UL) << CAPCTL_ALL_TSCNTRUN_Pos)
#define CAPCTL_ALL_TSCNTRUN_START_COUNTER     ((0x1UL) << CAPCTL_ALL_TSCNTRUN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          SYNCIEN
 *  @access     ECAP->CAPCTL.bit.SYNCIEN
 *  @brief      Counter (TSCNT) Sync-In select mode
 */
#define CAPCTL_ALL_SYNCIEN_Pos (21)
#define CAPCTL_ALL_SYNCIEN_Msk (0x1UL << CAPCTL_ALL_SYNCIEN_Pos)

typedef enum
{
    CAPCTL_BIT_SYNCIEN_DISABLE     = 0,  /*!< Disable sync-in option                                                                                     */
    CAPCTL_BIT_SYNCIEN_ENABLE      = 1,  /*!< Enable counter (TSCNT) to be loaded from CNTPHS register upon either a SYNCI signal or a S/W force event   */
} CAPCTL_BIT_SYNCIEN;

#define CAPCTL_ALL_SYNCIEN_DISABLE     ((0x0UL) << CAPCTL_ALL_SYNCIEN_Pos)
#define CAPCTL_ALL_SYNCIEN_ENABLE      ((0x1UL) << CAPCTL_ALL_SYNCIEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          SYNCOSEL
 *  @access     ECAP->CAPCTL.bit.SYNCOSEL
 *  @brief      Sync-Out Select
 */
#define CAPCTL_ALL_SYNCOSEL_Pos (22)
#define CAPCTL_ALL_SYNCOSEL_Msk (0x3UL << CAPCTL_ALL_SYNCOSEL_Pos)

typedef enum
{
    CAPCTL_BIT_SYNCOSEL_SYNC_IN              = 0,  /*!< Select sync-in event to be the sync-out signal (pass through)   */
    CAPCTL_BIT_SYNCOSEL_CNT_EQU_PRD          = 1,  /*!< Select CNT = PRD event to be the sync-out signal                */
    CAPCTL_BIT_SYNCOSEL_DISABLE_SYNC_OUT     = 3,  /*!< Disable sync out signal                                         */
} CAPCTL_BIT_SYNCOSEL;

#define CAPCTL_ALL_SYNCOSEL_SYNC_IN              ((0x0UL) << CAPCTL_ALL_SYNCOSEL_Pos)
#define CAPCTL_ALL_SYNCOSEL_CNT_EQU_PRD          ((0x1UL) << CAPCTL_ALL_SYNCOSEL_Pos)
#define CAPCTL_ALL_SYNCOSEL_DISABLE_SYNC_OUT     ((0x3UL) << CAPCTL_ALL_SYNCOSEL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          FRCSYNC
 *  @access     ECAP->CAPCTL.bit.FRCSYNC
 *  @brief      Software-forced Counter (TSCNT) Synchronizing. This provides a convenient software method to synchronize some or all ECAP time bases. In APWM mode, the synchronizing can also be done via the CNT = PRD event.
 *              
 *              Note: Selection CNT = PRD is meaningful only in APWM mode; however, you can choose it in CAP mode if you find doing so useful.
 */
#define CAPCTL_ALL_FRCSYNC_Pos (24)
#define CAPCTL_ALL_FRCSYNC_Msk (0x1UL << CAPCTL_ALL_FRCSYNC_Pos)

typedef enum
{
    CAPCTL_BIT_FRCSYNC_NO_EFFECT     = 0,  /*!< Writing a zero has no effect. Reading always returns a zero.                                                                                                                          */
    CAPCTL_BIT_FRCSYNC_ENABLE        = 1,  /*!< Writing a one forces a TSCNT shadow load of current ECAP module and any ECAP modules down-stream providing the SYNCOSEL bits are 00. After writing a 1, this bit returns to a zero.   */
} CAPCTL_BIT_FRCSYNC;

#define CAPCTL_ALL_FRCSYNC_NO_EFFECT     ((0x0UL) << CAPCTL_ALL_FRCSYNC_Pos)
#define CAPCTL_ALL_FRCSYNC_ENABLE        ((0x1UL) << CAPCTL_ALL_FRCSYNC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          CAPAPWM
 *  @access     ECAP->CAPCTL.bit.CAPAPWM
 *  @brief      Capture/APWM operating mode select
 */
#define CAPCTL_ALL_CAPAPWM_Pos (25)
#define CAPCTL_ALL_CAPAPWM_Msk (0x1UL << CAPCTL_ALL_CAPAPWM_Pos)

typedef enum
{
    CAPCTL_BIT_CAPAPWM_CAPTURE_MODE     = 0,  /*!< ECAP module operates in capture mode. This mode forces the following configuration:  
                                                   - Inhibits TSCNT resets via CNT = PRD event                                          
                                                   - Inhibits shadow loads on CAP0 and CAP1 registers                                   
                                                   - Permits user to enable CAP0-3 register load                                        
                                                   - CAPx/APWMx pin operates as a capture input                                          */
    CAPCTL_BIT_CAPAPWM_APWM_MODE        = 1,  /*!< ECAP module operates in APWM mode. This mode forces the following configuration:     
                                                   - Resets TSCNT on CNT = PRD event (period boundary                                   
                                                   - Permits shadow loading on CAP0 and CAP1 registers                                  
                                                   - Disables loading of time-stamps into CAP0-3 registers                              
                                                   - CAPx/APWMx pin operates as a APWM output                                            */
} CAPCTL_BIT_CAPAPWM;

#define CAPCTL_ALL_CAPAPWM_CAPTURE_MODE     ((0x0UL) << CAPCTL_ALL_CAPAPWM_Pos)
#define CAPCTL_ALL_CAPAPWM_APWM_MODE        ((0x1UL) << CAPCTL_ALL_CAPAPWM_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPCTL          APWMPOL
 *  @access     ECAP->CAPCTL.bit.APWMPOL
 *  @brief      APWM output polarity select. This is applicable only in APWM operating mode.
 */
#define CAPCTL_ALL_APWMPOL_Pos (26)
#define CAPCTL_ALL_APWMPOL_Msk (0x1UL << CAPCTL_ALL_APWMPOL_Pos)

typedef enum
{
    CAPCTL_BIT_APWMPOL_ACTIVE_HIGH     = 0,  /*!< Output is active high (i.e., Compare value defines high time)   */
    CAPCTL_BIT_APWMPOL_ACTIVE_LOW      = 1,  /*!< Output is active low (i.e., Compare value defines low time)     */
} CAPCTL_BIT_APWMPOL;

#define CAPCTL_ALL_APWMPOL_ACTIVE_HIGH     ((0x0UL) << CAPCTL_ALL_APWMPOL_Pos)
#define CAPCTL_ALL_APWMPOL_ACTIVE_LOW      ((0x1UL) << CAPCTL_ALL_APWMPOL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IFGLB
 *  @access     ECAP->CAPIEIF.bit.IFGLB
 *  @brief      Global Interrupt Status Flag
 */
#define CAPIEIF_ALL_IFGLB_Pos (0)
#define CAPIEIF_ALL_IFGLB_Msk (0x1UL << CAPIEIF_ALL_IFGLB_Pos)

typedef enum
{
    CAPIEIF_BIT_IFGLB_NOT_OCCUR     = 0,  /*!< Indicates no interrupt generated            */
    CAPIEIF_BIT_IFGLB_OCCUR         = 1,  /*!< Indicates that an interrupt was generated   */
} CAPIEIF_BIT_IFGLB;

#define CAPIEIF_ALL_IFGLB_NOT_OCCUR     ((0x0UL) << CAPIEIF_ALL_IFGLB_Pos)
#define CAPIEIF_ALL_IFGLB_OCCUR         ((0x1UL) << CAPIEIF_ALL_IFGLB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IFCEVT0
 *  @access     ECAP->CAPIEIF.bit.IFCEVT0
 *  @brief      Capture Event 0 Status Flag
 *              This flag is only active in Capture mode.
 */
#define CAPIEIF_ALL_IFCEVT0_Pos (1)
#define CAPIEIF_ALL_IFCEVT0_Msk (0x1UL << CAPIEIF_ALL_IFCEVT0_Pos)

typedef enum
{
    CAPIEIF_BIT_IFCEVT0_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                       */
    CAPIEIF_BIT_IFCEVT0_OCCUR         = 1,  /*!< Indicates the first event occurred at ECAPx pin   */
} CAPIEIF_BIT_IFCEVT0;

#define CAPIEIF_ALL_IFCEVT0_NOT_OCCUR     ((0x0UL) << CAPIEIF_ALL_IFCEVT0_Pos)
#define CAPIEIF_ALL_IFCEVT0_OCCUR         ((0x1UL) << CAPIEIF_ALL_IFCEVT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IFCEVT1
 *  @access     ECAP->CAPIEIF.bit.IFCEVT1
 *  @brief      Capture Event 1 Status Flag
 *              This flag is only active in Capture mode.
 */
#define CAPIEIF_ALL_IFCEVT1_Pos (2)
#define CAPIEIF_ALL_IFCEVT1_Msk (0x1UL << CAPIEIF_ALL_IFCEVT1_Pos)

typedef enum
{
    CAPIEIF_BIT_IFCEVT1_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                        */
    CAPIEIF_BIT_IFCEVT1_OCCUR         = 1,  /*!< Indicates the second event occurred at ECAPx pin   */
} CAPIEIF_BIT_IFCEVT1;

#define CAPIEIF_ALL_IFCEVT1_NOT_OCCUR     ((0x0UL) << CAPIEIF_ALL_IFCEVT1_Pos)
#define CAPIEIF_ALL_IFCEVT1_OCCUR         ((0x1UL) << CAPIEIF_ALL_IFCEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IFCEVT2
 *  @access     ECAP->CAPIEIF.bit.IFCEVT2
 *  @brief      Capture Event 2 Status Flag
 *              This flag is active only in Capture mode.
 */
#define CAPIEIF_ALL_IFCEVT2_Pos (3)
#define CAPIEIF_ALL_IFCEVT2_Msk (0x1UL << CAPIEIF_ALL_IFCEVT2_Pos)

typedef enum
{
    CAPIEIF_BIT_IFCEVT2_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                       */
    CAPIEIF_BIT_IFCEVT2_OCCUR         = 1,  /*!< Indicates the third event occurred at ECAPx pin   */
} CAPIEIF_BIT_IFCEVT2;

#define CAPIEIF_ALL_IFCEVT2_NOT_OCCUR     ((0x0UL) << CAPIEIF_ALL_IFCEVT2_Pos)
#define CAPIEIF_ALL_IFCEVT2_OCCUR         ((0x1UL) << CAPIEIF_ALL_IFCEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IFCEVT3
 *  @access     ECAP->CAPIEIF.bit.IFCEVT3
 *  @brief      Capture Event 3 Status Flag
 *              This flag is only active in Capture mode.
 */
#define CAPIEIF_ALL_IFCEVT3_Pos (4)
#define CAPIEIF_ALL_IFCEVT3_Msk (0x1UL << CAPIEIF_ALL_IFCEVT3_Pos)

typedef enum
{
    CAPIEIF_BIT_IFCEVT3_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                        */
    CAPIEIF_BIT_IFCEVT3_OCCUR         = 1,  /*!< Indicates the fourth event occurred at ECAPx pin   */
} CAPIEIF_BIT_IFCEVT3;

#define CAPIEIF_ALL_IFCEVT3_NOT_OCCUR     ((0x0UL) << CAPIEIF_ALL_IFCEVT3_Pos)
#define CAPIEIF_ALL_IFCEVT3_OCCUR         ((0x1UL) << CAPIEIF_ALL_IFCEVT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IFCNTOVF
 *  @access     ECAP->CAPIEIF.bit.IFCNTOVF
 *  @brief      Counter Overflow Status Flag.
 *              This flag is active in Capture and APWM mode.
 */
#define CAPIEIF_ALL_IFCNTOVF_Pos (5)
#define CAPIEIF_ALL_IFCNTOVF_Msk (0x1UL << CAPIEIF_ALL_IFCNTOVF_Pos)

typedef enum
{
    CAPIEIF_BIT_IFCNTOVF_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                                                       */
    CAPIEIF_BIT_IFCNTOVF_OCCUR         = 1,  /*!< Indicates the counter (TSCNT) has made the transition from FFFFFFFF to 00000000   */
} CAPIEIF_BIT_IFCNTOVF;

#define CAPIEIF_ALL_IFCNTOVF_NOT_OCCUR     ((0x0UL) << CAPIEIF_ALL_IFCNTOVF_Pos)
#define CAPIEIF_ALL_IFCNTOVF_OCCUR         ((0x1UL) << CAPIEIF_ALL_IFCNTOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IFPRD
 *  @access     ECAP->CAPIEIF.bit.IFPRD
 *  @brief      Counter Equal Period Status Flag
 *              This flag is only active in APWM mode.
 */
#define CAPIEIF_ALL_IFPRD_Pos (6)
#define CAPIEIF_ALL_IFPRD_Msk (0x1UL << CAPIEIF_ALL_IFPRD_Pos)

typedef enum
{
    CAPIEIF_BIT_IFPRD_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                                                            */
    CAPIEIF_BIT_IFPRD_OCCUR         = 1,  /*!< Indicates the counter (TSCNT) reached the period register value (APRD) and was reset   */
} CAPIEIF_BIT_IFPRD;

#define CAPIEIF_ALL_IFPRD_NOT_OCCUR     ((0x0UL) << CAPIEIF_ALL_IFPRD_Pos)
#define CAPIEIF_ALL_IFPRD_OCCUR         ((0x1UL) << CAPIEIF_ALL_IFPRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IFCMP
 *  @access     ECAP->CAPIEIF.bit.IFCMP
 *  @brief      Compare Equal Compare Status Flag
 *              This flag is active only in APWM mode.
 */
#define CAPIEIF_ALL_IFCMP_Pos (7)
#define CAPIEIF_ALL_IFCMP_Msk (0x1UL << CAPIEIF_ALL_IFCMP_Pos)

typedef enum
{
    CAPIEIF_BIT_IFCMP_NOT_OCCUR     = 0,  /*!< Indicates no event occurred                                               */
    CAPIEIF_BIT_IFCMP_OCCUR         = 1,  /*!< Indicates the counter (TSCNT) reached the compare register value (ACMP)   */
} CAPIEIF_BIT_IFCMP;

#define CAPIEIF_ALL_IFCMP_NOT_OCCUR     ((0x0UL) << CAPIEIF_ALL_IFCMP_Pos)
#define CAPIEIF_ALL_IFCMP_OCCUR         ((0x1UL) << CAPIEIF_ALL_IFCMP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IECEVT0
 *  @access     ECAP->CAPIEIF.bit.IECEVT0
 *  @brief      Capture Event 0 Interrupt Enable
 */
#define CAPIEIF_ALL_IECEVT0_Pos (9)
#define CAPIEIF_ALL_IECEVT0_Msk (0x1UL << CAPIEIF_ALL_IECEVT0_Pos)

typedef enum
{
    CAPIEIF_BIT_IECEVT0_DISABLE     = 0,  /*!< Disable Capture Event 0 as an Interrupt source   */
    CAPIEIF_BIT_IECEVT0_ENABLE      = 1,  /*!< Enable Capture Event 0 as an Interrupt source    */
} CAPIEIF_BIT_IECEVT0;

#define CAPIEIF_ALL_IECEVT0_DISABLE     ((0x0UL) << CAPIEIF_ALL_IECEVT0_Pos)
#define CAPIEIF_ALL_IECEVT0_ENABLE      ((0x1UL) << CAPIEIF_ALL_IECEVT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IECEVT1
 *  @access     ECAP->CAPIEIF.bit.IECEVT1
 *  @brief      Capture Event 1 Interrupt Enable
 */
#define CAPIEIF_ALL_IECEVT1_Pos (10)
#define CAPIEIF_ALL_IECEVT1_Msk (0x1UL << CAPIEIF_ALL_IECEVT1_Pos)

typedef enum
{
    CAPIEIF_BIT_IECEVT1_DISABLE     = 0,  /*!< Disable Capture Event 1 as an Interrupt source   */
    CAPIEIF_BIT_IECEVT1_ENABLE      = 1,  /*!< Enable Capture Event 1 as an Interrupt source    */
} CAPIEIF_BIT_IECEVT1;

#define CAPIEIF_ALL_IECEVT1_DISABLE     ((0x0UL) << CAPIEIF_ALL_IECEVT1_Pos)
#define CAPIEIF_ALL_IECEVT1_ENABLE      ((0x1UL) << CAPIEIF_ALL_IECEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IECEVT2
 *  @access     ECAP->CAPIEIF.bit.IECEVT2
 *  @brief      Capture Event 2 Interrupt Enable
 */
#define CAPIEIF_ALL_IECEVT2_Pos (11)
#define CAPIEIF_ALL_IECEVT2_Msk (0x1UL << CAPIEIF_ALL_IECEVT2_Pos)

typedef enum
{
    CAPIEIF_BIT_IECEVT2_DISABLE     = 0,  /*!< Disable Capture Event 2 as an Interrupt source   */
    CAPIEIF_BIT_IECEVT2_ENABLE      = 1,  /*!< Enable Capture Event 2 as an Interrupt source    */
} CAPIEIF_BIT_IECEVT2;

#define CAPIEIF_ALL_IECEVT2_DISABLE     ((0x0UL) << CAPIEIF_ALL_IECEVT2_Pos)
#define CAPIEIF_ALL_IECEVT2_ENABLE      ((0x1UL) << CAPIEIF_ALL_IECEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IECEVT3
 *  @access     ECAP->CAPIEIF.bit.IECEVT3
 *  @brief      Capture Event 3 Interrupt Enable
 */
#define CAPIEIF_ALL_IECEVT3_Pos (12)
#define CAPIEIF_ALL_IECEVT3_Msk (0x1UL << CAPIEIF_ALL_IECEVT3_Pos)

typedef enum
{
    CAPIEIF_BIT_IECEVT3_DISABLE     = 0,  /*!< Disable Capture Event 3 as an Interrupt source   */
    CAPIEIF_BIT_IECEVT3_ENABLE      = 1,  /*!< Enable Capture Event 3 as an Interrupt source    */
} CAPIEIF_BIT_IECEVT3;

#define CAPIEIF_ALL_IECEVT3_DISABLE     ((0x0UL) << CAPIEIF_ALL_IECEVT3_Pos)
#define CAPIEIF_ALL_IECEVT3_ENABLE      ((0x1UL) << CAPIEIF_ALL_IECEVT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IECNTOVF
 *  @access     ECAP->CAPIEIF.bit.IECNTOVF
 *  @brief      Counter Overflow Interrupt Enable
 */
#define CAPIEIF_ALL_IECNTOVF_Pos (13)
#define CAPIEIF_ALL_IECNTOVF_Msk (0x1UL << CAPIEIF_ALL_IECNTOVF_Pos)

typedef enum
{
    CAPIEIF_BIT_IECNTOVF_DISABLE     = 0,  /*!< Disabled counter Overflow as an Interrupt source   */
    CAPIEIF_BIT_IECNTOVF_ENABLE      = 1,  /*!< Enable counter Overflow as an Interrupt source     */
} CAPIEIF_BIT_IECNTOVF;

#define CAPIEIF_ALL_IECNTOVF_DISABLE     ((0x0UL) << CAPIEIF_ALL_IECNTOVF_Pos)
#define CAPIEIF_ALL_IECNTOVF_ENABLE      ((0x1UL) << CAPIEIF_ALL_IECNTOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IEPRD
 *  @access     ECAP->CAPIEIF.bit.IEPRD
 *  @brief      Counter Equal Period Interrupt Enable
 */
#define CAPIEIF_ALL_IEPRD_Pos (14)
#define CAPIEIF_ALL_IEPRD_Msk (0x1UL << CAPIEIF_ALL_IEPRD_Pos)

typedef enum
{
    CAPIEIF_BIT_IEPRD_DISABLE     = 0,  /*!< Disable Period Equal as an Interrupt source   */
    CAPIEIF_BIT_IEPRD_ENABLE      = 1,  /*!< Enable Period Equal as an Interrupt source    */
} CAPIEIF_BIT_IEPRD;

#define CAPIEIF_ALL_IEPRD_DISABLE     ((0x0UL) << CAPIEIF_ALL_IEPRD_Pos)
#define CAPIEIF_ALL_IEPRD_ENABLE      ((0x1UL) << CAPIEIF_ALL_IEPRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPIEIF         IECMP
 *  @access     ECAP->CAPIEIF.bit.IECMP
 *  @brief      Counter Equal Compare Interrupt Enable
 */
#define CAPIEIF_ALL_IECMP_Pos (15)
#define CAPIEIF_ALL_IECMP_Msk (0x1UL << CAPIEIF_ALL_IECMP_Pos)

typedef enum
{
    CAPIEIF_BIT_IECMP_DISABLE     = 0,  /*!< Disable Compare Equal as an Interrupt source   */
    CAPIEIF_BIT_IECMP_ENABLE      = 1,  /*!< Enable Compare Equal as an Interrupt source    */
} CAPIEIF_BIT_IECMP;

#define CAPIEIF_ALL_IECMP_DISABLE     ((0x0UL) << CAPIEIF_ALL_IECMP_Pos)
#define CAPIEIF_ALL_IECMP_ENABLE      ((0x1UL) << CAPIEIF_ALL_IECMP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        FRCCEVT0
 *  @access     ECAP->CAPICFRC.bit.FRCCEVT0
 *  @brief      Force Capture Event 0
 */
#define CAPICFRC_ALL_FRCCEVT0_Pos (1)
#define CAPICFRC_ALL_FRCCEVT0_Msk (0x1UL << CAPICFRC_ALL_FRCCEVT0_Pos)

typedef enum
{
    CAPICFRC_BIT_FRCCEVT0_NO_EFFECT     = 0,  /*!< No effect. Always reads back a 0.   */
    CAPICFRC_BIT_FRCCEVT0_FORCE         = 1,  /*!< Sets the CEVT0 flag bit             */
} CAPICFRC_BIT_FRCCEVT0;

#define CAPICFRC_ALL_FRCCEVT0_NO_EFFECT     ((0x0UL) << CAPICFRC_ALL_FRCCEVT0_Pos)
#define CAPICFRC_ALL_FRCCEVT0_FORCE         ((0x1UL) << CAPICFRC_ALL_FRCCEVT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        FRCCEVT1
 *  @access     ECAP->CAPICFRC.bit.FRCCEVT1
 *  @brief      Force Capture Event 1
 */
#define CAPICFRC_ALL_FRCCEVT1_Pos (2)
#define CAPICFRC_ALL_FRCCEVT1_Msk (0x1UL << CAPICFRC_ALL_FRCCEVT1_Pos)

typedef enum
{
    CAPICFRC_BIT_FRCCEVT1_NO_EFFECT     = 0,  /*!< No effect. Always reads back a 0.     */
    CAPICFRC_BIT_FRCCEVT1_FORCE         = 1,  /*!< Writing a 1 sets the CEVT1 flag bit   */
} CAPICFRC_BIT_FRCCEVT1;

#define CAPICFRC_ALL_FRCCEVT1_NO_EFFECT     ((0x0UL) << CAPICFRC_ALL_FRCCEVT1_Pos)
#define CAPICFRC_ALL_FRCCEVT1_FORCE         ((0x1UL) << CAPICFRC_ALL_FRCCEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        FRCCEVT2
 *  @access     ECAP->CAPICFRC.bit.FRCCEVT2
 *  @brief      Force Capture Event 2
 */
#define CAPICFRC_ALL_FRCCEVT2_Pos (3)
#define CAPICFRC_ALL_FRCCEVT2_Msk (0x1UL << CAPICFRC_ALL_FRCCEVT2_Pos)

typedef enum
{
    CAPICFRC_BIT_FRCCEVT2_NO_EFFECT     = 0,  /*!< No effect. Always reads back a 0.     */
    CAPICFRC_BIT_FRCCEVT2_FORCE         = 1,  /*!< Writing a 1 sets the CEVT2 flag bit   */
} CAPICFRC_BIT_FRCCEVT2;

#define CAPICFRC_ALL_FRCCEVT2_NO_EFFECT     ((0x0UL) << CAPICFRC_ALL_FRCCEVT2_Pos)
#define CAPICFRC_ALL_FRCCEVT2_FORCE         ((0x1UL) << CAPICFRC_ALL_FRCCEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        FRCCEVT3
 *  @access     ECAP->CAPICFRC.bit.FRCCEVT3
 *  @brief      Force Capture Event 3
 */
#define CAPICFRC_ALL_FRCCEVT3_Pos (4)
#define CAPICFRC_ALL_FRCCEVT3_Msk (0x1UL << CAPICFRC_ALL_FRCCEVT3_Pos)

typedef enum
{
    CAPICFRC_BIT_FRCCEVT3_NO_EFFECT     = 0,  /*!< No effect. Always reads back a 0.     */
    CAPICFRC_BIT_FRCCEVT3_FORCE         = 1,  /*!< Writing a 1 sets the CEVT3 flag bit   */
} CAPICFRC_BIT_FRCCEVT3;

#define CAPICFRC_ALL_FRCCEVT3_NO_EFFECT     ((0x0UL) << CAPICFRC_ALL_FRCCEVT3_Pos)
#define CAPICFRC_ALL_FRCCEVT3_FORCE         ((0x1UL) << CAPICFRC_ALL_FRCCEVT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        FRCCNTOVF
 *  @access     ECAP->CAPICFRC.bit.FRCCNTOVF
 *  @brief      Force Counter Overflow
 */
#define CAPICFRC_ALL_FRCCNTOVF_Pos (5)
#define CAPICFRC_ALL_FRCCNTOVF_Msk (0x1UL << CAPICFRC_ALL_FRCCNTOVF_Pos)

typedef enum
{
    CAPICFRC_BIT_FRCCNTOVF_NO_EFFECT              = 0,  /*!< No effect. Always reads back a 0.      */
    CAPICFRC_BIT_FRCCNTOVF_FORCE_CNT_OVERFLOW     = 1,  /*!< Writing a 1 sets the CNTOVF flag bit   */
} CAPICFRC_BIT_FRCCNTOVF;

#define CAPICFRC_ALL_FRCCNTOVF_NO_EFFECT              ((0x0UL) << CAPICFRC_ALL_FRCCNTOVF_Pos)
#define CAPICFRC_ALL_FRCCNTOVF_FORCE_CNT_OVERFLOW     ((0x1UL) << CAPICFRC_ALL_FRCCNTOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        FRCPRD
 *  @access     ECAP->CAPICFRC.bit.FRCPRD
 *  @brief      Force Counter Equal Period Interrupt
 */
#define CAPICFRC_ALL_FRCPRD_Pos (6)
#define CAPICFRC_ALL_FRCPRD_Msk (0x1UL << CAPICFRC_ALL_FRCPRD_Pos)

typedef enum
{
    CAPICFRC_BIT_FRCPRD_NO_EFFECT             = 0,  /*!< No effect. Always reads back a 0.       */
    CAPICFRC_BIT_FRCPRD_FORCE_CNT_EQU_PRD     = 1,  /*!< Writing a 1 sets the CNT=PRD flag bit   */
} CAPICFRC_BIT_FRCPRD;

#define CAPICFRC_ALL_FRCPRD_NO_EFFECT             ((0x0UL) << CAPICFRC_ALL_FRCPRD_Pos)
#define CAPICFRC_ALL_FRCPRD_FORCE_CNT_EQU_PRD     ((0x1UL) << CAPICFRC_ALL_FRCPRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        FRCCMP
 *  @access     ECAP->CAPICFRC.bit.FRCCMP
 *  @brief      Force Counter Equal Compare Interrupt
 */
#define CAPICFRC_ALL_FRCCMP_Pos (7)
#define CAPICFRC_ALL_FRCCMP_Msk (0x1UL << CAPICFRC_ALL_FRCCMP_Pos)

typedef enum
{
    CAPICFRC_BIT_FRCCMP_NO_EFFECT              = 0,  /*!< No effect. Always reads back a 0.       */
    CAPICFRC_BIT_FRCCMP_FORCE_CNT_EQU_COMP     = 1,  /*!< Writing a 1 sets the CNT=CMP flag bit   */
} CAPICFRC_BIT_FRCCMP;

#define CAPICFRC_ALL_FRCCMP_NO_EFFECT              ((0x0UL) << CAPICFRC_ALL_FRCCMP_Pos)
#define CAPICFRC_ALL_FRCCMP_FORCE_CNT_EQU_COMP     ((0x1UL) << CAPICFRC_ALL_FRCCMP_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        ICGLB
 *  @access     ECAP->CAPICFRC.bit.ICGLB
 *  @brief      Global Interrupt Clear Flag
 */
#define CAPICFRC_ALL_ICGLB_Pos (8)
#define CAPICFRC_ALL_ICGLB_Msk (0x1UL << CAPICFRC_ALL_ICGLB_Pos)

typedef enum
{
    CAPICFRC_BIT_ICGLB_NO_EFFECT                 = 0,  /*!< Writing a 0 has no effect. Always reads back a 0.                                                                      */
    CAPICFRC_BIT_ICGLB_CLEAR_GLOBAL_INT_FLAG     = 1,  /*!< Writing a 1 clears the INT flag and enable further interrupts to be generated if any of the event flags are set to 1   */
} CAPICFRC_BIT_ICGLB;

#define CAPICFRC_ALL_ICGLB_NO_EFFECT                 ((0x0UL) << CAPICFRC_ALL_ICGLB_Pos)
#define CAPICFRC_ALL_ICGLB_CLEAR_GLOBAL_INT_FLAG     ((0x1UL) << CAPICFRC_ALL_ICGLB_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        ICCEVT0
 *  @access     ECAP->CAPICFRC.bit.ICCEVT0
 *  @brief      Capture Event 0 Status Flag
 */
#define CAPICFRC_ALL_ICCEVT0_Pos (9)
#define CAPICFRC_ALL_ICCEVT0_Msk (0x1UL << CAPICFRC_ALL_ICCEVT0_Pos)

typedef enum
{
    CAPICFRC_BIT_ICCEVT0_NO_EFFECT     = 0,  /*!< Writing a 0 has no effect. Always reads back a 0.   */
    CAPICFRC_BIT_ICCEVT0_CLEAR         = 1,  /*!< Writing a 1 clears the CEVT0 flag condition         */
} CAPICFRC_BIT_ICCEVT0;

#define CAPICFRC_ALL_ICCEVT0_NO_EFFECT     ((0x0UL) << CAPICFRC_ALL_ICCEVT0_Pos)
#define CAPICFRC_ALL_ICCEVT0_CLEAR         ((0x1UL) << CAPICFRC_ALL_ICCEVT0_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        ICCEVT1
 *  @access     ECAP->CAPICFRC.bit.ICCEVT1
 *  @brief      Capture Event 1 Status Flag
 */
#define CAPICFRC_ALL_ICCEVT1_Pos (10)
#define CAPICFRC_ALL_ICCEVT1_Msk (0x1UL << CAPICFRC_ALL_ICCEVT1_Pos)

typedef enum
{
    CAPICFRC_BIT_ICCEVT1_NO_EFFECT     = 0,  /*!< Writing a 0 has no effect. Always reads back a 0.   */
    CAPICFRC_BIT_ICCEVT1_CLEAR         = 1,  /*!< Writing a 1 clears the CEVT1 flag condition         */
} CAPICFRC_BIT_ICCEVT1;

#define CAPICFRC_ALL_ICCEVT1_NO_EFFECT     ((0x0UL) << CAPICFRC_ALL_ICCEVT1_Pos)
#define CAPICFRC_ALL_ICCEVT1_CLEAR         ((0x1UL) << CAPICFRC_ALL_ICCEVT1_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        ICCEVT2
 *  @access     ECAP->CAPICFRC.bit.ICCEVT2
 *  @brief      Capture Event 2 Status Flag
 */
#define CAPICFRC_ALL_ICCEVT2_Pos (11)
#define CAPICFRC_ALL_ICCEVT2_Msk (0x1UL << CAPICFRC_ALL_ICCEVT2_Pos)

typedef enum
{
    CAPICFRC_BIT_ICCEVT2_NO_EFFECT     = 0,  /*!< Writing a 0 has no effect. Always reads back a 0.   */
    CAPICFRC_BIT_ICCEVT2_CLEAR         = 1,  /*!< Writing a 1 clears the CEVT2 flag condition         */
} CAPICFRC_BIT_ICCEVT2;

#define CAPICFRC_ALL_ICCEVT2_NO_EFFECT     ((0x0UL) << CAPICFRC_ALL_ICCEVT2_Pos)
#define CAPICFRC_ALL_ICCEVT2_CLEAR         ((0x1UL) << CAPICFRC_ALL_ICCEVT2_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        ICCEVT3
 *  @access     ECAP->CAPICFRC.bit.ICCEVT3
 *  @brief      Capture Event 3 Status Flag
 */
#define CAPICFRC_ALL_ICCEVT3_Pos (12)
#define CAPICFRC_ALL_ICCEVT3_Msk (0x1UL << CAPICFRC_ALL_ICCEVT3_Pos)

typedef enum
{
    CAPICFRC_BIT_ICCEVT3_NO_EFFECT     = 0,  /*!< Writing a 0 has no effect. Always reads back a 0.   */
    CAPICFRC_BIT_ICCEVT3_CLEAR         = 1,  /*!< Writing a 1 clears the CEVT3 flag condition         */
} CAPICFRC_BIT_ICCEVT3;

#define CAPICFRC_ALL_ICCEVT3_NO_EFFECT     ((0x0UL) << CAPICFRC_ALL_ICCEVT3_Pos)
#define CAPICFRC_ALL_ICCEVT3_CLEAR         ((0x1UL) << CAPICFRC_ALL_ICCEVT3_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        ICCNTOVF
 *  @access     ECAP->CAPICFRC.bit.ICCNTOVF
 *  @brief      Counter Overflow Status Flag
 */
#define CAPICFRC_ALL_ICCNTOVF_Pos (13)
#define CAPICFRC_ALL_ICCNTOVF_Msk (0x1UL << CAPICFRC_ALL_ICCNTOVF_Pos)

typedef enum
{
    CAPICFRC_BIT_ICCNTOVF_NO_EFFECT                   = 0,  /*!< Writing a 0 has no effect. Always reads back a 0.   */
    CAPICFRC_BIT_ICCNTOVF_CLEAR_CNT_OVERFLOW_FLAG     = 1,  /*!< Writing a 1 clears the CNTOVF flag condition        */
} CAPICFRC_BIT_ICCNTOVF;

#define CAPICFRC_ALL_ICCNTOVF_NO_EFFECT                   ((0x0UL) << CAPICFRC_ALL_ICCNTOVF_Pos)
#define CAPICFRC_ALL_ICCNTOVF_CLEAR_CNT_OVERFLOW_FLAG     ((0x1UL) << CAPICFRC_ALL_ICCNTOVF_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        ICPRD
 *  @access     ECAP->CAPICFRC.bit.ICPRD
 *  @brief      Counter Equal Period Status Flag
 */
#define CAPICFRC_ALL_ICPRD_Pos (14)
#define CAPICFRC_ALL_ICPRD_Msk (0x1UL << CAPICFRC_ALL_ICPRD_Pos)

typedef enum
{
    CAPICFRC_BIT_ICPRD_NO_EFFECT                  = 0,  /*!< Writing a 0 has no effect. Always reads back a 0.   */
    CAPICFRC_BIT_ICPRD_CLEAR_CNT_EQU_PRD_FLAG     = 1,  /*!< Writing a 1 clears the CNT=PRD flag condition       */
} CAPICFRC_BIT_ICPRD;

#define CAPICFRC_ALL_ICPRD_NO_EFFECT                  ((0x0UL) << CAPICFRC_ALL_ICPRD_Pos)
#define CAPICFRC_ALL_ICPRD_CLEAR_CNT_EQU_PRD_FLAG     ((0x1UL) << CAPICFRC_ALL_ICPRD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   ECAP            CAPICFRC        ICCMP
 *  @access     ECAP->CAPICFRC.bit.ICCMP
 *  @brief      Counter Equal Compare Status Flag
 */
#define CAPICFRC_ALL_ICCMP_Pos (15)
#define CAPICFRC_ALL_ICCMP_Msk (0x1UL << CAPICFRC_ALL_ICCMP_Pos)

typedef enum
{
    CAPICFRC_BIT_ICCMP_NO_EFFECT                   = 0,  /*!< Writing a 0 has no effect. Always reads back a 0.   */
    CAPICFRC_BIT_ICCMP_CLEAR_CNT_EQU_COMP_FLAG     = 1,  /*!< Writing a 1 clears the CNT=CMP flag condition       */
} CAPICFRC_BIT_ICCMP;

#define CAPICFRC_ALL_ICCMP_NO_EFFECT                   ((0x0UL) << CAPICFRC_ALL_ICCMP_Pos)
#define CAPICFRC_ALL_ICCMP_CLEAR_CNT_EQU_COMP_FLAG     ((0x1UL) << CAPICFRC_ALL_ICCMP_Pos)





/********************************************************************************
*
* Module Name     CRC
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCIF           DONE
 *  @access     CRC->CRCIF.bit.DONE
 *  @brief      CRC calculation done interrupt status after mask
 */
#define CRCIF_ALL_DONE_Pos (0)
#define CRCIF_ALL_DONE_Msk (0x1UL << CRCIF_ALL_DONE_Pos)

typedef enum
{
    CRCIF_BIT_DONE_NOT_OCCUR     = 0,  /*!< Interrupt is not occurred   */
    CRCIF_BIT_DONE_OCCUR         = 1,  /*!< Interrupt is occurred       */
} CRCIF_BIT_DONE;

#define CRCIF_ALL_DONE_NOT_OCCUR     ((0x0UL) << CRCIF_ALL_DONE_Pos)
#define CRCIF_ALL_DONE_OCCUR         ((0x1UL) << CRCIF_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCRAWIF        DONE
 *  @access     CRC->CRCRAWIF.bit.DONE
 *  @brief      CRC calculation done interrupt raw status regardless of mask
 *              
 */
#define CRCRAWIF_ALL_DONE_Pos (0)
#define CRCRAWIF_ALL_DONE_Msk (0x1UL << CRCRAWIF_ALL_DONE_Pos)

typedef enum
{
    CRCRAWIF_BIT_DONE_NOT_OCCUR     = 0,  /*!< Interrupt is not occurred   */
    CRCRAWIF_BIT_DONE_OCCUR         = 1,  /*!< Interrupt is occurred       */
} CRCRAWIF_BIT_DONE;

#define CRCRAWIF_ALL_DONE_NOT_OCCUR     ((0x0UL) << CRCRAWIF_ALL_DONE_Pos)
#define CRCRAWIF_ALL_DONE_OCCUR         ((0x1UL) << CRCRAWIF_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCIC           DONE
 *  @access     CRC->CRCIC.bit.DONE
 *  @brief      Clearance of CRCIF[0] and CRCRAWIF[0]
 */
#define CRCIC_ALL_DONE_Pos (0)
#define CRCIC_ALL_DONE_Msk (0x1UL << CRCIC_ALL_DONE_Pos)

typedef enum
{
    CRCIC_BIT_DONE_NO_EFFECT      = 0,  /*!<                                                                                          */
    CRCIC_BIT_DONE_CLEAR_FLAG     = 1,  /*!< Write "1" will generate a single-cycle pulse that clears both CRCIF[0] and CRCRAWIF[0]   */
} CRCIC_BIT_DONE;

#define CRCIC_ALL_DONE_NO_EFFECT      ((0x0UL) << CRCIC_ALL_DONE_Pos)
#define CRCIC_ALL_DONE_CLEAR_FLAG     ((0x1UL) << CRCIC_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCINTMSK       MSKDONE
 *  @access     CRC->CRCINTMSK.bit.MSKDONE
 *  @brief      Mask of interrupt
 *              
 */
#define CRCINTMSK_ALL_MSKDONE_Pos (0)
#define CRCINTMSK_ALL_MSKDONE_Msk (0x1UL << CRCINTMSK_ALL_MSKDONE_Pos)

typedef enum
{
    CRCINTMSK_BIT_MSKDONE_UNMASK     = 0,  /*!< Enable generation of IRQ and corresponding CRCIF[0]    */
    CRCINTMSK_BIT_MSKDONE_MASK       = 1,  /*!< Disable generation of IRQ and corresponding CRCIF[0]   */
} CRCINTMSK_BIT_MSKDONE;

#define CRCINTMSK_ALL_MSKDONE_UNMASK     ((0x0UL) << CRCINTMSK_ALL_MSKDONE_Pos)
#define CRCINTMSK_ALL_MSKDONE_MASK       ((0x1UL) << CRCINTMSK_ALL_MSKDONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCCTL          EN
 *  @access     CRC->CRCCTL.bit.EN
 *  @brief      CRC calculate enable
 */
#define CRCCTL_ALL_EN_Pos (0)
#define CRCCTL_ALL_EN_Msk (0x1UL << CRCCTL_ALL_EN_Pos)

typedef enum
{
    CRCCTL_BIT_EN_DISABLE     = 0,  /*!< Disable CRC calculation                                                                    */
    CRCCTL_BIT_EN_ENABLE      = 1,  /*!< Enable CRC calculation, it is automatically cleared when the CRC calculation is finished   */
} CRCCTL_BIT_EN;

#define CRCCTL_ALL_EN_DISABLE     ((0x0UL) << CRCCTL_ALL_EN_Pos)
#define CRCCTL_ALL_EN_ENABLE      ((0x1UL) << CRCCTL_ALL_EN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCCTL          MODE
 *  @access     CRC->CRCCTL.bit.MODE
 *  @brief      CRC mode select
 */
#define CRCCTL_ALL_MODE_Pos (1)
#define CRCCTL_ALL_MODE_Msk (0x7UL << CRCCTL_ALL_MODE_Pos)

typedef enum
{
    CRCCTL_BIT_MODE_16_CCITT       = 0,  /*!< x**16+x**12+x**5+1 (CRC-16-CCITT, CRC-CCITT)                                                      */
    CRCCTL_BIT_MODE_16_IBM         = 1,  /*!< x**16+x**15+x**2+1 (CRC-16, CRC-16-IBM, CRC-16-ANSI)                                              */
    CRCCTL_BIT_MODE_16_T10_DIF     = 2,  /*!< x**16+x**15+x**11+x**9+x**8+x**7+x**5+x**4+x**2+x+1 (CRC-16-T10-DIF)                              */
    CRCCTL_BIT_MODE_IEEE802_3      = 3,  /*!< x**32+x**26+x**23+x**22+x**16+x**12+x**11+x**10+x**8+x**7+x**5+x**4+x**2+x+1 (CRC-32-IEEE802.3)   */
    CRCCTL_BIT_MODE_16_DNP         = 4,  /*!< x**16+x**13+x**12+x**11+x**10+x**8+x**6+x**5+x**2+1(CRC-16-DNP)                                   */
} CRCCTL_BIT_MODE;

#define CRCCTL_ALL_MODE_16_CCITT       ((0x0UL) << CRCCTL_ALL_MODE_Pos)
#define CRCCTL_ALL_MODE_16_IBM         ((0x1UL) << CRCCTL_ALL_MODE_Pos)
#define CRCCTL_ALL_MODE_16_T10_DIF     ((0x2UL) << CRCCTL_ALL_MODE_Pos)
#define CRCCTL_ALL_MODE_IEEE802_3      ((0x3UL) << CRCCTL_ALL_MODE_Pos)
#define CRCCTL_ALL_MODE_16_DNP         ((0x4UL) << CRCCTL_ALL_MODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCSTRLEN       VAL
 *  @access     CRC->CRCSTRLEN.bit.VAL
 *  @brief      Input stream length minus 1(in unit of byte)
 */
#define CRCSTRLEN_ALL_VAL_Pos (0)
#define CRCSTRLEN_ALL_VAL_Msk (0xFFFFFFFFUL << CRCSTRLEN_ALL_VAL_Pos)

#define CRCSTRLEN_BIT_VAL

#define CRCSTRLEN_ALL_VAL_(x) ((x) << CRCSTRLEN_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCSTRIN        VAL
 *  @access     CRC->CRCSTRIN.bit.VAL
 *  @brief      Stream Input data register
 */
#define CRCSTRIN_ALL_VAL_Pos (0)
#define CRCSTRIN_ALL_VAL_Msk (0xFFFFFFFFUL << CRCSTRIN_ALL_VAL_Pos)

#define CRCSTRIN_BIT_VAL

#define CRCSTRIN_ALL_VAL_(x) ((x) << CRCSTRIN_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   CRC             CRCRESULT       VAL
 *  @access     CRC->CRCRESULT.bit.VAL
 *  @brief      CRC calculation result
 */
#define CRCRESULT_ALL_VAL_Pos (0)
#define CRCRESULT_ALL_VAL_Msk (0xFFFFFFFFUL << CRCRESULT_ALL_VAL_Pos)

#define CRCRESULT_BIT_VAL

#define CRCRESULT_ALL_VAL_(x) ((x) << CRCRESULT_ALL_VAL_Pos)





/********************************************************************************
*
* Module Name     AES
*
*
********************************************************************************/



/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         START
 *  @access     AES->AESCTL0.bit.START
 *  @brief      Start AES
 */
#define AESCTL0_ALL_START_Pos (0)
#define AESCTL0_ALL_START_Msk (0x1UL << AESCTL0_ALL_START_Pos)

typedef enum
{
    AESCTL0_BIT_START_NO_EFFECT     = 0,  /*!<                                                                  */
    AESCTL0_BIT_START_AES_START     = 1,  /*!< Write '1' will generate one-cycle pulse to start AES operation   */
} AESCTL0_BIT_START;

#define AESCTL0_ALL_START_NO_EFFECT     ((0x0UL) << AESCTL0_ALL_START_Pos)
#define AESCTL0_ALL_START_AES_START     ((0x1UL) << AESCTL0_ALL_START_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         IFIFOCLR
 *  @access     AES->AESCTL0.bit.IFIFOCLR
 *  @brief      Clear input FIFO
 */
#define AESCTL0_ALL_IFIFOCLR_Pos (2)
#define AESCTL0_ALL_IFIFOCLR_Msk (0x1UL << AESCTL0_ALL_IFIFOCLR_Pos)

typedef enum
{
    AESCTL0_BIT_IFIFOCLR_NO_EFFECT            = 0,  /*!<                                                               */
    AESCTL0_BIT_IFIFOCLR_CLEAR_INPUT_FIFO     = 1,  /*!< Write '1' will generate one-cycle pulse to clear input FIFO   */
} AESCTL0_BIT_IFIFOCLR;

#define AESCTL0_ALL_IFIFOCLR_NO_EFFECT            ((0x0UL) << AESCTL0_ALL_IFIFOCLR_Pos)
#define AESCTL0_ALL_IFIFOCLR_CLEAR_INPUT_FIFO     ((0x1UL) << AESCTL0_ALL_IFIFOCLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         OFIFOCLR
 *  @access     AES->AESCTL0.bit.OFIFOCLR
 *  @brief      Clear output FIFO
 */
#define AESCTL0_ALL_OFIFOCLR_Pos (3)
#define AESCTL0_ALL_OFIFOCLR_Msk (0x1UL << AESCTL0_ALL_OFIFOCLR_Pos)

typedef enum
{
    AESCTL0_BIT_OFIFOCLR_NO_EFFECT             = 0,  /*!<                                                                */
    AESCTL0_BIT_OFIFOCLR_CLEAR_OUTPUT_FIFO     = 1,  /*!< Write '1' will generate one-cycle pulse to clear output FIFO   */
} AESCTL0_BIT_OFIFOCLR;

#define AESCTL0_ALL_OFIFOCLR_NO_EFFECT             ((0x0UL) << AESCTL0_ALL_OFIFOCLR_Pos)
#define AESCTL0_ALL_OFIFOCLR_CLEAR_OUTPUT_FIFO     ((0x1UL) << AESCTL0_ALL_OFIFOCLR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         OUTMSG
 *  @access     AES->AESCTL0.bit.OUTMSG
 *  @brief      Output stream to output FIFO
 */
#define AESCTL0_ALL_OUTMSG_Pos (4)
#define AESCTL0_ALL_OUTMSG_Msk (0x1UL << AESCTL0_ALL_OUTMSG_Pos)

typedef enum
{
    AESCTL0_BIT_OUTMSG_DISABLE     = 0,  /*!< Block output stream from output FIFO   */
    AESCTL0_BIT_OUTMSG_ENABLE      = 1,  /*!< Forward output stream to output FIFO   */
} AESCTL0_BIT_OUTMSG;

#define AESCTL0_ALL_OUTMSG_DISABLE     ((0x0UL) << AESCTL0_ALL_OUTMSG_Pos)
#define AESCTL0_ALL_OUTMSG_ENABLE      ((0x1UL) << AESCTL0_ALL_OUTMSG_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         OUTHDR
 *  @access     AES->AESCTL0.bit.OUTHDR
 *  @brief      Output B0 and l(a) in CCM* mode
 */
#define AESCTL0_ALL_OUTHDR_Pos (5)
#define AESCTL0_ALL_OUTHDR_Msk (0x1UL << AESCTL0_ALL_OUTHDR_Pos)

typedef enum
{
    AESCTL0_BIT_OUTHDR_DISABLE     = 0,  /*!< Don't output B0 and l(a) at the beginning of output stream   */
    AESCTL0_BIT_OUTHDR_ENABLE      = 1,  /*!< Output B0 and l(a) at the beginning of output stream         */
} AESCTL0_BIT_OUTHDR;

#define AESCTL0_ALL_OUTHDR_DISABLE     ((0x0UL) << AESCTL0_ALL_OUTHDR_Pos)
#define AESCTL0_ALL_OUTHDR_ENABLE      ((0x1UL) << AESCTL0_ALL_OUTHDR_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         KEYSIZE
 *  @access     AES->AESCTL0.bit.KEYSIZE
 *  @brief      Key size parameter
 */
#define AESCTL0_ALL_KEYSIZE_Pos (10)
#define AESCTL0_ALL_KEYSIZE_Msk (0x3UL << AESCTL0_ALL_KEYSIZE_Pos)

typedef enum
{
    AESCTL0_BIT_KEYSIZE_16BYTE     = 0,  /*!< 16 bytes   */
    AESCTL0_BIT_KEYSIZE_32BYTE     = 1,  /*!< 32 bytes   */
    AESCTL0_BIT_KEYSIZE_24BYTE     = 2,  /*!< 24 bytes   */
} AESCTL0_BIT_KEYSIZE;

#define AESCTL0_ALL_KEYSIZE_16BYTE     ((0x0UL) << AESCTL0_ALL_KEYSIZE_Pos)
#define AESCTL0_ALL_KEYSIZE_32BYTE     ((0x1UL) << AESCTL0_ALL_KEYSIZE_Pos)
#define AESCTL0_ALL_KEYSIZE_24BYTE     ((0x2UL) << AESCTL0_ALL_KEYSIZE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         MICLEN
 *  @access     AES->AESCTL0.bit.MICLEN
 *  @brief      Length of MIC field
 */
#define AESCTL0_ALL_MICLEN_Pos (12)
#define AESCTL0_ALL_MICLEN_Msk (0x3UL << AESCTL0_ALL_MICLEN_Pos)

typedef enum
{
    AESCTL0_BIT_MICLEN_0BYTE      = 0,  /*!< 0 bytes    */
    AESCTL0_BIT_MICLEN_4BYTE      = 1,  /*!< 4 bytes    */
    AESCTL0_BIT_MICLEN_8BYTE      = 2,  /*!< 8 bytes    */
    AESCTL0_BIT_MICLEN_16BYTE     = 3,  /*!< 16 bytes   */
} AESCTL0_BIT_MICLEN;

#define AESCTL0_ALL_MICLEN_0BYTE      ((0x0UL) << AESCTL0_ALL_MICLEN_Pos)
#define AESCTL0_ALL_MICLEN_4BYTE      ((0x1UL) << AESCTL0_ALL_MICLEN_Pos)
#define AESCTL0_ALL_MICLEN_8BYTE      ((0x2UL) << AESCTL0_ALL_MICLEN_Pos)
#define AESCTL0_ALL_MICLEN_16BYTE     ((0x3UL) << AESCTL0_ALL_MICLEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         OUTMIC
 *  @access     AES->AESCTL0.bit.OUTMIC
 *  @brief      Append MIC/HASH at the end of output stream in CCM* mode encryption/MMO mode.
 */
#define AESCTL0_ALL_OUTMIC_Pos (14)
#define AESCTL0_ALL_OUTMIC_Msk (0x1UL << AESCTL0_ALL_OUTMIC_Pos)

typedef enum
{
    AESCTL0_BIT_OUTMIC_DISABLE     = 0,  /*!< Not append MIC/HASH at the end of output stream in CCM* mode encryption or MMO mode   */
    AESCTL0_BIT_OUTMIC_ENABLE      = 1,  /*!< Append MIC/HASH at the end of output stream in CCM* mode encryption or MMO mode       */
} AESCTL0_BIT_OUTMIC;

#define AESCTL0_ALL_OUTMIC_DISABLE     ((0x0UL) << AESCTL0_ALL_OUTMIC_Pos)
#define AESCTL0_ALL_OUTMIC_ENABLE      ((0x1UL) << AESCTL0_ALL_OUTMIC_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         DECRYPTEN
 *  @access     AES->AESCTL0.bit.DECRYPTEN
 *  @brief      Decrypt operation. Ignored in MMO and BYPASS Mode.
 */
#define AESCTL0_ALL_DECRYPTEN_Pos (15)
#define AESCTL0_ALL_DECRYPTEN_Msk (0x1UL << AESCTL0_ALL_DECRYPTEN_Pos)

typedef enum
{
    AESCTL0_BIT_DECRYPTEN_ENCRYPT     = 0,  /*!< Encryption   */
    AESCTL0_BIT_DECRYPTEN_DECRYPT     = 1,  /*!< Decryption   */
} AESCTL0_BIT_DECRYPTEN;

#define AESCTL0_ALL_DECRYPTEN_ENCRYPT     ((0x0UL) << AESCTL0_ALL_DECRYPTEN_Pos)
#define AESCTL0_ALL_DECRYPTEN_DECRYPT     ((0x1UL) << AESCTL0_ALL_DECRYPTEN_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         MODE
 *  @access     AES->AESCTL0.bit.MODE
 *  @brief      AES running mode
 */
#define AESCTL0_ALL_MODE_Pos (16)
#define AESCTL0_ALL_MODE_Msk (0x7UL << AESCTL0_ALL_MODE_Pos)

typedef enum
{
    AESCTL0_BIT_MODE_ECB        = 0,  /*!< ECB      */
    AESCTL0_BIT_MODE_CBC        = 1,  /*!< CBC      */
    AESCTL0_BIT_MODE_CTR        = 2,  /*!< CTR      */
    AESCTL0_BIT_MODE_CCM        = 5,  /*!< CCM*     */
    AESCTL0_BIT_MODE_MMO        = 6,  /*!< MMO      */
    AESCTL0_BIT_MODE_BYPASS     = 7,  /*!< BYPASS   */
} AESCTL0_BIT_MODE;

#define AESCTL0_ALL_MODE_ECB        ((0x0UL) << AESCTL0_ALL_MODE_Pos)
#define AESCTL0_ALL_MODE_CBC        ((0x1UL) << AESCTL0_ALL_MODE_Pos)
#define AESCTL0_ALL_MODE_CTR        ((0x2UL) << AESCTL0_ALL_MODE_Pos)
#define AESCTL0_ALL_MODE_CCM        ((0x5UL) << AESCTL0_ALL_MODE_Pos)
#define AESCTL0_ALL_MODE_MMO        ((0x6UL) << AESCTL0_ALL_MODE_Pos)
#define AESCTL0_ALL_MODE_BYPASS     ((0x7UL) << AESCTL0_ALL_MODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL0         CNTMOD
 *  @access     AES->AESCTL0.bit.CNTMOD
 *  @brief      CTR mode's counter modular
 *              modular=2^128:[7'h0-7'hF]
 *              modular=2^ctr_mod: others
 */
#define AESCTL0_ALL_CNTMOD_Pos (19)
#define AESCTL0_ALL_CNTMOD_Msk (0x7FUL << AESCTL0_ALL_CNTMOD_Pos)

#define AESCTL0_BIT_CNTMOD

#define AESCTL0_ALL_CNTMOD_(x) ((x) << AESCTL0_ALL_CNTMOD_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESCTL1         RST
 *  @access     AES->AESCTL1.bit.RST
 *  @brief      Reset AES
 */
#define AESCTL1_ALL_RST_Pos (0)
#define AESCTL1_ALL_RST_Msk (0x1UL << AESCTL1_ALL_RST_Pos)

typedef enum
{
    AESCTL1_BIT_RST_AES_NOT_RESET     = 0,  /*!< Un-reset AES                          */
    AESCTL1_BIT_RST_AES_RESET         = 1,  /*!< Reset AES, please set to 0 manually   */
} AESCTL1_BIT_RST;

#define AESCTL1_ALL_RST_AES_NOT_RESET     ((0x0UL) << AESCTL1_ALL_RST_Pos)
#define AESCTL1_ALL_RST_AES_RESET         ((0x1UL) << AESCTL1_ALL_RST_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTS          DONE
 *  @access     AES->AESSTS.bit.DONE
 *  @brief      AES operation done
 */
#define AESSTS_ALL_DONE_Pos (0)
#define AESSTS_ALL_DONE_Msk (0x1UL << AESSTS_ALL_DONE_Pos)

typedef enum
{
    AESSTS_BIT_DONE_OPERATION_NOT_DONE     = 0,  /*!< AES operation has not done yet   */
    AESSTS_BIT_DONE_OPERATION_DONE         = 1,  /*!< AES operation done               */
} AESSTS_BIT_DONE;

#define AESSTS_ALL_DONE_OPERATION_NOT_DONE     ((0x0UL) << AESSTS_ALL_DONE_Pos)
#define AESSTS_ALL_DONE_OPERATION_DONE         ((0x1UL) << AESSTS_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTS          IFIFOFULL
 *  @access     AES->AESSTS.bit.IFIFOFULL
 *  @brief      Input FIFO full
 */
#define AESSTS_ALL_IFIFOFULL_Pos (4)
#define AESSTS_ALL_IFIFOFULL_Msk (0x1UL << AESSTS_ALL_IFIFOFULL_Pos)

typedef enum
{
    AESSTS_BIT_IFIFOFULL_NOT_FULL     = 0,  /*!< Input FIFO is not full   */
    AESSTS_BIT_IFIFOFULL_FULL         = 1,  /*!< Input FIFO is full       */
} AESSTS_BIT_IFIFOFULL;

#define AESSTS_ALL_IFIFOFULL_NOT_FULL     ((0x0UL) << AESSTS_ALL_IFIFOFULL_Pos)
#define AESSTS_ALL_IFIFOFULL_FULL         ((0x1UL) << AESSTS_ALL_IFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTS          OFIFORDY
 *  @access     AES->AESSTS.bit.OFIFORDY
 *  @brief      Output FIFO is ready to read
 */
#define AESSTS_ALL_OFIFORDY_Pos (6)
#define AESSTS_ALL_OFIFORDY_Msk (0x1UL << AESSTS_ALL_OFIFORDY_Pos)

typedef enum
{
    AESSTS_BIT_OFIFORDY_NOT_READY     = 0,  /*!< Output FIFO is not ready to read   */
    AESSTS_BIT_OFIFORDY_READY         = 1,  /*!< Output FIFO is ready to read       */
} AESSTS_BIT_OFIFORDY;

#define AESSTS_ALL_OFIFORDY_NOT_READY     ((0x0UL) << AESSTS_ALL_OFIFORDY_Pos)
#define AESSTS_ALL_OFIFORDY_READY         ((0x1UL) << AESSTS_ALL_OFIFORDY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTS          OFIFOEMPTY
 *  @access     AES->AESSTS.bit.OFIFOEMPTY
 *  @brief      Output FIFO empty
 */
#define AESSTS_ALL_OFIFOEMPTY_Pos (7)
#define AESSTS_ALL_OFIFOEMPTY_Msk (0x1UL << AESSTS_ALL_OFIFOEMPTY_Pos)

typedef enum
{
    AESSTS_BIT_OFIFOEMPTY_NOT_EMPTY     = 0,  /*!< Output FIFO is not empty   */
    AESSTS_BIT_OFIFOEMPTY_EMPTY         = 1,  /*!< Output FIFO is empty       */
} AESSTS_BIT_OFIFOEMPTY;

#define AESSTS_ALL_OFIFOEMPTY_NOT_EMPTY     ((0x0UL) << AESSTS_ALL_OFIFOEMPTY_Pos)
#define AESSTS_ALL_OFIFOEMPTY_EMPTY         ((0x1UL) << AESSTS_ALL_OFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTS          ERRCODE
 *  @access     AES->AESSTS.bit.ERRCODE
 *  @brief      AES operation error status
 */
#define AESSTS_ALL_ERRCODE_Pos (11)
#define AESSTS_ALL_ERRCODE_Msk (0x7UL << AESSTS_ALL_ERRCODE_Pos)

typedef enum
{
    AESSTS_BIT_ERRCODE_NO_ERROR     = 0,  /*!< No operation error                                                                           */
    AESSTS_BIT_ERRCODE_1            = 1,  /*!< Input stream size less than 16 byte in ECB, CBC and CTR mode                                 */
    AESSTS_BIT_ERRCODE_2            = 2,  /*!< Data is not multiple of 16 bytes in ECB mode or Data is more than 2^13-1 bytes in MMO mode   */
    AESSTS_BIT_ERRCODE_3            = 3,  /*!< Data is not multiple of 16 bytes and less than 16 bytes in ECB mode                          */
    AESSTS_BIT_ERRCODE_4            = 4,  /*!< MIC Mismatch during CCM* Decryption                                                          */
} AESSTS_BIT_ERRCODE;

#define AESSTS_ALL_ERRCODE_NO_ERROR     ((0x0UL) << AESSTS_ALL_ERRCODE_Pos)
#define AESSTS_ALL_ERRCODE_1            ((0x1UL) << AESSTS_ALL_ERRCODE_Pos)
#define AESSTS_ALL_ERRCODE_2            ((0x2UL) << AESSTS_ALL_ERRCODE_Pos)
#define AESSTS_ALL_ERRCODE_3            ((0x3UL) << AESSTS_ALL_ERRCODE_Pos)
#define AESSTS_ALL_ERRCODE_4            ((0x4UL) << AESSTS_ALL_ERRCODE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTS          IFIFODEPTH
 *  @access     AES->AESSTS.bit.IFIFODEPTH
 *  @brief      The input FIFO depth
 */
#define AESSTS_ALL_IFIFODEPTH_Pos (14)
#define AESSTS_ALL_IFIFODEPTH_Msk (0x7UL << AESSTS_ALL_IFIFODEPTH_Pos)

#define AESSTS_BIT_IFIFODEPTH

#define AESSTS_ALL_IFIFODEPTH_(x) ((x) << AESSTS_ALL_IFIFODEPTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTS          OFIFODEPTH
 *  @access     AES->AESSTS.bit.OFIFODEPTH
 *  @brief      The output FIFO depth
 */
#define AESSTS_ALL_OFIFODEPTH_Pos (17)
#define AESSTS_ALL_OFIFODEPTH_Msk (0x7UL << AESSTS_ALL_OFIFODEPTH_Pos)

#define AESSTS_BIT_OFIFODEPTH

#define AESSTS_ALL_OFIFODEPTH_(x) ((x) << AESSTS_ALL_OFIFODEPTH_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESASTRLEN      VAL
 *  @access     AES->AESASTRLEN.bit.VAL
 *  @brief      Size of associate string
 */
#define AESASTRLEN_ALL_VAL_Pos (0)
#define AESASTRLEN_ALL_VAL_Msk (0xFFFFFFFFUL << AESASTRLEN_ALL_VAL_Pos)

#define AESASTRLEN_BIT_VAL

#define AESASTRLEN_ALL_VAL_(x) ((x) << AESASTRLEN_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESMSTRLEN      VAL
 *  @access     AES->AESMSTRLEN.bit.VAL
 *  @brief      Size of message string
 */
#define AESMSTRLEN_ALL_VAL_Pos (0)
#define AESMSTRLEN_ALL_VAL_Msk (0xFFFFFFFFUL << AESMSTRLEN_ALL_VAL_Pos)

#define AESMSTRLEN_BIT_VAL

#define AESMSTRLEN_ALL_VAL_(x) ((x) << AESMSTRLEN_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTRIN        VAL
 *  @access     AES->AESSTRIN.bit.VAL
 *  @brief      Input message word
 */
#define AESSTRIN_ALL_VAL_Pos (0)
#define AESSTRIN_ALL_VAL_Msk (0xFFFFFFFFUL << AESSTRIN_ALL_VAL_Pos)

#define AESSTRIN_BIT_VAL

#define AESSTRIN_ALL_VAL_(x) ((x) << AESSTRIN_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIV0          VAL
 *  @access     AES->AESIV0.bit.VAL
 *  @brief      Byte 0-3 of initial vector
 */
#define AESIV0_ALL_VAL_Pos (0)
#define AESIV0_ALL_VAL_Msk (0xFFFFFFFFUL << AESIV0_ALL_VAL_Pos)

#define AESIV0_BIT_VAL

#define AESIV0_ALL_VAL_(x) ((x) << AESIV0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIV1          VAL
 *  @access     AES->AESIV1.bit.VAL
 *  @brief      Byte 4-7 of initial vector
 */
#define AESIV1_ALL_VAL_Pos (0)
#define AESIV1_ALL_VAL_Msk (0xFFFFFFFFUL << AESIV1_ALL_VAL_Pos)

#define AESIV1_BIT_VAL

#define AESIV1_ALL_VAL_(x) ((x) << AESIV1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIV2          VAL
 *  @access     AES->AESIV2.bit.VAL
 *  @brief      Byte 8-11 of initial vector
 */
#define AESIV2_ALL_VAL_Pos (0)
#define AESIV2_ALL_VAL_Msk (0xFFFFFFFFUL << AESIV2_ALL_VAL_Pos)

#define AESIV2_BIT_VAL

#define AESIV2_ALL_VAL_(x) ((x) << AESIV2_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIV3          VAL
 *  @access     AES->AESIV3.bit.VAL
 *  @brief      Byte 12-15 of initial vector
 */
#define AESIV3_ALL_VAL_Pos (0)
#define AESIV3_ALL_VAL_Msk (0xFFFFFFFFUL << AESIV3_ALL_VAL_Pos)

#define AESIV3_BIT_VAL

#define AESIV3_ALL_VAL_(x) ((x) << AESIV3_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESKEY0         VAL
 *  @access     AES->AESKEY0.bit.VAL
 *  @brief      Byte 0-3 of key
 */
#define AESKEY0_ALL_VAL_Pos (0)
#define AESKEY0_ALL_VAL_Msk (0xFFFFFFFFUL << AESKEY0_ALL_VAL_Pos)

#define AESKEY0_BIT_VAL

#define AESKEY0_ALL_VAL_(x) ((x) << AESKEY0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESKEY1         VAL
 *  @access     AES->AESKEY1.bit.VAL
 *  @brief      Byte 4-7 of key
 */
#define AESKEY1_ALL_VAL_Pos (0)
#define AESKEY1_ALL_VAL_Msk (0xFFFFFFFFUL << AESKEY1_ALL_VAL_Pos)

#define AESKEY1_BIT_VAL

#define AESKEY1_ALL_VAL_(x) ((x) << AESKEY1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESKEY2         VAL
 *  @access     AES->AESKEY2.bit.VAL
 *  @brief      Byte 8-11 of key
 */
#define AESKEY2_ALL_VAL_Pos (0)
#define AESKEY2_ALL_VAL_Msk (0xFFFFFFFFUL << AESKEY2_ALL_VAL_Pos)

#define AESKEY2_BIT_VAL

#define AESKEY2_ALL_VAL_(x) ((x) << AESKEY2_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESKEY3         VAL
 *  @access     AES->AESKEY3.bit.VAL
 *  @brief      Byte 12-15 of key
 */
#define AESKEY3_ALL_VAL_Pos (0)
#define AESKEY3_ALL_VAL_Msk (0xFFFFFFFFUL << AESKEY3_ALL_VAL_Pos)

#define AESKEY3_BIT_VAL

#define AESKEY3_ALL_VAL_(x) ((x) << AESKEY3_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESKEY4         VAL
 *  @access     AES->AESKEY4.bit.VAL
 *  @brief      Byte of 16-19 of key
 */
#define AESKEY4_ALL_VAL_Pos (0)
#define AESKEY4_ALL_VAL_Msk (0xFFFFFFFFUL << AESKEY4_ALL_VAL_Pos)

#define AESKEY4_BIT_VAL

#define AESKEY4_ALL_VAL_(x) ((x) << AESKEY4_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESKEY5         VAL
 *  @access     AES->AESKEY5.bit.VAL
 *  @brief      Byte 20-23 of key
 */
#define AESKEY5_ALL_VAL_Pos (0)
#define AESKEY5_ALL_VAL_Msk (0xFFFFFFFFUL << AESKEY5_ALL_VAL_Pos)

#define AESKEY5_BIT_VAL

#define AESKEY5_ALL_VAL_(x) ((x) << AESKEY5_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESKEY6         VAL
 *  @access     AES->AESKEY6.bit.VAL
 *  @brief      Byte 24-27 of key
 */
#define AESKEY6_ALL_VAL_Pos (0)
#define AESKEY6_ALL_VAL_Msk (0xFFFFFFFFUL << AESKEY6_ALL_VAL_Pos)

#define AESKEY6_BIT_VAL

#define AESKEY6_ALL_VAL_(x) ((x) << AESKEY6_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESKEY7         VAL
 *  @access     AES->AESKEY7.bit.VAL
 *  @brief      Byte 28-31 of key
 */
#define AESKEY7_ALL_VAL_Pos (0)
#define AESKEY7_ALL_VAL_Msk (0xFFFFFFFFUL << AESKEY7_ALL_VAL_Pos)

#define AESKEY7_BIT_VAL

#define AESKEY7_ALL_VAL_(x) ((x) << AESKEY7_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESSTROUT       VAL
 *  @access     AES->AESSTROUT.bit.VAL
 *  @brief      Output message word
 */
#define AESSTROUT_ALL_VAL_Pos (0)
#define AESSTROUT_ALL_VAL_Msk (0xFFFFFFFFUL << AESSTROUT_ALL_VAL_Pos)

#define AESSTROUT_BIT_VAL

#define AESSTROUT_ALL_VAL_(x) ((x) << AESSTROUT_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESOV0          VAL
 *  @access     AES->AESOV0.bit.VAL
 *  @brief      Byte 0-3 of output vector
 */
#define AESOV0_ALL_VAL_Pos (0)
#define AESOV0_ALL_VAL_Msk (0xFFFFFFFFUL << AESOV0_ALL_VAL_Pos)

#define AESOV0_BIT_VAL

#define AESOV0_ALL_VAL_(x) ((x) << AESOV0_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESOV1          VAL
 *  @access     AES->AESOV1.bit.VAL
 *  @brief      Byte 4-7 of output vector
 */
#define AESOV1_ALL_VAL_Pos (0)
#define AESOV1_ALL_VAL_Msk (0xFFFFFFFFUL << AESOV1_ALL_VAL_Pos)

#define AESOV1_BIT_VAL

#define AESOV1_ALL_VAL_(x) ((x) << AESOV1_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESOV2          VAL
 *  @access     AES->AESOV2.bit.VAL
 *  @brief      Byte 8-11 of output vector
 */
#define AESOV2_ALL_VAL_Pos (0)
#define AESOV2_ALL_VAL_Msk (0xFFFFFFFFUL << AESOV2_ALL_VAL_Pos)

#define AESOV2_BIT_VAL

#define AESOV2_ALL_VAL_(x) ((x) << AESOV2_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESOV3          VAL
 *  @access     AES->AESOV3.bit.VAL
 *  @brief      Byte 12-15 of output vector
 */
#define AESOV3_ALL_VAL_Pos (0)
#define AESOV3_ALL_VAL_Msk (0xFFFFFFFFUL << AESOV3_ALL_VAL_Pos)

#define AESOV3_BIT_VAL

#define AESOV3_ALL_VAL_(x) ((x) << AESOV3_ALL_VAL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIF           DONE
 *  @access     AES->AESIF.bit.DONE
 *  @brief      Status of AES operation done interrupt
 */
#define AESIF_ALL_DONE_Pos (0)
#define AESIF_ALL_DONE_Msk (0x1UL << AESIF_ALL_DONE_Pos)

typedef enum
{
    AESIF_BIT_DONE_NOT_OCCUR     = 0,  /*!< AES operation done interrupt not occurred   */
    AESIF_BIT_DONE_OCCUR         = 1,  /*!< AES operation done interrupt occurred       */
} AESIF_BIT_DONE;

#define AESIF_ALL_DONE_NOT_OCCUR     ((0x0UL) << AESIF_ALL_DONE_Pos)
#define AESIF_ALL_DONE_OCCUR         ((0x1UL) << AESIF_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIF           IFIFOFULL
 *  @access     AES->AESIF.bit.IFIFOFULL
 *  @brief      Status of AES input FIFO full interrupt
 */
#define AESIF_ALL_IFIFOFULL_Pos (1)
#define AESIF_ALL_IFIFOFULL_Msk (0x1UL << AESIF_ALL_IFIFOFULL_Pos)

typedef enum
{
    AESIF_BIT_IFIFOFULL_NOT_OCCUR     = 0,  /*!< AES input FIFO full interrupt not occurred   */
    AESIF_BIT_IFIFOFULL_OCCUR         = 1,  /*!< AES input FIFO full interrupt occurred       */
} AESIF_BIT_IFIFOFULL;

#define AESIF_ALL_IFIFOFULL_NOT_OCCUR     ((0x0UL) << AESIF_ALL_IFIFOFULL_Pos)
#define AESIF_ALL_IFIFOFULL_OCCUR         ((0x1UL) << AESIF_ALL_IFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIF           OFIFOEMPTY
 *  @access     AES->AESIF.bit.OFIFOEMPTY
 *  @brief      Status of AES output FIFO empty interrupt
 */
#define AESIF_ALL_OFIFOEMPTY_Pos (2)
#define AESIF_ALL_OFIFOEMPTY_Msk (0x1UL << AESIF_ALL_OFIFOEMPTY_Pos)

typedef enum
{
    AESIF_BIT_OFIFOEMPTY_NOT_OCCUR     = 0,  /*!< AES output FIFO empty interrupt not occurred   */
    AESIF_BIT_OFIFOEMPTY_OCCUR         = 1,  /*!< AES output FIFO empty interrupt occurred       */
} AESIF_BIT_OFIFOEMPTY;

#define AESIF_ALL_OFIFOEMPTY_NOT_OCCUR     ((0x0UL) << AESIF_ALL_OFIFOEMPTY_Pos)
#define AESIF_ALL_OFIFOEMPTY_OCCUR         ((0x1UL) << AESIF_ALL_OFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESINTMSK       DONE
 *  @access     AES->AESINTMSK.bit.DONE
 *  @brief      Mask of AES operation done interrupt
 */
#define AESINTMSK_ALL_DONE_Pos (0)
#define AESINTMSK_ALL_DONE_Msk (0x1UL << AESINTMSK_ALL_DONE_Pos)

typedef enum
{
    AESINTMSK_BIT_DONE_UNMASK     = 0,  /*!< Enable AES operation done interrupt    */
    AESINTMSK_BIT_DONE_MASK       = 1,  /*!< Disable AES operation done interrupt   */
} AESINTMSK_BIT_DONE;

#define AESINTMSK_ALL_DONE_UNMASK     ((0x0UL) << AESINTMSK_ALL_DONE_Pos)
#define AESINTMSK_ALL_DONE_MASK       ((0x1UL) << AESINTMSK_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESINTMSK       IFIFOFULL
 *  @access     AES->AESINTMSK.bit.IFIFOFULL
 *  @brief      Mask of AES input FIFO full interrupt
 */
#define AESINTMSK_ALL_IFIFOFULL_Pos (1)
#define AESINTMSK_ALL_IFIFOFULL_Msk (0x1UL << AESINTMSK_ALL_IFIFOFULL_Pos)

typedef enum
{
    AESINTMSK_BIT_IFIFOFULL_UNMASK     = 0,  /*!< Enable AES input FIFO full interrupt    */
    AESINTMSK_BIT_IFIFOFULL_MASK       = 1,  /*!< Disable AES input FIFO full interrupt   */
} AESINTMSK_BIT_IFIFOFULL;

#define AESINTMSK_ALL_IFIFOFULL_UNMASK     ((0x0UL) << AESINTMSK_ALL_IFIFOFULL_Pos)
#define AESINTMSK_ALL_IFIFOFULL_MASK       ((0x1UL) << AESINTMSK_ALL_IFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESINTMSK       OFIFOEMPTY
 *  @access     AES->AESINTMSK.bit.OFIFOEMPTY
 *  @brief      Mask of AES output FIFO empty interrupt
 */
#define AESINTMSK_ALL_OFIFOEMPTY_Pos (2)
#define AESINTMSK_ALL_OFIFOEMPTY_Msk (0x1UL << AESINTMSK_ALL_OFIFOEMPTY_Pos)

typedef enum
{
    AESINTMSK_BIT_OFIFOEMPTY_UNMASK     = 0,  /*!< Enable AES output FIFO empty interrupt    */
    AESINTMSK_BIT_OFIFOEMPTY_MASK       = 1,  /*!< Disable AES output FIFO empty interrupt   */
} AESINTMSK_BIT_OFIFOEMPTY;

#define AESINTMSK_ALL_OFIFOEMPTY_UNMASK     ((0x0UL) << AESINTMSK_ALL_OFIFOEMPTY_Pos)
#define AESINTMSK_ALL_OFIFOEMPTY_MASK       ((0x1UL) << AESINTMSK_ALL_OFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESRAWIF        DONE
 *  @access     AES->AESRAWIF.bit.DONE
 *  @brief      AES operation done interrupt raw status regardless of mask
 */
#define AESRAWIF_ALL_DONE_Pos (0)
#define AESRAWIF_ALL_DONE_Msk (0x1UL << AESRAWIF_ALL_DONE_Pos)

typedef enum
{
    AESRAWIF_BIT_DONE_NOT_OCCUR     = 0,  /*!< AES operation done interrupt not occurred   */
    AESRAWIF_BIT_DONE_OCCUR         = 1,  /*!< AES operation done interrupt occurred       */
} AESRAWIF_BIT_DONE;

#define AESRAWIF_ALL_DONE_NOT_OCCUR     ((0x0UL) << AESRAWIF_ALL_DONE_Pos)
#define AESRAWIF_ALL_DONE_OCCUR         ((0x1UL) << AESRAWIF_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESRAWIF        IFIFOFULL
 *  @access     AES->AESRAWIF.bit.IFIFOFULL
 *  @brief      AES input FIFO full interrupt raw status regardless of mask
 */
#define AESRAWIF_ALL_IFIFOFULL_Pos (1)
#define AESRAWIF_ALL_IFIFOFULL_Msk (0x1UL << AESRAWIF_ALL_IFIFOFULL_Pos)

typedef enum
{
    AESRAWIF_BIT_IFIFOFULL_NOT_OCCUR     = 0,  /*!< AES no input FIFO full interrupt not occurred   */
    AESRAWIF_BIT_IFIFOFULL_OCCUR         = 1,  /*!< AES no input FIFO full interrupt occurred       */
} AESRAWIF_BIT_IFIFOFULL;

#define AESRAWIF_ALL_IFIFOFULL_NOT_OCCUR     ((0x0UL) << AESRAWIF_ALL_IFIFOFULL_Pos)
#define AESRAWIF_ALL_IFIFOFULL_OCCUR         ((0x1UL) << AESRAWIF_ALL_IFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESRAWIF        OFIFOEMPTY
 *  @access     AES->AESRAWIF.bit.OFIFOEMPTY
 *  @brief      AES output FIFO empty interrupt raw status regardless of mask
 */
#define AESRAWIF_ALL_OFIFOEMPTY_Pos (2)
#define AESRAWIF_ALL_OFIFOEMPTY_Msk (0x1UL << AESRAWIF_ALL_OFIFOEMPTY_Pos)

typedef enum
{
    AESRAWIF_BIT_OFIFOEMPTY_NOT_OCCUR     = 0,  /*!< AES output FIFO empty interrupt not occurred   */
    AESRAWIF_BIT_OFIFOEMPTY_OCCUR         = 1,  /*!< AES output FIFO empty interrupt                */
} AESRAWIF_BIT_OFIFOEMPTY;

#define AESRAWIF_ALL_OFIFOEMPTY_NOT_OCCUR     ((0x0UL) << AESRAWIF_ALL_OFIFOEMPTY_Pos)
#define AESRAWIF_ALL_OFIFOEMPTY_OCCUR         ((0x1UL) << AESRAWIF_ALL_OFIFOEMPTY_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIC           DONE
 *  @access     AES->AESIC.bit.DONE
 *  @brief      Clearance of AES operation done interrupt status and raw status
 */
#define AESIC_ALL_DONE_Pos (0)
#define AESIC_ALL_DONE_Msk (0x1UL << AESIC_ALL_DONE_Pos)

typedef enum
{
    AESIC_BIT_DONE_NO_EFFECT      = 0,  /*!<                                                                                                                    */
    AESIC_BIT_DONE_CLEAR_FLAG     = 1,  /*!< Write '1' will generate a single-cycle pulse that clears both AES operation done interrupt status and raw status   */
} AESIC_BIT_DONE;

#define AESIC_ALL_DONE_NO_EFFECT      ((0x0UL) << AESIC_ALL_DONE_Pos)
#define AESIC_ALL_DONE_CLEAR_FLAG     ((0x1UL) << AESIC_ALL_DONE_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIC           IFIFOFULL
 *  @access     AES->AESIC.bit.IFIFOFULL
 *  @brief      Clearance of AES input FIFO full interrupt status and raw status
 */
#define AESIC_ALL_IFIFOFULL_Pos (1)
#define AESIC_ALL_IFIFOFULL_Msk (0x1UL << AESIC_ALL_IFIFOFULL_Pos)

typedef enum
{
    AESIC_BIT_IFIFOFULL_NO_EFFECT      = 0,  /*!<                                                                                                                     */
    AESIC_BIT_IFIFOFULL_CLEAR_FLAG     = 1,  /*!< Write '1' will generate a single-cycle pulse that clears both AES input FIFO full interrupt status and raw status   */
} AESIC_BIT_IFIFOFULL;

#define AESIC_ALL_IFIFOFULL_NO_EFFECT      ((0x0UL) << AESIC_ALL_IFIFOFULL_Pos)
#define AESIC_ALL_IFIFOFULL_CLEAR_FLAG     ((0x1UL) << AESIC_ALL_IFIFOFULL_Pos)





/**
 *  @hierarchy       Module          Register        Bitfield
 *                   AES             AESIC           OFIFOEMPTY
 *  @access     AES->AESIC.bit.OFIFOEMPTY
 *  @brief      Clearance of AES output FIFO empty interrupt status and raw status
 */
#define AESIC_ALL_OFIFOEMPTY_Pos (2)
#define AESIC_ALL_OFIFOEMPTY_Msk (0x1UL << AESIC_ALL_OFIFOEMPTY_Pos)

typedef enum
{
    AESIC_BIT_OFIFOEMPTY_NO_EFFECT      = 0,  /*!<                                                                                                                       */
    AESIC_BIT_OFIFOEMPTY_CLEAR_FLAG     = 1,  /*!< Write '1' will generate a single-cycle pulse that clears both AES output FIFO empty interrupt status and raw status   */
} AESIC_BIT_OFIFOEMPTY;

#define AESIC_ALL_OFIFOEMPTY_NO_EFFECT      ((0x0UL) << AESIC_ALL_OFIFOEMPTY_Pos)
#define AESIC_ALL_OFIFOEMPTY_CLEAR_FLAG     ((0x1UL) << AESIC_ALL_OFIFOEMPTY_Pos)




#ifdef __cplusplus
}
#endif /* extern "C" */
#endif /* SPC1068_BITFIELD_H */


/******************* (C) COPYRIGHT 2021 SPINTROL LIMITED CO. *****END OF FILE****/
